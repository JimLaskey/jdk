<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavaTokenizer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.parser;
  27 
  28 import com.sun.tools.javac.code.Lint;
  29 import com.sun.tools.javac.code.Lint.LintCategory;
  30 import com.sun.tools.javac.code.Preview;
  31 import com.sun.tools.javac.code.Source;
  32 import com.sun.tools.javac.code.Source.Feature;
  33 import com.sun.tools.javac.file.JavacFileManager;
  34 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  35 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  36 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  37 import com.sun.tools.javac.util.*;
  38 import com.sun.tools.javac.util.JCDiagnostic.*;
  39 
  40 import java.nio.CharBuffer;
  41 import java.util.Set;
  42 import java.util.regex.Pattern;
  43 
  44 import static com.sun.tools.javac.parser.Tokens.*;
  45 import static com.sun.tools.javac.util.LayoutCharacters.EOI;
  46 
  47 /**
  48  * The lexical analyzer maps an input stream consisting of UTF-8 characters and unicode
  49  * escape sequences into a token sequence.
  50  *
  51  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  52  *  If you write code that depends on this, you do so at your own risk.
  53  *  This code and its internal interfaces are subject to change or
  54  *  deletion without notice.&lt;/b&gt;
  55  */
  56 public class JavaTokenizer extends UnicodeReader {
  57     /**
  58      * If true then prints token information after each nextToken().
  59      */
  60     private static final boolean scannerDebug = false;
  61 
  62     /**
  63      * Sentinal for non-value.
  64      */
  65     private int NOT_FOUND = -1;
  66 
  67     /**
  68      * The source language setting. Copied from scanner factory.
  69      */
  70     private Source source;
  71 
  72     /**
  73      * The preview language setting. Copied from scanner factory.
  74      */
  75     private Preview preview;
  76 
  77     /**
  78      * The log to be used for error reporting. Copied from scanner factory.
  79      */
  80     private final Log log;
  81 
  82     /**
  83      * The token factory. Copied from scanner factory.
  84      */
  85     private final Tokens tokens;
  86 
  87     /**
  88      * The names factory. Copied from scanner factory.
  89      */
  90     private final Names names;
  91 
  92     /**
  93      * The token kind, set by nextToken().
  94      */
  95     protected TokenKind tk;
  96 
  97     /**
  98      * The token&#39;s radix, set by nextToken().
  99      */
 100     protected int radix;
 101 
 102     /**
 103      * The token&#39;s name, set by nextToken().
 104      */
 105     protected Name name;
 106 
 107     /**
 108      * The position where a lexical error occurred;
 109      */
 110     protected int errPos = Position.NOPOS;
 111 
 112     /**
 113      * true if is a text block, set by nextToken().
 114      */
 115     protected boolean isTextBlock;
 116 
 117     /**
 118      * true if contains escape sequences, set by nextToken().
 119      */
 120     protected boolean hasEscapeSequences;
 121 
 122     /**
 123      * Buffer for building literals, used by nextToken().
 124      */
 125     protected StringBuilder sb;
 126 
 127     /**
 128      * Origin scanner factory.
 129      */
 130     protected ScannerFactory fac;
 131 
 132     /**
 133      * The set of lint options currently in effect. It is initialized
 134      * from the context, and then is set/reset as needed by Attr as it
 135      * visits all the various parts of the trees during attribution.
 136      */
 137     protected Lint lint;
 138 
 139     /**
 140      * Construct a Java token scanner from the input character buffer.
 141      *
 142      * @param fac  the factory which created this Scanner.
 143      * @param cb   the input character buffer.
 144      */
 145     protected JavaTokenizer(ScannerFactory fac, CharBuffer cb) {
 146         this(fac, JavacFileManager.toArray(cb), cb.limit());
 147     }
 148 
 149     /**
 150      * Construct a Java token scanner from the input character array.
 151      *
 152      * @param fac     the factory which created this Scanner
 153      * @param array   the input character array.
 154      * @param length  The length of the meaningful content in the array.
 155      */
 156     protected JavaTokenizer(ScannerFactory fac, char[] array, int length) {
 157         super(fac, array, length);
 158         this.fac = fac;
 159         this.log = fac.log;
 160         this.names = fac.names;
 161         this.tokens = fac.tokens;
 162         this.source = fac.source;
 163         this.preview = fac.preview;
 164         this.lint = fac.lint;
 165         this.sb = new StringBuilder(256);
 166     }
 167 
 168     /**
 169      * Check the source level for a lexical feature.
 170      *
 171      * @param pos      position in input buffer.
 172      * @param feature  feature to verify.
 173      */
 174     protected void checkSourceLevel(int pos, Feature feature) {
 175         if (preview.isPreview(feature) &amp;&amp; !preview.isEnabled()) {
 176             //preview feature without --preview flag, error
 177             lexError(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));
 178         } else if (!feature.allowedInSource(source)) {
 179             //incompatible source level, error
 180             lexError(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));
 181         } else if (preview.isPreview(feature)) {
 182             //use of preview feature, warn
 183             preview.warnPreview(pos, feature);
 184         }
 185     }
 186 
 187     /**
 188      * Report an error at the given position using the provided arguments.
 189      *
 190      * @param pos  position in input buffer.
 191      * @param key  error key to report.
 192      */
 193     protected void lexError(int pos, JCDiagnostic.Error key) {
 194         log.error(pos, key);
 195         tk = TokenKind.ERROR;
 196         errPos = pos;
 197     }
 198 
 199     /**
 200      * Report an error at the given position using the provided arguments.
 201      *
 202      * @param flags  diagnostic flags.
 203      * @param pos    position in input buffer.
 204      * @param key    error key to report.
 205      */
 206     protected void lexError(DiagnosticFlag flags, int pos, JCDiagnostic.Error key) {
 207         log.error(flags, pos, key);
 208         tk = TokenKind.ERROR;
 209         errPos = pos;
 210     }
 211 
 212     /**
 213      * Report an error at the given position using the provided arguments.
 214      *
 215      * @param lc     lint category.
 216      * @param pos    position in input buffer.
 217      * @param key    error key to report.
 218      */
 219     protected void lexWarning(LintCategory lc, int pos, JCDiagnostic.Warning key) {
 220         DiagnosticPosition dp = new SimpleDiagnosticPosition(pos) ;
 221         log.warning(lc, dp, key);
 222     }
 223 
 224     /**
 225      * Add a character to the literal buffer.
 226      *
 227      * @param ch  character to add.
 228      */
 229     protected void put(char ch) {
 230         sb.append(ch);
 231     }
 232 
 233     /**
 234      * Add a codepoint to the literal buffer.
 235      *
 236      * @param codePoint  codepoint to add.
 237      */
 238     protected void putCodePoint(int codePoint) {
 239         sb.appendCodePoint(codePoint);
 240     }
 241 
 242     /**
 243      * Add current character or codepoint to the literal buffer.
 244      */
 245     protected void put() {
 246         if (isSurrogate()) {
 247             putCodePoint(getCodepoint());
 248         } else {
 249             put(get());
 250         }
 251     }
 252 
 253     /**
 254      * Add a string to the literal buffer.
 255      */
 256     protected void put(String string) {
 257         sb.append(string);
 258     }
 259 
 260     /**
 261      * Add current character or codepoint to the literal buffer then return next character.
 262      */
 263     protected char putThenNext() {
 264         put();
 265 
 266         return next();
 267     }
 268 
 269     /**
 270      * If the specified character ch matches the current character then add current character
 271      * to the literal buffer and then advance.
 272      *
 273      * @param ch  character to match.
 274      *
 275      * @return true if ch matches current character.
 276      */
 277     protected boolean acceptThenPut(char ch) {
 278         if (is(ch)) {
 279             put(get());
 280             next();
 281 
 282             return true;
 283         }
 284 
 285         return false;
 286     }
 287 
 288     /**
 289      * If either ch1 or ch2 matches the current character then add current character
 290      * to the literal buffer and then advance.
 291      *
 292      * @param ch1  first character to match.
 293      * @param ch2  second character to match.
 294      *
 295      * @return true if either ch1 or ch2 matches current character.
 296      */
 297     protected boolean acceptOneOfThenPut(char ch1, char ch2) {
 298         if (isOneOf(ch1, ch2)) {
 299             put(get());
 300             next();
 301 
 302             return true;
 303         }
 304 
 305         return false;
 306     }
 307 
 308     /**
 309      * Test if the current character is a line terminator.
 310      *
 311      * @return true if current character is a line terminator.
 312      */
 313     private boolean isEOLN() {
 314         return isOneOf(&#39;\n&#39;, &#39;\r&#39;);
 315     }
 316 
 317     /**
 318      * Skip and process a line terminator sequence.
 319      */
 320     private void skipLineTerminator() {
 321         int start = position();
 322         accept(&#39;\r&#39;);
 323         accept(&#39;\n&#39;);
 324         processLineTerminator(start, position());
 325     }
 326 
 327     /**
 328      * Processes the current character and places in the literal buffer. If the current
 329      * character is a backslash then the next character is validated as a proper
 330      * escape character. Conversion of escape sequences takes place at end of nextToken().
 331      *
 332      * @param pos position of the first character in literal.
 333      */
 334     private void scanLitChar(int pos) {
 335         if (acceptThenPut(&#39;\\&#39;)) {
 336             hasEscapeSequences = true;
 337 
 338             switch (get()) {
 339                 case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;:
 340                 case &#39;4&#39;: case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;:
 341                     char leadch = get();
 342                     putThenNext();
 343 
 344                     if (inRange(&#39;0&#39;, &#39;7&#39;)) {
 345                         putThenNext();
 346 
 347                         if (leadch &lt;= &#39;3&#39; &amp;&amp; inRange(&#39;0&#39;, &#39;7&#39;)) {
 348                             putThenNext();
 349                         }
 350                     }
 351                     break;
 352 
 353                 case &#39;b&#39;:
 354                 case &#39;t&#39;:
 355                 case &#39;n&#39;:
 356                 case &#39;f&#39;:
 357                 case &#39;r&#39;:
 358                 case &#39;\&#39;&#39;:
 359                 case &#39;\&quot;&#39;:
 360                 case &#39;\\&#39;:
 361                     putThenNext();
 362                     break;
 363 
 364                 case &#39;s&#39;:
 365                     checkSourceLevel(position(), Feature.TEXT_BLOCKS);
 366                     putThenNext();
 367                     break;
 368 
 369                 case &#39;\n&#39;:
 370                 case &#39;\r&#39;:
 371                     if (isTextBlock) {
 372                         skipLineTerminator();
 373                         // Normalize line terminator.
 374                         put(&#39;\n&#39;);
 375                     } else {
 376                         lexError(position(), Errors.IllegalEscChar);
 377                     }
 378                     break;
 379 
 380                 default:
 381                     lexError(position(), Errors.IllegalEscChar);
 382                     break;
 383             }
 384         } else {
 385             putThenNext();
 386         }
 387     }
 388 
 389     /**
 390      * Scan a string literal or text block.
 391      *
 392      * @param pos  position of the first character in literal.
 393      */
 394     private void scanString(int pos) {
 395         // Assume the best.
 396         tk = Tokens.TokenKind.STRINGLITERAL;
 397         // Track the end of first line for error recovery.
 398         int firstEOLN = NOT_FOUND;
 399         // Check for text block delimiter.
 400         isTextBlock = accept(&quot;\&quot;\&quot;\&quot;&quot;);
 401 
 402         if (isTextBlock) {
 403             // Check if preview feature is enabled for text blocks.
 404             checkSourceLevel(pos, Feature.TEXT_BLOCKS);
 405 
 406             // Verify the open delimiter sequence.
 407             // Error if the open delimiter sequence is not &quot;&quot;&quot;&lt;white space&gt;*&lt;LineTerminator&gt;.
 408             skipWhitespace();
 409 
 410             if (isEOLN()) {
 411                 skipLineTerminator();
 412             } else {
 413                 lexError(position(), Errors.IllegalTextBlockOpen);
 414                 return;
 415             }
 416 
 417             // While characters are available.
 418             while (isAvailable()) {
 419                 if (accept(&quot;\&quot;\&quot;\&quot;&quot;)) {
 420                     return;
 421                 }
 422 
 423                 if (isEOLN()) {
 424                     skipLineTerminator();
 425                     // Add normalized line terminator to literal buffer.
 426                     put(&#39;\n&#39;);
 427 
 428                     // Record first line terminator for error recovery.
 429                     if (firstEOLN == NOT_FOUND) {
 430                         firstEOLN = position();
 431                     }
 432                 } else {
 433                     // Add character to string buffer.
 434                     scanLitChar(pos);
 435                 }
 436             }
 437         } else {
 438             // Skip first quote.
 439             next();
 440 
 441             // While characters are available.
 442             while (isAvailable()) {
 443                 if (accept(&#39;\&quot;&#39;)) {
 444                     return;
 445                 }
 446 
 447                 if (isEOLN()) {
 448                     // Line terminator in string literal is an error.
 449                     // Fall out to unclosed string literal error.
 450                     break;
 451                 } else {
 452                     // Add character to string buffer.
 453                     scanLitChar(pos);
 454                 }
 455             }
 456         }
 457 
 458         // String ended without close delimiter sequence.
 459         lexError(pos, isTextBlock ? Errors.UnclosedTextBlock : Errors.UnclosedStrLit);
 460 
 461         if (firstEOLN  != NOT_FOUND) {
 462             // Reset recovery position to point after text block open delimiter sequence.
 463             reset(firstEOLN);
 464         }
 465     }
 466 
 467     /**
 468      * Scan sequence of digits.
 469      *
 470      * @param pos         position of the first character in literal.
 471      * @param digitRadix  radix of numeric literal.
 472      */
 473     private void scanDigits(int pos, int digitRadix) {
 474         int leadingUnderscorePos = is(&#39;_&#39;) ? position() : NOT_FOUND;
 475         int trailingUnderscorePos;
 476 
 477         do {
 478             if (!is(&#39;_&#39;)) {
 479                 put();
 480                 trailingUnderscorePos = NOT_FOUND;
 481             } else {
 482                 trailingUnderscorePos = position();
 483             }
 484 
 485             next();
 486         } while (digit(pos, digitRadix) &gt;= 0 || is(&#39;_&#39;));
 487 
 488         if (leadingUnderscorePos != NOT_FOUND) {
 489             lexError(leadingUnderscorePos, Errors.IllegalUnderscore);
 490         } else if (trailingUnderscorePos != NOT_FOUND) {
 491             lexError(trailingUnderscorePos, Errors.IllegalUnderscore);
 492         }
 493     }
 494 
 495     /**
 496      * Read fractional part of hexadecimal floating point number.
 497      *
 498      * @param pos  position of the first character in literal.
 499      */
 500     private void scanHexExponentAndSuffix(int pos) {
 501         if (acceptOneOfThenPut(&#39;p&#39;, &#39;P&#39;)) {
 502             skipIllegalUnderscores();
 503             acceptOneOfThenPut(&#39;+&#39;, &#39;-&#39;);
 504             skipIllegalUnderscores();
 505 
 506             if (digit(pos, 10) &gt;= 0) {
 507                 scanDigits(pos, 10);
 508             } else {
 509                 lexError(pos, Errors.MalformedFpLit);
 510             }
 511         } else {
 512             lexError(pos, Errors.MalformedFpLit);
 513         }
 514 
 515         if (acceptOneOfThenPut(&#39;f&#39;, &#39;F&#39;)) {
 516             tk = TokenKind.FLOATLITERAL;
 517             radix = 16;
 518         } else {
 519             acceptOneOfThenPut(&#39;d&#39;, &#39;D&#39;);
 520             tk = TokenKind.DOUBLELITERAL;
 521             radix = 16;
 522         }
 523     }
 524 
 525     /**
 526      * Read fractional part of floating point number.
 527      *
 528      * @param pos  position of the first character in literal.
 529      */
 530     private void scanFraction(int pos) {
 531         skipIllegalUnderscores();
 532 
 533         if (digit(pos, 10) &gt;= 0) {
 534             scanDigits(pos, 10);
 535         }
 536 
 537         int index = sb.length();
 538 
 539         if (acceptOneOfThenPut(&#39;e&#39;, &#39;E&#39;)) {
 540             skipIllegalUnderscores();
 541             acceptOneOfThenPut(&#39;+&#39;, &#39;-&#39;);
 542             skipIllegalUnderscores();
 543 
 544             if (digit(pos, 10) &gt;= 0) {
 545                 scanDigits(pos, 10);
 546                 return;
 547             }
 548 
 549             lexError(pos, Errors.MalformedFpLit);
 550             sb.setLength(index);
 551         }
 552     }
 553 
 554     /**
 555      * Read fractional part and &#39;d&#39; or &#39;f&#39; suffix of floating point number.
 556      *
 557      * @param pos  position of the first character in literal.
 558      */
 559     private void scanFractionAndSuffix(int pos) {
 560         radix = 10;
 561         scanFraction(pos);
 562 
 563         if (acceptOneOfThenPut(&#39;f&#39;, &#39;F&#39;)) {
 564              tk = TokenKind.FLOATLITERAL;
 565         } else {
 566             acceptOneOfThenPut(&#39;d&#39;, &#39;D&#39;);
 567             tk = TokenKind.DOUBLELITERAL;
 568         }
 569     }
 570 
 571     /**
 572      * Read fractional part and &#39;d&#39; or &#39;f&#39; suffix of hexadecimal floating point number.
 573      *
 574      * @param pos  position of the first character in literal.
 575      */
 576     private void scanHexFractionAndSuffix(int pos, boolean seendigit) {
 577         radix = 16;
 578         Assert.check(is(&#39;.&#39;));
 579         putThenNext();
 580         skipIllegalUnderscores();
 581 
 582         if (digit(pos, 16) &gt;= 0) {
 583             seendigit = true;
 584             scanDigits(pos, 16);
 585         }
 586 
 587         if (!seendigit)
 588             lexError(pos, Errors.InvalidHexNumber);
 589         else
 590             scanHexExponentAndSuffix(pos);
 591     }
 592 
 593     /**
 594      * Skip over underscores and report as a error if found.
 595      */
 596     private void skipIllegalUnderscores() {
 597         if (is(&#39;_&#39;)) {
 598             lexError(position(), Errors.IllegalUnderscore);
 599             skip(&#39;_&#39;);
 600         }
 601     }
 602 
 603     /**
 604      * Read a number. (Spec. 3.10)
 605      *
 606      * @param pos    position of the first character in literal.
 607      * @param radix  the radix of the number; one of 2, 8, 10, 16.
 608      */
 609     private void scanNumber(int pos, int radix) {
 610         // for octal, allow base-10 digit in case it&#39;s a float literal
 611         this.radix = radix;
 612         int digitRadix = (radix == 8 ? 10 : radix);
 613         int firstDigit = digit(pos, Math.max(10, digitRadix));
 614         boolean seendigit = firstDigit &gt;= 0;
 615         boolean seenValidDigit = firstDigit &gt;= 0 &amp;&amp; firstDigit &lt; digitRadix;
 616 
 617         if (seendigit) {
 618             scanDigits(pos, digitRadix);
 619         }
 620 
 621         if (radix == 16 &amp;&amp; is(&#39;.&#39;)) {
 622             scanHexFractionAndSuffix(pos, seendigit);
 623         } else if (seendigit &amp;&amp; radix == 16 &amp;&amp; isOneOf(&#39;p&#39;, &#39;P&#39;)) {
 624             scanHexExponentAndSuffix(pos);
 625         } else if (digitRadix == 10 &amp;&amp; is(&#39;.&#39;)) {
 626             putThenNext();
 627             scanFractionAndSuffix(pos);
 628         } else if (digitRadix == 10 &amp;&amp; isOneOf(&#39;e&#39;, &#39;E&#39;, &#39;f&#39;, &#39;F&#39;, &#39;d&#39;, &#39;D&#39;)) {
 629             scanFractionAndSuffix(pos);
 630         } else {
 631             if (!seenValidDigit) {
 632                 switch (radix) {
 633                 case 2:
 634                     lexError(pos, Errors.InvalidBinaryNumber);
 635                     break;
 636                 case 16:
 637                     lexError(pos, Errors.InvalidHexNumber);
 638                     break;
 639                 }
 640             }
 641 
 642             if (acceptOneOf(&#39;l&#39;, &#39;L&#39;)) {
 643                 tk = TokenKind.LONGLITERAL;
 644             } else {
 645                 tk = TokenKind.INTLITERAL;
 646             }
 647         }
 648     }
 649 
 650     /**
 651      * Determines if the sequence in the literal buffer is a token (keyword, operator.)
 652      */
 653     private void checkIdent() {
 654         name = names.fromString(sb.toString());
 655         tk = tokens.lookupKind(name);
 656     }
 657 
 658     /**
 659      * Read an identifier. (Spec. 3.8)
 660      */
 661     private void scanIdent() {
 662         putThenNext();
 663 
 664         do {
 665             switch (get()) {
 666             case &#39;A&#39;: case &#39;B&#39;: case &#39;C&#39;: case &#39;D&#39;: case &#39;E&#39;:
 667             case &#39;F&#39;: case &#39;G&#39;: case &#39;H&#39;: case &#39;I&#39;: case &#39;J&#39;:
 668             case &#39;K&#39;: case &#39;L&#39;: case &#39;M&#39;: case &#39;N&#39;: case &#39;O&#39;:
 669             case &#39;P&#39;: case &#39;Q&#39;: case &#39;R&#39;: case &#39;S&#39;: case &#39;T&#39;:
 670             case &#39;U&#39;: case &#39;V&#39;: case &#39;W&#39;: case &#39;X&#39;: case &#39;Y&#39;:
 671             case &#39;Z&#39;:
 672             case &#39;a&#39;: case &#39;b&#39;: case &#39;c&#39;: case &#39;d&#39;: case &#39;e&#39;:
 673             case &#39;f&#39;: case &#39;g&#39;: case &#39;h&#39;: case &#39;i&#39;: case &#39;j&#39;:
 674             case &#39;k&#39;: case &#39;l&#39;: case &#39;m&#39;: case &#39;n&#39;: case &#39;o&#39;:
 675             case &#39;p&#39;: case &#39;q&#39;: case &#39;r&#39;: case &#39;s&#39;: case &#39;t&#39;:
 676             case &#39;u&#39;: case &#39;v&#39;: case &#39;w&#39;: case &#39;x&#39;: case &#39;y&#39;:
 677             case &#39;z&#39;:
 678             case &#39;$&#39;: case &#39;_&#39;:
 679             case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
 680             case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:
 681                 break;
 682 
 683             case &#39;\u0000&#39;: case &#39;\u0001&#39;: case &#39;\u0002&#39;: case &#39;\u0003&#39;:
 684             case &#39;\u0004&#39;: case &#39;\u0005&#39;: case &#39;\u0006&#39;: case &#39;\u0007&#39;:
 685             case &#39;\u0008&#39;: case &#39;\u000E&#39;: case &#39;\u000F&#39;: case &#39;\u0010&#39;:
 686             case &#39;\u0011&#39;: case &#39;\u0012&#39;: case &#39;\u0013&#39;: case &#39;\u0014&#39;:
 687             case &#39;\u0015&#39;: case &#39;\u0016&#39;: case &#39;\u0017&#39;:
 688             case &#39;\u0018&#39;: case &#39;\u0019&#39;: case &#39;\u001B&#39;:
 689             case &#39;\u007F&#39;:
 690                 next();
 691                 continue;
 692 
 693             case &#39;\u001A&#39;: // EOI is also a legal identifier part
 694                 if (isAvailable()) {
 695                     next();
 696                     continue;
 697                 }
 698 
 699                 checkIdent();
 700                 return;
 701 
 702             default:
 703                 boolean isJavaIdentifierPart;
 704 
 705                 if (isASCII()) {
 706                     // all ASCII range chars already handled, above
 707                     isJavaIdentifierPart = false;
 708                 } else {
 709                     if (Character.isIdentifierIgnorable(get())) {
 710                         next();
 711                         continue;
 712                     }
 713 
 714                     isJavaIdentifierPart = isSurrogate()
 715                             ? Character.isJavaIdentifierPart(getCodepoint())
 716                             : Character.isJavaIdentifierPart(get());
 717                 }
 718 
 719                 if (!isJavaIdentifierPart) {
 720                     checkIdent();
 721                     return;
 722                 }
 723             }
 724 
 725             putThenNext();
 726         } while (true);
 727     }
 728 
 729     /**
 730      * Return true if ch can be part of an operator.
 731      *
 732      * @param ch  character to check.
 733      *
 734      * @return true if ch can be part of an operator.
 735      */
 736     private boolean isSpecial(char ch) {
 737         switch (ch) {
 738         case &#39;!&#39;: case &#39;%&#39;: case &#39;&amp;&#39;: case &#39;*&#39;: case &#39;?&#39;:
 739         case &#39;+&#39;: case &#39;-&#39;: case &#39;:&#39;: case &#39;&lt;&#39;: case &#39;=&#39;:
 740         case &#39;&gt;&#39;: case &#39;^&#39;: case &#39;|&#39;: case &#39;~&#39;:
 741         case &#39;@&#39;:
 742             return true;
 743 
 744         default:
 745             return false;
 746         }
 747     }
 748 
 749     /**
 750      * Read longest possible sequence of special characters and convert to token.
 751      */
 752     private void scanOperator() {
 753         while (true) {
 754             put();
 755             TokenKind newtk = tokens.lookupKind(sb.toString());
 756 
 757             if (newtk == TokenKind.IDENTIFIER) {
 758                 sb.setLength(sb.length() - 1);
 759                 break;
 760             }
 761 
 762             tk = newtk;
 763             next();
 764 
 765             if (!isSpecial(get())) {
 766                 break;
 767             }
 768         }
 769     }
 770 
 771     /**
 772      * Read token (main entrypoint.)
 773      */
 774     public Token readToken() {
 775         sb.setLength(0);
 776         name = null;
 777         radix = 0;
 778         isTextBlock = false;
 779         hasEscapeSequences = false;
 780 
 781         int pos;
 782         List&lt;Comment&gt; comments = null;
 783 
 784         try {
 785             loop: while (true) {
 786                 pos = position();
 787 
 788                 switch (get()) {
 789                 case &#39; &#39;:  // (Spec 3.6)
 790                 case &#39;\t&#39;: // (Spec 3.6)
 791                 case &#39;\f&#39;: // (Spec 3.6)
 792                     skipWhitespace();
 793                     processWhiteSpace(pos, position());
 794                     break;
 795 
 796                 case &#39;\n&#39;: // (Spec 3.4)
 797                     next();
 798                     processLineTerminator(pos, position());
 799                     break;
 800 
 801                 case &#39;\r&#39;: // (Spec 3.4)
 802                     next();
 803                     accept(&#39;\n&#39;);
 804                     processLineTerminator(pos, position());
 805                     break;
 806 
 807                 case &#39;A&#39;: case &#39;B&#39;: case &#39;C&#39;: case &#39;D&#39;: case &#39;E&#39;:
 808                 case &#39;F&#39;: case &#39;G&#39;: case &#39;H&#39;: case &#39;I&#39;: case &#39;J&#39;:
 809                 case &#39;K&#39;: case &#39;L&#39;: case &#39;M&#39;: case &#39;N&#39;: case &#39;O&#39;:
 810                 case &#39;P&#39;: case &#39;Q&#39;: case &#39;R&#39;: case &#39;S&#39;: case &#39;T&#39;:
 811                 case &#39;U&#39;: case &#39;V&#39;: case &#39;W&#39;: case &#39;X&#39;: case &#39;Y&#39;:
 812                 case &#39;Z&#39;:
 813                 case &#39;a&#39;: case &#39;b&#39;: case &#39;c&#39;: case &#39;d&#39;: case &#39;e&#39;:
 814                 case &#39;f&#39;: case &#39;g&#39;: case &#39;h&#39;: case &#39;i&#39;: case &#39;j&#39;:
 815                 case &#39;k&#39;: case &#39;l&#39;: case &#39;m&#39;: case &#39;n&#39;: case &#39;o&#39;:
 816                 case &#39;p&#39;: case &#39;q&#39;: case &#39;r&#39;: case &#39;s&#39;: case &#39;t&#39;:
 817                 case &#39;u&#39;: case &#39;v&#39;: case &#39;w&#39;: case &#39;x&#39;: case &#39;y&#39;:
 818                 case &#39;z&#39;:
 819                 case &#39;$&#39;: case &#39;_&#39;: // (Spec. 3.8)
 820                     scanIdent();
 821                     break loop;
 822 
 823                 case &#39;0&#39;: // (Spec. 3.10)
 824                     next();
 825 
 826                     if (acceptOneOf(&#39;x&#39;, &#39;X&#39;)) {
 827                         skipIllegalUnderscores();
 828                         scanNumber(pos, 16);
 829                     } else if (acceptOneOf(&#39;b&#39;, &#39;B&#39;)) {
 830                         skipIllegalUnderscores();
 831                         scanNumber(pos, 2);
 832                     } else {
 833                         put(&#39;0&#39;);
 834 
 835                         if (is(&#39;_&#39;)) {
 836                             int savePos = position();
 837                             skip(&#39;_&#39;);
 838 
 839                             if (digit(pos, 10) &lt; 0) {
 840                                 lexError(savePos, Errors.IllegalUnderscore);
 841                             }
 842                         }
 843 
 844                         scanNumber(pos, 8);
 845                     }
 846                     break loop;
 847 
 848                 case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
 849                 case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:  // (Spec. 3.10)
 850                     scanNumber(pos, 10);
 851                     break loop;
 852 
 853                 case &#39;.&#39;: // (Spec. 3.12)
 854                     if (accept(&quot;...&quot;)) {
 855                         put(&quot;...&quot;);
 856                         tk = TokenKind.ELLIPSIS;
 857                     } else {
 858                         next();
 859                         int savePos = position();
 860 
 861                         if (accept(&#39;.&#39;)) {
 862                             lexError(savePos, Errors.IllegalDot);
 863                         } else if (digit(pos, 10) &gt;= 0) {
 864                             put(&#39;.&#39;);
 865                             scanFractionAndSuffix(pos); // (Spec. 3.10)
 866                         } else {
 867                             tk = TokenKind.DOT;
 868                         }
 869                     }
 870                     break loop;
 871 
 872                 case &#39;,&#39;: // (Spec. 3.12)
 873                     next();
 874                     tk = TokenKind.COMMA;
 875                     break loop;
 876 
 877                 case &#39;;&#39;: // (Spec. 3.12)
 878                     next();
 879                     tk = TokenKind.SEMI;
 880                     break loop;
 881 
 882                 case &#39;(&#39;: // (Spec. 3.12)
 883                     next();
 884                     tk = TokenKind.LPAREN;
 885                     break loop;
 886 
 887                 case &#39;)&#39;: // (Spec. 3.12)
 888                     next();
 889                     tk = TokenKind.RPAREN;
 890                     break loop;
 891 
 892                 case &#39;[&#39;: // (Spec. 3.12)
 893                     next();
 894                     tk = TokenKind.LBRACKET;
 895                     break loop;
 896 
 897                 case &#39;]&#39;: // (Spec. 3.12)
 898                     next();
 899                     tk = TokenKind.RBRACKET;
 900                     break loop;
 901 
 902                 case &#39;{&#39;: // (Spec. 3.12)
 903                     next();
 904                     tk = TokenKind.LBRACE;
 905                     break loop;
 906 
 907                 case &#39;}&#39;: // (Spec. 3.12)
 908                     next();
 909                     tk = TokenKind.RBRACE;
 910                     break loop;
 911 
 912                 case &#39;/&#39;:
 913                     next();
 914 
 915                     if (accept(&#39;/&#39;)) { // (Spec. 3.7)
 916                         skipToEOLN();
 917 
 918                         if (isAvailable()) {
 919                             comments = appendComment(comments, processComment(pos, position(), CommentStyle.LINE));
 920                         }
 921                         break;
 922                     } else if (accept(&#39;*&#39;)) { // (Spec. 3.7)
 923                         boolean isEmpty = false;
 924                         CommentStyle style;
 925 
 926                         if (accept(&#39;*&#39;)) {
 927                             style = CommentStyle.JAVADOC;
 928 
 929                             if (is(&#39;/&#39;)) {
 930                                 isEmpty = true;
 931                             }
 932                         } else {
 933                             style = CommentStyle.BLOCK;
 934                         }
 935 
 936                         if (!isEmpty) {
 937                             while (isAvailable()) {
 938                                 if (accept(&#39;*&#39;)) {
 939                                     if (is(&#39;/&#39;)) {
 940                                         break;
 941                                     }
 942                                 } else {
 943                                     next();
 944                                 }
 945                             }
 946                         }
 947 
 948                         if (accept(&#39;/&#39;)) {
 949                             comments = appendComment(comments, processComment(pos, position(), style));
 950 
 951                             break;
 952                         } else {
 953                             lexError(pos, Errors.UnclosedComment);
 954 
 955                             break loop;
 956                         }
 957                     } else if (accept(&#39;=&#39;)) {
 958                         tk = TokenKind.SLASHEQ; // (Spec. 3.12)
 959                     } else {
 960                         tk = TokenKind.SLASH; // (Spec. 3.12)
 961                     }
 962                     break loop;
 963 
 964                 case &#39;\&#39;&#39;: // (Spec. 3.10)
 965                     next();
 966 
 967                     if (accept(&#39;\&#39;&#39;)) {
 968                         lexError(pos, Errors.EmptyCharLit);
 969                     } else {
 970                         if (isEOLN()) {
 971                             lexError(pos, Errors.IllegalLineEndInCharLit);
 972                         }
 973 
 974                         scanLitChar(pos);
 975 
 976                         if (accept(&#39;\&#39;&#39;)) {
 977                             tk = TokenKind.CHARLITERAL;
 978                         } else {
 979                             lexError(pos, Errors.UnclosedCharLit);
 980                         }
 981                     }
 982                     break loop;
 983 
 984                 case &#39;\&quot;&#39;: // (Spec. 3.10)
 985                     scanString(pos);
 986                     break loop;
 987 
 988                 default:
 989                     if (isSpecial(get())) {
 990                         scanOperator();
 991                     } else {
 992                         boolean isJavaIdentifierStart;
 993 
 994                         if (isASCII()) {
 995                             // all ASCII range chars already handled, above
 996                             isJavaIdentifierStart = false;
 997                         } else {
 998                             isJavaIdentifierStart = isSurrogate()
 999                                     ? Character.isJavaIdentifierStart(getCodepoint())
1000                                     : Character.isJavaIdentifierStart(get());
1001                         }
1002 
1003                         if (isJavaIdentifierStart) {
1004                             scanIdent();
1005                         } else if (digit(pos, 10) &gt;= 0) {
1006                             scanNumber(pos, 10);
1007                         } else if (is((char)EOI) || !isAvailable()) {
1008                             tk = TokenKind.EOF;
1009                             pos = position();
1010                         } else {
1011                             String arg;
1012 
1013                             if (isSurrogate()) {
1014                                 int codePoint = getCodepoint();
1015                                 char hi = Character.highSurrogate(codePoint);
1016                                 char lo = Character.lowSurrogate(codePoint);
1017                                 arg = String.format(&quot;\\u%04x\\u%04x&quot;, (int) hi, (int) lo);
1018                             } else {
1019                                 char ch = get();
1020                                 arg = (32 &lt; ch &amp;&amp; ch &lt; 127) ? String.format(&quot;%s&quot;, ch) :
1021                                                               String.format(&quot;\\u%04x&quot;, (int) ch);
1022                             }
1023 
1024                             lexError(pos, Errors.IllegalChar(arg));
1025                             next();
1026                         }
1027                     }
1028                     break loop;
1029                 }
1030             }
1031 
1032             int endPos = position();
1033 
1034             if (tk.tag == Token.Tag.DEFAULT) {
1035                 return new Token(tk, pos, endPos, comments);
1036             } else  if (tk.tag == Token.Tag.NAMED) {
1037                 return new NamedToken(tk, pos, endPos, name, comments);
1038             } else {
1039                 // Get characters from string buffer.
1040                 String string = sb.toString();
1041 
1042                 // If a text block.
1043                 if (isTextBlock) {
1044                     // Verify that the incidental indentation is consistent.
1045                     if (lint.isEnabled(LintCategory.TEXT_BLOCKS)) {
1046                         Set&lt;TextBlockSupport.WhitespaceChecks&gt; checks =
1047                                 TextBlockSupport.checkWhitespace(string);
1048                         if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {
1049                             lexWarning(LintCategory.TEXT_BLOCKS, pos,
1050                                     Warnings.InconsistentWhiteSpaceIndentation);
1051                         }
1052                         if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {
1053                             lexWarning(LintCategory.TEXT_BLOCKS, pos,
1054                                     Warnings.TrailingWhiteSpaceWillBeRemoved);
1055                         }
1056                     }
1057                     // Remove incidental indentation.
1058                     try {
1059                         string = string.stripIndent();
1060                     } catch (Exception ex) {
1061                         // Error already reported, just use unstripped string.
1062                     }
1063                 }
1064 
1065                 // Translate escape sequences if present.
1066                 if (hasEscapeSequences) {
1067                     try {
1068                         string = string.translateEscapes();
1069                     } catch (Exception ex) {
1070                         // Error already reported, just use untranslated string.
1071                     }
1072                 }
1073 
1074                 if (tk.tag == Token.Tag.STRING) {
1075                     // Build string token.
1076                     return new StringToken(tk, pos, endPos, string, comments);
1077                 } else {
1078                     // Build numeric token.
1079                     return new NumericToken(tk, pos, endPos, string, radix, comments);
1080                 }
1081             }
1082         } finally {
1083             int endPos = position();
1084 
1085             if (scannerDebug) {
1086                     System.out.println(&quot;nextToken(&quot; + pos
1087                                        + &quot;,&quot; + endPos + &quot;)=|&quot; +
1088                                        new String(getRawCharacters(pos, endPos))
1089                                        + &quot;|&quot;);
1090             }
1091         }
1092     }
1093 
1094     /**
1095      * Appends a comment to the list of comments preceding the current token.
1096      *
1097      * @param comments  existing list of comments.
1098      * @param comment   comment to append.
1099      *
1100      * @return new list with comment prepended to the existing list.
1101      */
1102     List&lt;Comment&gt; appendComment(List&lt;Comment&gt; comments, Comment comment) {
1103         return comments == null ?
1104                 List.of(comment) :
1105                 comments.prepend(comment);
1106     }
1107 
1108     /**
1109      * Return the position where a lexical error occurred.
1110      *
1111      * @return position in the input buffer of where the error occurred.
1112      */
1113     public int errPos() {
1114         return errPos;
1115     }
1116 
1117     /**
1118      * Set the position where a lexical error occurred.
1119      *
1120      * @param pos  position in the input buffer of where the error occurred.
1121      */
1122     public void errPos(int pos) {
1123         errPos = pos;
1124     }
1125 
1126     /**
1127      * Called when a complete comment has been scanned. pos and endPos
1128      * will mark the comment boundary.
1129      *
1130      * @param pos     position of the opening / in the input buffer.
1131      * @param endPos  position + 1 of the closing / in the input buffer.
1132      * @param style   style of comment.
1133      *
1134      * @return the constructed BasicComment.
1135      */
1136     protected Tokens.Comment processComment(int pos, int endPos, CommentStyle style) {
1137         if (scannerDebug) {
1138             System.out.println(&quot;processComment(&quot; + pos
1139                                 + &quot;,&quot; + endPos + &quot;,&quot; + style + &quot;)=|&quot;
1140                                 + new String(getRawCharacters(pos, endPos))
1141                                 + &quot;|&quot;);
1142         }
1143 
1144         char[] buf = getRawCharacters(pos, endPos);
1145 
1146         return new BasicComment(style, fac, buf, pos);
1147     }
1148 
1149     /**
1150      * Called when a complete whitespace run has been scanned. pos and endPos
1151      * will mark the whitespace boundary.
1152      *
1153      * (Spec 3.6)
1154      *
1155      * @param pos     position in input buffer of first whitespace character.
1156      * @param endPos  position + 1 in input buffer of last whitespace character.
1157      */
1158     protected void processWhiteSpace(int pos, int endPos) {
1159         if (scannerDebug) {
1160             System.out.println(&quot;processWhitespace(&quot; + pos
1161                                 + &quot;,&quot; + endPos + &quot;)=|&quot; +
1162                                 new String(getRawCharacters(pos, endPos))
1163                                 + &quot;|&quot;);
1164         }
1165     }
1166 
1167     /**
1168      * Called when a line terminator has been processed.
1169      *
1170      * @param pos     position in input buffer of first character in sequence.
1171      * @param endPos  position + 1 in input buffer of last character in sequence.
1172      */
1173     protected void processLineTerminator(int pos, int endPos) {
1174         if (scannerDebug) {
1175             System.out.println(&quot;processTerminator(&quot; + pos
1176                                 + &quot;,&quot; + endPos + &quot;)=|&quot; +
1177                                 new String(getRawCharacters(pos, endPos))
1178                                 + &quot;|&quot;);
1179         }
1180     }
1181 
1182     /**
1183      * Build a map for translating between line numbers and positions in the input.
1184      *
1185      * @return a LineMap
1186      */
1187     public Position.LineMap getLineMap() {
1188         return Position.makeLineMap(getRawCharacters(), length(), false);
1189     }
1190 
1191     /**
1192      * Scan a documentation comment; determine if a deprecated tag is present.
1193      * Called once the initial /, * have been skipped, positioned at the second *
1194      * (which is treated as the beginning of the first line).
1195      * Stops positioned at the closing &#39;/&#39;.
1196      */
1197     protected static class BasicComment extends PositionTrackingReader implements Comment {
1198         /**
1199          * Style of comment
1200          *   LINE starting with //
1201          *   BLOCK starting with /*
1202          *   JAVADOC starting with /**
1203          */
1204         CommentStyle cs;
1205 
1206         /**
1207          * true if comment contains @deprecated at beginning of a line.
1208          */
1209         protected boolean deprecatedFlag = false;
1210 
1211         /**
1212          * true if comment has been fully scanned.
1213          */
1214         protected boolean scanned = false;
1215 
1216         /**
1217          * Constructor.
1218          *
1219          * @param cs      comment style
1220          * @param sf      Scan factory.
1221          * @param array   Array containing contents of source.
1222          * @param offset  Position offset in original source buffer.
1223          */
1224         protected BasicComment(CommentStyle cs, ScannerFactory sf, char[] array, int offset) {
1225             super(sf, array, offset);
1226             this.cs = cs;
1227         }
1228 
1229         /**
1230          * Return comment body text minus comment adornments or null if not scanned.
1231          *
1232          * @return comment body text.
1233          */
1234         public String getText() {
1235             return null;
1236         }
1237 
1238         /**
1239          * Return buffer position in original buffer mapped from buffer position in comment.
1240          *
1241          * @param pos  buffer position in comment.
1242          *
1243          * @return buffer position in original buffer.
1244          */
1245         public int getSourcePos(int pos) {
1246             return -1;
1247         }
1248 
1249         /**
1250          * Return style of comment.
1251          *   LINE starting with //
1252          *   BLOCK starting with /*
1253          *   JAVADOC starting with /**
1254          *
1255          * @return
1256          */
1257         public CommentStyle getStyle() {
1258             return cs;
1259         }
1260 
1261         /**
1262          * true if comment contains @deprecated at beginning of a line.
1263          *
1264          * @return true if comment contains @deprecated.
1265          */
1266         public boolean isDeprecated() {
1267             if (!scanned &amp;&amp; cs == CommentStyle.JAVADOC) {
1268                 scanDocComment();
1269             }
1270 
1271             return deprecatedFlag;
1272         }
1273 
1274         /**
1275          * Scan JAVADOC comment for details.
1276          */
1277         protected void scanDocComment() {
1278             try {
1279                 boolean deprecatedPrefix = false;
1280                 accept(&quot;/**&quot;);
1281 
1282                 forEachLine:
1283                 while (isAvailable()) {
1284                     // Skip optional WhiteSpace at beginning of line
1285                     skipWhitespace();
1286 
1287                     // Skip optional consecutive Stars
1288                     while (accept(&#39;*&#39;)) {
1289                         if (is(&#39;/&#39;)) {
1290                             return;
1291                         }
1292                     }
1293 
1294                     // Skip optional WhiteSpace after Stars
1295                     skipWhitespace();
1296 
1297                     // At beginning of line in the JavaDoc sense.
1298                     deprecatedPrefix = deprecatedFlag || accept(&quot;@deprecated&quot;);
1299 
1300                     if (deprecatedPrefix &amp;&amp; isAvailable()) {
1301                         if (Character.isWhitespace(get())) {
1302                             deprecatedFlag = true;
1303                         } else if (accept(&#39;*&#39;)) {
1304                             if (is(&#39;/&#39;)) {
1305                                 deprecatedFlag = true;
1306                                 return;
1307                             }
1308                         }
1309                     }
1310 
1311                     // Skip rest of line
1312                     while (isAvailable()) {
1313                         switch (get()) {
1314                             case &#39;*&#39;:
1315                                 next();
1316 
1317                                 if (is(&#39;/&#39;)) {
1318                                     return;
1319                                 }
1320 
1321                                 break;
1322                             case &#39;\r&#39;: // (Spec 3.4)
1323                             case &#39;\n&#39;: // (Spec 3.4)
1324                                 accept(&#39;\r&#39;);
1325                                 accept(&#39;\n&#39;);
1326                                 continue forEachLine;
1327 
1328                             default:
1329                                 next();
1330                                 break;
1331                         }
1332                     } // rest of line
1333                 } // forEachLine
1334                 return;
1335             } finally {
1336                 scanned = true;
1337             }
1338         }
1339     }
1340 }
    </pre>
  </body>
</html>