<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.compiler/share/classes/com/sun/tools/javac/parser/UnicodeReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JavadocTokenizer.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../resources/compiler.properties.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/parser/UnicodeReader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,271 ***</span>
   * questions.
   */
  
  package com.sun.tools.javac.parser;
  
<span class="line-removed">- import java.nio.CharBuffer;</span>
  import java.util.Arrays;
  
<span class="line-removed">- import com.sun.tools.javac.file.JavacFileManager;</span>
  import com.sun.tools.javac.resources.CompilerProperties.Errors;
<span class="line-removed">- import com.sun.tools.javac.util.ArrayUtils;</span>
  import com.sun.tools.javac.util.Log;
<span class="line-removed">- import com.sun.tools.javac.util.Name;</span>
<span class="line-removed">- import com.sun.tools.javac.util.Names;</span>
  
<span class="line-modified">! import static com.sun.tools.javac.util.LayoutCharacters.*;</span>
  
<span class="line-modified">! /** The char reader used by the javac lexer/tokenizer. Returns the sequence of</span>
<span class="line-modified">!  * characters contained in the input stream, handling unicode escape accordingly.</span>
<span class="line-modified">!  * Additionally, it provides features for saving chars into a buffer and to retrieve</span>
<span class="line-removed">-  * them at a later stage.</span>
   *
   *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
   *  If you write code that depends on this, you do so at your own risk.
   *  This code and its internal interfaces are subject to change or
<span class="line-modified">!  *  deletion without notice.&lt;/b&gt;</span>
   */
  public class UnicodeReader {
  
<span class="line-modified">!     /** The input buffer, index of next character to be read,</span>
<span class="line-modified">!      *  index of one past last character in buffer.</span>
       */
<span class="line-modified">!     protected char[] buf;</span>
<span class="line-removed">-     protected int bp;</span>
<span class="line-removed">-     protected final int buflen;</span>
  
<span class="line-modified">!     /** The current character.</span>
       */
<span class="line-modified">!     protected char ch;</span>
  
<span class="line-modified">!     /** The buffer index of the last converted unicode character</span>
       */
<span class="line-modified">!     protected int unicodeConversionBp = -1;</span>
  
<span class="line-modified">!     protected Log log;</span>
<span class="line-modified">!     protected Names names;</span>
  
<span class="line-modified">!     /** A character buffer for saved chars.</span>
       */
<span class="line-modified">!     protected char[] sbuf = new char[128];</span>
<span class="line-removed">-     protected int realLength;</span>
<span class="line-removed">-     protected int sp;</span>
  
      /**
<span class="line-modified">!      * Create a scanner from the input array.  This method might</span>
<span class="line-modified">!      * modify the array.  To avoid copying the input array, ensure</span>
<span class="line-modified">!      * that {@code inputLength &lt; input.length} or</span>
<span class="line-modified">!      * {@code input[input.length -1]} is a white space character.</span>
       *
<span class="line-modified">!      * @param sf the factory which created this Scanner</span>
<span class="line-modified">!      * @param buffer the input, might be modified</span>
<span class="line-modified">!      * Must be positive and less than or equal to input.length.</span>
       */
<span class="line-modified">!     protected UnicodeReader(ScannerFactory sf, CharBuffer buffer) {</span>
<span class="line-modified">!         this(sf, JavacFileManager.toArray(buffer), buffer.limit());</span>
      }
  
<span class="line-modified">!     protected UnicodeReader(ScannerFactory sf, char[] input, int inputLength) {</span>
<span class="line-modified">!         log = sf.log;</span>
<span class="line-modified">!         names = sf.names;</span>
<span class="line-modified">!         realLength = inputLength;</span>
<span class="line-modified">!         if (inputLength == input.length) {</span>
<span class="line-modified">!             if (input.length &gt; 0 &amp;&amp; Character.isWhitespace(input[input.length - 1])) {</span>
<span class="line-modified">!                 inputLength--;</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 input = Arrays.copyOf(input, inputLength + 1);</span>
<span class="line-modified">!             }</span>
          }
<span class="line-removed">-         buf = input;</span>
<span class="line-removed">-         buflen = inputLength;</span>
<span class="line-removed">-         buf[buflen] = EOI;</span>
<span class="line-removed">-         bp = -1;</span>
<span class="line-removed">-         scanChar();</span>
      }
  
<span class="line-modified">!     /** Read next character.</span>
       */
<span class="line-modified">!     protected void scanChar() {</span>
<span class="line-modified">!         if (bp &lt; buflen) {</span>
<span class="line-modified">!             ch = buf[++bp];</span>
<span class="line-modified">!             if (ch == &#39;\\&#39;) {</span>
<span class="line-modified">!                 convertUnicode();</span>
<span class="line-modified">!             }</span>
          }
      }
  
<span class="line-modified">!     /** Read next character in comment, skipping over double &#39;\&#39; characters.</span>
       */
<span class="line-modified">!     protected void scanCommentChar() {</span>
<span class="line-modified">!         scanChar();</span>
<span class="line-modified">!         if (ch == &#39;\\&#39;) {</span>
<span class="line-modified">!             if (peekChar() == &#39;\\&#39; &amp;&amp; !isUnicode()) {</span>
<span class="line-modified">!                 skipChar();</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 convertUnicode();</span>
              }
          }
      }
  
<span class="line-modified">!     /** Append a character to sbuf.</span>
       */
<span class="line-modified">!     protected void putChar(char ch, boolean scan) {</span>
<span class="line-modified">!         sbuf = ArrayUtils.ensureCapacity(sbuf, sp);</span>
<span class="line-removed">-         sbuf[sp++] = ch;</span>
<span class="line-removed">-         if (scan)</span>
<span class="line-removed">-             scanChar();</span>
      }
  
<span class="line-modified">!     protected void putChar(char ch) {</span>
<span class="line-modified">!         putChar(ch, false);</span>
      }
  
<span class="line-modified">!     protected void putChar(boolean scan) {</span>
<span class="line-modified">!         putChar(ch, scan);</span>
      }
  
<span class="line-modified">!     protected void nextChar(boolean skip) {</span>
<span class="line-modified">!         if (!skip) {</span>
<span class="line-modified">!             sbuf = ArrayUtils.ensureCapacity(sbuf, sp);</span>
<span class="line-modified">!             sbuf[sp++] = ch;</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         scanChar();</span>
      }
  
<span class="line-modified">!     Name name() {</span>
<span class="line-modified">!         return names.fromChars(sbuf, 0, sp);</span>
      }
  
<span class="line-modified">!     String chars() {</span>
<span class="line-modified">!         return new String(sbuf, 0, sp);</span>
      }
  
<span class="line-modified">!     /** Add &#39;count&#39; copies of the character &#39;ch&#39; to the string buffer.</span>
       */
<span class="line-modified">!     protected void repeat(char ch, int count) {</span>
<span class="line-modified">!         for ( ; 0 &lt; count; count--) {</span>
<span class="line-removed">-             putChar(ch, false);</span>
<span class="line-removed">-         }</span>
      }
  
<span class="line-modified">!     /** Reset the scan buffer pointer to &#39;pos&#39;.</span>
       */
<span class="line-modified">!     protected void reset(int pos) {</span>
<span class="line-modified">!         bp = pos - 1;</span>
<span class="line-modified">!         scanChar();</span>
      }
  
<span class="line-modified">!     /** Convert unicode escape; bp points to initial &#39;\&#39; character</span>
<span class="line-modified">!      *  (Spec 3.3).</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     protected void convertUnicode() {</span>
<span class="line-modified">!         if (ch == &#39;\\&#39; &amp;&amp; unicodeConversionBp != bp ) {</span>
<span class="line-modified">!             bp++; ch = buf[bp];</span>
<span class="line-modified">!             if (ch == &#39;u&#39;) {</span>
<span class="line-modified">!                 do {</span>
<span class="line-modified">!                     bp++; ch = buf[bp];</span>
<span class="line-modified">!                 } while (ch == &#39;u&#39;);</span>
<span class="line-removed">-                 int limit = bp + 3;</span>
<span class="line-removed">-                 if (limit &lt; buflen) {</span>
<span class="line-removed">-                     int d = digit(bp, 16);</span>
<span class="line-removed">-                     int code = d;</span>
<span class="line-removed">-                     while (bp &lt; limit &amp;&amp; d &gt;= 0) {</span>
<span class="line-removed">-                         bp++; ch = buf[bp];</span>
<span class="line-removed">-                         d = digit(bp, 16);</span>
<span class="line-removed">-                         code = (code &lt;&lt; 4) + d;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     if (d &gt;= 0) {</span>
<span class="line-removed">-                         ch = (char)code;</span>
<span class="line-removed">-                         unicodeConversionBp = bp;</span>
<span class="line-removed">-                         return;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 log.error(bp, Errors.IllegalUnicodeEsc);</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 bp--;</span>
<span class="line-removed">-                 ch = &#39;\\&#39;;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
      }
  
<span class="line-modified">!     /** Are surrogates supported?</span>
       */
<span class="line-modified">!     final static boolean surrogatesSupported = surrogatesSupported();</span>
<span class="line-modified">!     private static boolean surrogatesSupported() {</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             Character.isHighSurrogate(&#39;a&#39;);</span>
              return true;
<span class="line-removed">-         } catch (NoSuchMethodError ex) {</span>
<span class="line-removed">-             return false;</span>
          }
      }
  
<span class="line-modified">!     /** Scan surrogate pairs.  If &#39;ch&#39; is a high surrogate and</span>
<span class="line-modified">!      *  the next character is a low surrogate, returns the code point</span>
<span class="line-removed">-      *  constructed from these surrogates. Otherwise, returns -1.</span>
<span class="line-removed">-      *  This method will not consume any of the characters.</span>
       */
<span class="line-modified">!     protected int peekSurrogates() {</span>
<span class="line-modified">!         if (surrogatesSupported &amp;&amp; Character.isHighSurrogate(ch)) {</span>
<span class="line-modified">!             char high = ch;</span>
<span class="line-removed">-             int prevBP = bp;</span>
  
<span class="line-modified">!             scanChar();</span>
  
<span class="line-modified">!             char low = ch;</span>
  
<span class="line-modified">!             ch = high;</span>
<span class="line-modified">!             bp = prevBP;</span>
  
<span class="line-modified">!             if (Character.isLowSurrogate(low)) {</span>
<span class="line-removed">-                 return Character.toCodePoint(high, low);</span>
<span class="line-removed">-             }</span>
          }
  
<span class="line-modified">!         return -1;</span>
      }
  
<span class="line-modified">!     /** Convert an ASCII digit from its base (8, 10, or 16)</span>
<span class="line-modified">!      *  to its value.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     protected int digit(int pos, int base) {</span>
<span class="line-modified">!         char c = ch;</span>
<span class="line-modified">!         if (&#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;)</span>
<span class="line-modified">!             return Character.digit(c, base); //a fast common case</span>
<span class="line-modified">!         int codePoint = peekSurrogates();</span>
<span class="line-removed">-         int result = codePoint &gt;= 0 ? Character.digit(codePoint, base) : Character.digit(c, base);</span>
<span class="line-removed">-         if (result &gt;= 0 &amp;&amp; c &gt; 0x7f) {</span>
<span class="line-removed">-             log.error(pos + 1, Errors.IllegalNonasciiDigit);</span>
<span class="line-removed">-             if (codePoint &gt;= 0)</span>
<span class="line-removed">-                 scanChar();</span>
<span class="line-removed">-             ch = &quot;0123456789abcdef&quot;.charAt(result);</span>
          }
<span class="line-removed">-         return result;</span>
      }
  
<span class="line-modified">!     protected boolean isUnicode() {</span>
<span class="line-modified">!         return unicodeConversionBp == bp;</span>
      }
  
<span class="line-modified">!     protected void skipChar() {</span>
<span class="line-modified">!         bp++;</span>
      }
  
<span class="line-modified">!     protected char peekChar() {</span>
<span class="line-modified">!         return buf[bp + 1];</span>
      }
  
      /**
<span class="line-modified">!      * Returns a copy of the input buffer, up to its inputLength.</span>
<span class="line-modified">!      * Unicode escape sequences are not translated.</span>
       */
      public char[] getRawCharacters() {
<span class="line-modified">!         char[] chars = new char[buflen];</span>
<span class="line-removed">-         System.arraycopy(buf, 0, chars, 0, buflen);</span>
<span class="line-removed">-         return chars;</span>
      }
  
      /**
       * Returns a copy of a character array subset of the input buffer.
       * The returned array begins at the {@code beginIndex} and
<span class="line-new-header">--- 23,503 ---</span>
   * questions.
   */
  
  package com.sun.tools.javac.parser;
  
  import java.util.Arrays;
  
  import com.sun.tools.javac.resources.CompilerProperties.Errors;
  import com.sun.tools.javac.util.Log;
  
<span class="line-modified">! import static com.sun.tools.javac.util.LayoutCharacters.EOI;</span>
<span class="line-added">+ import static com.sun.tools.javac.util.LayoutCharacters.tabulate;</span>
  
<span class="line-modified">! /**</span>
<span class="line-modified">!  * The unicode character reader used by the javac/javadoc lexer/tokenizer, returns characters</span>
<span class="line-modified">!  * one by one as contained in the input stream, handling unicode escape sequences accordingly.</span>
   *
   *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
   *  If you write code that depends on this, you do so at your own risk.
   *  This code and its internal interfaces are subject to change or
<span class="line-modified">!  *  deletion without notice.&lt;/b&gt;&lt;/p&gt;</span>
   */
  public class UnicodeReader {
<span class="line-added">+     /**</span>
<span class="line-added">+      * Buffer containing characters from source file. May contain extraneous characters</span>
<span class="line-added">+      * beyond this.length.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private final char[] buffer;</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Length of meaningful content in buffer.</span>
       */
<span class="line-modified">!     private final int length;</span>
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Character buffer index of character currently being observed.</span>
       */
<span class="line-modified">!     private int position;</span>
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Number of characters combined to provide character currently being observed. Typically</span>
<span class="line-added">+      * one, but may be more when combinations of surrogate pairs and unicode escape sequences</span>
<span class="line-added">+      * are read.</span>
       */
<span class="line-modified">!     private int width;</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Character currently being observed. If a surrogate pair is read then will be the high</span>
<span class="line-added">+      * member of the pair.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private char character;</span>
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Codepoint of character currently being observed. Typically equivalent to the character</span>
<span class="line-added">+      * but will have a value greater that 0xFFFF when a surrogate pair.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private int codepoint;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * true if the last character was a backslash. This is used to handle the special case</span>
<span class="line-added">+      * when a backslash precedes an unicode escape. In that case, the second backslash</span>
<span class="line-added">+      * is treated as a backslash and not part of an unicode escape.</span>
       */
<span class="line-modified">!     private boolean wasBackslash;</span>
  
      /**
<span class="line-modified">!      * Log for error reporting.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     private final Log log;</span>
<span class="line-modified">! </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Constructor.</span>
       *
<span class="line-modified">!      * @param sf      scan factory.</span>
<span class="line-modified">!      * @param array   array containing contents of source.</span>
<span class="line-modified">!      * @param length  length of meaningful content in buffer.</span>
       */
<span class="line-modified">!     protected UnicodeReader(ScannerFactory sf, char[] array, int length) {</span>
<span class="line-modified">!         this.buffer = array;</span>
<span class="line-added">+         this.length = length;</span>
<span class="line-added">+         this.position = 0;</span>
<span class="line-added">+         this.width = 0;</span>
<span class="line-added">+         this.character = &#39;\0&#39;;</span>
<span class="line-added">+         this.codepoint = 0;</span>
<span class="line-added">+         this.wasBackslash = false;</span>
<span class="line-added">+         this.log = sf.log;</span>
<span class="line-added">+ </span>
<span class="line-added">+         nextCodePoint();</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Returns the length of the buffer. This is length of meaningful content in buffer and</span>
<span class="line-modified">!      * not the length of the buffer array.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @return length of the buffer.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     protected int length() {</span>
<span class="line-modified">!         return length;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Return true if current position is within the meaningful part of the buffer.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return true if current position is within the meaningful part of the buffer.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     protected boolean isAvailable() {</span>
<span class="line-added">+         return position &lt; length;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Fetches the next 16-bit character from the buffer and places it in this.character.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private void nextCodeUnit() {</span>
<span class="line-added">+         // Index of next character in buffer.</span>
<span class="line-added">+         int index = position + width;</span>
<span class="line-added">+ </span>
<span class="line-added">+         // If past end of buffer.</span>
<span class="line-added">+         if (length &lt;= index) {</span>
<span class="line-added">+             // End of file is marked with EOI.</span>
<span class="line-added">+             character = EOI;</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             // Next character in buffer.</span>
<span class="line-added">+             character = buffer[index];</span>
<span class="line-added">+             // Increment length of codepoint.</span>
<span class="line-added">+             width++;</span>
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Fetches the next 16-bit character from the buffer. If an unicode escape</span>
<span class="line-added">+      * is detected then converts the unicode escape to a character.</span>
       */
<span class="line-modified">!     private void nextUnicodeInputCharacter() {</span>
<span class="line-modified">!         // Position to next codepoint.</span>
<span class="line-modified">!         position += width;</span>
<span class="line-modified">!         // Codepoint has no characters yet.</span>
<span class="line-modified">!         width = 0;</span>
<span class="line-modified">! </span>
<span class="line-added">+         // Fetch next character.</span>
<span class="line-added">+         nextCodeUnit();</span>
<span class="line-added">+ </span>
<span class="line-added">+         // If second backslash is detected.</span>
<span class="line-added">+         if (wasBackslash) {</span>
<span class="line-added">+             // Treat like a normal character (not part of unicode escape.)</span>
<span class="line-added">+             wasBackslash = false;</span>
<span class="line-added">+         } else if (character == &#39;\\&#39;) {</span>
<span class="line-added">+             // May be an unicode escape.</span>
<span class="line-added">+             wasBackslash = !unicodeEscape();</span>
          }
<span class="line-added">+ </span>
<span class="line-added">+         // Codepoint and character match if not surrogate.</span>
<span class="line-added">+         codepoint = (int)character;</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Fetches the nextcode point from the buffer. If an unicode escape is recognized</span>
<span class="line-added">+      * then converts unicode escape to a character. If two characters are a surrogate pair</span>
<span class="line-added">+      * then converts to a codepoint.</span>
       */
<span class="line-modified">!     private void nextCodePoint() {</span>
<span class="line-modified">!         // Next unicode character.</span>
<span class="line-modified">!         nextUnicodeInputCharacter();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // Return early if ASCII or not a surrogate pair.</span>
<span class="line-modified">!         if (isASCII() || !Character.isHighSurrogate(character)) {</span>
<span class="line-modified">!             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Capture high surrogate and position.</span>
<span class="line-added">+         char hi = character;</span>
<span class="line-added">+         int savePosition = position;</span>
<span class="line-added">+         int saveWidth = width;</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Get potential low surrogate.</span>
<span class="line-added">+         nextUnicodeInputCharacter();</span>
<span class="line-added">+         char lo = character;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (Character.isLowSurrogate(lo)) {</span>
<span class="line-added">+             // Start codepoint at start of high surrogate.</span>
<span class="line-added">+             position = savePosition;</span>
<span class="line-added">+             width += saveWidth;</span>
<span class="line-added">+             // Compute codepoint.</span>
<span class="line-added">+             codepoint = Character.toCodePoint(hi, lo);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             // Restore to treat high surrogate as just a character.</span>
<span class="line-added">+             position = savePosition;</span>
<span class="line-added">+             width = saveWidth;</span>
<span class="line-added">+             character = hi;</span>
<span class="line-added">+             codepoint = (int)hi;</span>
<span class="line-added">+             // Could potential report an error here (old code did not.)</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Converts an unicode escape into a character.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return true if was an unicode escape.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private boolean unicodeEscape() {</span>
<span class="line-added">+         // Start of unicode escape (past backslash.)</span>
<span class="line-added">+         int start = position + width;</span>
<span class="line-added">+         int index;</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Skip multiple &#39;u&#39;.</span>
<span class="line-added">+         for (index = start; index &lt; length; index++) {</span>
<span class="line-added">+             if (buffer[index] != &#39;u&#39;) {</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Needs to be at least backslash-u.</span>
<span class="line-added">+         if (index != start) {</span>
<span class="line-added">+             // If enough characters available.</span>
<span class="line-added">+             if (index + 4 &lt; length) {</span>
<span class="line-added">+                 // Convert four hex digits to codepoint. If any digit is invalid then the</span>
<span class="line-added">+                 // result is negative.</span>
<span class="line-added">+                 int code = (Character.digit(buffer[index++], 16) &lt;&lt; 12) |</span>
<span class="line-added">+                            (Character.digit(buffer[index++], 16) &lt;&lt; 8) |</span>
<span class="line-added">+                            (Character.digit(buffer[index++], 16) &lt;&lt; 4) |</span>
<span class="line-added">+                             Character.digit(buffer[index++], 16);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // If all digits are good.</span>
<span class="line-added">+                 if (code &gt;= 0) {</span>
<span class="line-added">+                     width = index - position;</span>
<span class="line-added">+                     character = (char)code;</span>
<span class="line-added">+ </span>
<span class="line-added">+                     return true;</span>
<span class="line-added">+                 }</span>
              }
<span class="line-added">+ </span>
<span class="line-added">+             // Did not work out.</span>
<span class="line-added">+             log.error(position, Errors.IllegalUnicodeEsc);</span>
<span class="line-added">+             width = index - position;</span>
<span class="line-added">+ </span>
<span class="line-added">+             // Return true so that the invalid unicode escape is skipped.</span>
<span class="line-added">+             return true;</span>
          }
<span class="line-added">+ </span>
<span class="line-added">+         // Must be just a backslash.</span>
<span class="line-added">+         character = &#39;\\&#39;;</span>
<span class="line-added">+         width = 1;</span>
<span class="line-added">+ </span>
<span class="line-added">+         return false;</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Return the current position in the character buffer.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return  current position in the character buffer.</span>
       */
<span class="line-modified">!     protected int position() {</span>
<span class="line-modified">!         return position;</span>
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Reset the reader to the specified position.</span>
<span class="line-added">+      * Warning: Do not use when previous character was an ASCII or unicode backslash.</span>
<span class="line-added">+      * @param pos</span>
<span class="line-added">+      */</span>
<span class="line-added">+     protected void reset(int pos) {</span>
<span class="line-added">+         position = pos;</span>
<span class="line-added">+         width = 0;</span>
<span class="line-added">+         wasBackslash = false;</span>
<span class="line-added">+         nextCodePoint();</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Return the current character in at the current position.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return current character in at the current position.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     protected char get() {</span>
<span class="line-added">+         return character;</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Return the current codepoint in at the current position.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @return current codepoint in at the current position.</span>
<span class="line-modified">!      */</span>
<span class="line-added">+     protected int getCodepoint() {</span>
<span class="line-added">+         return codepoint;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Returns true if the current codepoint is a surrogate.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return true if the current codepoint is a surrogate.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     protected boolean isSurrogate() {</span>
<span class="line-added">+         return 0xFFFF &lt; codepoint;</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Returns true if the current character is ASCII.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return true if the current character is ASCII.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     protected boolean isASCII() {</span>
<span class="line-added">+         return character &lt;= 0x7F;</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Advances the current character to the next character.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return next character.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     protected char next() {</span>
<span class="line-added">+         nextCodePoint();</span>
<span class="line-added">+ </span>
<span class="line-added">+         return character;</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Compare character. Returns true if a match.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param ch  character to match.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return true if a match.</span>
       */
<span class="line-modified">!     protected boolean is(char ch) {</span>
<span class="line-modified">!         return character == ch;</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Match one of the arguments. Returns true if a match.</span>
       */
<span class="line-modified">!     protected boolean isOneOf(char ch1, char ch2) {</span>
<span class="line-modified">!         return is(ch1) || is(ch2);</span>
<span class="line-modified">!     }</span>
<span class="line-added">+     protected boolean isOneOf(char ch1, char ch2, char ch3) {</span>
<span class="line-added">+         return is(ch1) || is(ch2) || is(ch3);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     protected boolean isOneOf(char ch1, char ch2, char ch3, char ch4, char ch5, char ch6) {</span>
<span class="line-added">+         return is(ch1) || is(ch2) || is(ch3) || is(ch4) || is(ch5) || is(ch6);</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Tests to see if current character is in the range of lo to hi characters (inclusive).</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @param lo  lowest character in range.</span>
<span class="line-modified">!      * @param hi  highest character in range.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @return true if the current character is in range.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     protected boolean inRange(char lo, char hi) {</span>
<span class="line-modified">!         return lo &lt;= character &amp;&amp; character &lt;= hi;</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Compare character and advance if a match. Returns true if a match.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param ch  character to match.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return true if a match.</span>
       */
<span class="line-modified">!     protected boolean accept(char ch) {</span>
<span class="line-modified">!         if (is(ch)) {</span>
<span class="line-modified">!             next();</span>
<span class="line-modified">! </span>
              return true;
          }
<span class="line-added">+ </span>
<span class="line-added">+         return false;</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Match one of the arguments and advance if a match. Returns true if a match.</span>
       */
<span class="line-modified">!     protected boolean acceptOneOf(char ch1, char ch2) {</span>
<span class="line-modified">!         if (isOneOf(ch1, ch2)) {</span>
<span class="line-modified">!             next();</span>
  
<span class="line-modified">!             return true;</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         return false;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     protected boolean acceptOneOf(char ch1, char ch2, char ch3) {</span>
<span class="line-modified">!         if (isOneOf(ch1, ch2, ch3)) {</span>
<span class="line-added">+             next();</span>
  
<span class="line-modified">!             return true;</span>
          }
  
<span class="line-modified">!         return false;</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Skip over all occurances of character.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @param ch character to accept.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     protected void skip(char ch) {</span>
<span class="line-modified">!         while (accept(ch)) {</span>
<span class="line-modified">!             // next</span>
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Skip over ASCII white space characters.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     protected void skipWhitespace() {</span>
<span class="line-added">+         while (acceptOneOf(&#39; &#39;, &#39;\t&#39;, &#39;\f&#39;)) {</span>
<span class="line-added">+             // next</span>
<span class="line-added">+         }</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Skip to end of line.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     protected void skipToEOLN() {</span>
<span class="line-added">+         while (isAvailable()) {</span>
<span class="line-added">+             if (isOneOf(&#39;\r&#39;, &#39;\n&#39;)) {</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             next();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Compare string and advance if a match. Returns true if a match.</span>
<span class="line-added">+      * Warning: Do not use when previous character was a backslash</span>
<span class="line-added">+      * (confuses state of wasBackslash.)</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param string string to match character for character.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return true if a match.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     protected boolean accept(String string) {</span>
<span class="line-added">+         // Quick test.</span>
<span class="line-added">+         if (string.length() == 0 || !is(string.charAt(0))) {</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Be prepared to retreat if not a match.</span>
<span class="line-added">+         int savedPosition = position;</span>
<span class="line-added">+ </span>
<span class="line-added">+         nextCodePoint();</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Check each character.</span>
<span class="line-added">+         for (int i = 1; i &lt; string.length(); i++) {</span>
<span class="line-added">+             if (!is(string.charAt(i))) {</span>
<span class="line-added">+                 // Restart if not a match.</span>
<span class="line-added">+                 reset(savedPosition);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             nextCodePoint();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return true;</span>
      }
  
      /**
<span class="line-modified">!      * Convert an ASCII digit from its base (8, 10, or 16) to its value. Does not</span>
<span class="line-modified">!      * advance character.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param pos         starting position.</span>
<span class="line-added">+      * @param digitRadix  base of number being converted.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return value of digit.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     protected int digit(int pos, int digitRadix) {</span>
<span class="line-added">+         int result;</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Just an ASCII digit.</span>
<span class="line-added">+         if (inRange(&#39;0&#39;, &#39;9&#39;)) {</span>
<span class="line-added">+             // Fast common case.</span>
<span class="line-added">+             result = character - &#39;0&#39;;</span>
<span class="line-added">+ </span>
<span class="line-added">+             return result &lt; digitRadix ? result : -1;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Handle other digits.</span>
<span class="line-added">+         result = isSurrogate() ? Character.digit(codepoint, digitRadix) :</span>
<span class="line-added">+                                  Character.digit(character, digitRadix);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (result &gt;= 0 &amp;&amp; !isASCII()) {</span>
<span class="line-added">+             log.error(position(), Errors.IllegalNonasciiDigit);</span>
<span class="line-added">+             character = &quot;0123456789abcdef&quot;.charAt(result);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return result;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns the input buffer. Unicode escape sequences are not translated.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return the input buffer.</span>
       */
      public char[] getRawCharacters() {
<span class="line-modified">!         return length == buffer.length ? buffer : Arrays.copyOf(buffer, length);</span>
      }
  
      /**
       * Returns a copy of a character array subset of the input buffer.
       * The returned array begins at the {@code beginIndex} and
</pre>
<hr />
<pre>
<span class="line-old-header">*** 295,17 ***</span>
       * Thus the length of the substring is {@code endIndex-beginIndex}.
       * This behavior is like
       * {@code String.substring(beginIndex, endIndex)}.
       * Unicode escape sequences are not translated.
       *
<span class="line-modified">!      * @param beginIndex the beginning index, inclusive.</span>
<span class="line-modified">!      * @param endIndex the ending index, exclusive.</span>
       * @throws ArrayIndexOutOfBoundsException if either offset is outside of the
       *         array bounds
       */
      public char[] getRawCharacters(int beginIndex, int endIndex) {
<span class="line-modified">!         int length = endIndex - beginIndex;</span>
<span class="line-modified">!         char[] chars = new char[length];</span>
<span class="line-modified">!         System.arraycopy(buf, beginIndex, chars, 0, length);</span>
<span class="line-modified">!         return chars;</span>
      }
  }
<span class="line-new-header">--- 527,85 ---</span>
       * Thus the length of the substring is {@code endIndex-beginIndex}.
       * This behavior is like
       * {@code String.substring(beginIndex, endIndex)}.
       * Unicode escape sequences are not translated.
       *
<span class="line-modified">!      * @param  beginIndex the beginning index, inclusive.</span>
<span class="line-modified">!      * @param  endIndex the ending index, exclusive.</span>
<span class="line-added">+      *</span>
       * @throws ArrayIndexOutOfBoundsException if either offset is outside of the
       *         array bounds
       */
      public char[] getRawCharacters(int beginIndex, int endIndex) {
<span class="line-modified">!         return Arrays.copyOfRange(buffer, beginIndex, endIndex);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     /**</span>
<span class="line-added">+      * This is a specialized version of UnicodeReader that keeps track of the</span>
<span class="line-added">+      * column position within a given character stream. Used for Javadoc</span>
<span class="line-added">+      * processing to build a table for mapping positions in the comment string</span>
<span class="line-added">+      * to positions in the source file.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     static class PositionTrackingReader extends UnicodeReader {</span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Offset from the beginning of the original reader buffer.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         private int offset;</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Current column in the comment.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         private int column;</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Constructor.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * @param sf      Scan factory.</span>
<span class="line-added">+          * @param array   Array containing contents of source.</span>
<span class="line-added">+          * @param offset  Position offset in original source buffer.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         protected PositionTrackingReader(ScannerFactory sf, char[] array, int offset) {</span>
<span class="line-added">+             super(sf, array, array.length);</span>
<span class="line-added">+             this.offset = offset;</span>
<span class="line-added">+             this.column = 0;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Advances the current character to the next character. Tracks column.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * @return next character.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         protected char next() {</span>
<span class="line-added">+             super.next();</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (isOneOf(&#39;\n&#39;, &#39;\r&#39;, &#39;\f&#39;)) {</span>
<span class="line-added">+                 column = 0;</span>
<span class="line-added">+             } else if (is(&#39;\t&#39;)) {</span>
<span class="line-added">+                 column = tabulate(column);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 column++;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             return get();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Returns the current column.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * @return  the current column.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         protected int column() {</span>
<span class="line-added">+             return column;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Returns position relative to the original source buffer.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * @return</span>
<span class="line-added">+          */</span>
<span class="line-added">+         protected int offsetPosition() {</span>
<span class="line-added">+             return position() + offset;</span>
<span class="line-added">+         }</span>
      }
<span class="line-added">+ </span>
  }
</pre>
<center><a href="JavadocTokenizer.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../resources/compiler.properties.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>