<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/resources/compiler.properties</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 #
   2 # Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4 #
   5 # This code is free software; you can redistribute it and/or modify it
   6 # under the terms of the GNU General Public License version 2 only, as
   7 # published by the Free Software Foundation.  Oracle designates this
   8 # particular file as subject to the &quot;Classpath&quot; exception as provided
   9 # by Oracle in the LICENSE file that accompanied this code.
  10 #
  11 # This code is distributed in the hope that it will be useful, but WITHOUT
  12 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14 # version 2 for more details (a copy is included in the LICENSE file that
  15 # accompanied this code).
  16 #
  17 # You should have received a copy of the GNU General Public License version
  18 # 2 along with this work; if not, write to the Free Software Foundation,
  19 # Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20 #
  21 # Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22 # or visit www.oracle.com if you need additional information or have any
  23 # questions.
  24 #
  25 
  26 # Messages in this file which use &quot;placeholders&quot; for values (e.g. {0}, {1})
  27 # are preceded by a stylized comment describing the type of the corresponding
  28 # values.
  29 # The simple types currently in use are:
  30 #
  31 # annotation        annotation compound
  32 # boolean           true or false
  33 # diagnostic        a sub-message; see compiler.misc.*
  34 # fragment          similar to &#39;message segment&#39;, but with more specific type
  35 # modifier          a Java modifier; e.g. public, private, protected
  36 # file              a file URL
  37 # file object       a file URL - similar to &#39;file&#39; but typically used for source/class files, hence more specific
  38 # flag              a Flags.Flag instance
  39 # name              a name, typically a Java identifier
  40 # number            an integer
  41 # option name       the name of a command line option
  42 # path              a path
  43 # profile           a profile name
  44 # source            a source version number, such as 1.5, 1.6, 1.7, taken from a com.sun.tools.javac.code.Source
  45 # source version    a source version number, such as 1.5, 1.6, 1.7, taken from a javax.lang.model.SourceVersion
  46 # string            a general string
  47 # symbol            the name of a declared type
  48 # symbol kind       the kind of a symbol (i.e. method, variable)
  49 # kind name         an informative description of the kind of a declaration; see compiler.misc.kindname.*
  50 # target            a target version number, such as 1.5, 1.6, 1.7, taken from a com.sun.tools.javac.jvm.Target
  51 # token             the name of a non-terminal in source code; see compiler.misc.token.*
  52 # tree tag          the name of a non-terminal in source code; see compiler.misc.token.*
  53 # type              a Java type; e.g. int, X, X&lt;T&gt;
  54 # url               a URL
  55 # object            a Java object (unspecified)
  56 # unused            the value is not used in this message
  57 #
  58 # The following compound types are also used:
  59 #
  60 # collection of X   a comma-separated collection of items; e.g. collection of type
  61 # list of X         a comma-separated list of items; e.g. list of type
  62 # set of X          a comma-separated set of items; e.g. set of modifier
  63 #
  64 # These may be composed:
  65 #
  66 # list of type or message segment
  67 #
  68 # The following type aliases are supported:
  69 #
  70 # message segment --&gt; diagnostic or fragment
  71 # file name --&gt; file, path or file object
  72 #
  73 # Custom comments are supported in parenthesis i.e.
  74 #
  75 # number (classfile major version)
  76 #
  77 # These comments are used internally in order to generate an enum-like class declaration containing
  78 # a method/field for each of the diagnostic keys listed here. Those methods/fields can then be used
  79 # by javac code to build diagnostics in a type-safe fashion.
  80 #
  81 # In addition, these comments are verified by the jtreg test test/tools/javac/diags/MessageInfo,
  82 # using info derived from the collected set of examples in test/tools/javac/diags/examples.
  83 # MessageInfo can also be run as a standalone utility providing more facilities
  84 # for manipulating this file. For more details, see MessageInfo.java.
  85 
  86 ##
  87 ## errors
  88 ##
  89 
  90 # 0: symbol
  91 compiler.err.abstract.cant.be.instantiated=\
  92     {0} is abstract; cannot be instantiated
  93 
  94 compiler.err.abstract.meth.cant.have.body=\
  95     abstract methods cannot have a body
  96 
  97 # 0: kind name, 1: symbol
  98 compiler.err.already.annotated=\
  99     {0} {1} has already been annotated
 100 
 101 # 0: kind name, 1: symbol, 2: kind name, 3: symbol
 102 compiler.err.already.defined=\
 103     {0} {1} is already defined in {2} {3}
 104 
 105 # 0: kind name, 1: symbol, 2: kind name, 3: kind name, 4: symbol
 106 compiler.err.already.defined.in.clinit=\
 107     {0} {1} is already defined in {2} of {3} {4}
 108 
 109 # 0: symbol
 110 compiler.err.already.defined.single.import=\
 111     a type with the same simple name is already defined by the single-type-import of {0}
 112 
 113 # 0: symbol
 114 compiler.err.already.defined.static.single.import=\
 115     a type with the same simple name is already defined by the static single-type-import of {0}
 116 
 117 # 0: symbol
 118 compiler.err.already.defined.this.unit=\
 119     {0} is already defined in this compilation unit
 120 
 121 # 0: type, 1: list of name
 122 compiler.err.annotation.missing.default.value=\
 123     annotation @{0} is missing a default value for the element &#39;&#39;{1}&#39;&#39;
 124 
 125 # 0: type, 1: list of name
 126 compiler.err.annotation.missing.default.value.1=\
 127     annotation @{0} is missing default values for elements {1}
 128 
 129 # 0: type
 130 compiler.err.annotation.not.valid.for.type=\
 131     annotation not valid for an element of type {0}
 132 
 133 compiler.err.annotation.type.not.applicable=\
 134     annotation type not applicable to this kind of declaration
 135 
 136 # 0: type
 137 compiler.err.annotation.type.not.applicable.to.type=\
 138     annotation @{0} not applicable in this type context
 139 
 140 compiler.err.annotation.value.must.be.annotation=\
 141     annotation value must be an annotation
 142 
 143 compiler.err.annotation.value.must.be.class.literal=\
 144     annotation value must be a class literal
 145 
 146 compiler.err.annotation.value.must.be.name.value=\
 147     annotation values must be of the form &#39;&#39;name=value&#39;&#39;
 148 
 149 compiler.err.annotation.value.not.allowable.type=\
 150     annotation value not of an allowable type
 151 
 152 compiler.err.expression.not.allowable.as.annotation.value=\
 153     expression not allowed as annotation value
 154 
 155 compiler.err.anon.class.impl.intf.no.args=\
 156     anonymous class implements interface; cannot have arguments
 157 
 158 compiler.err.anon.class.impl.intf.no.typeargs=\
 159     anonymous class implements interface; cannot have type arguments
 160 
 161 compiler.err.anon.class.impl.intf.no.qual.for.new=\
 162     anonymous class implements interface; cannot have qualifier for new
 163 
 164 compiler.err.cant.inherit.from.anon=\
 165     cannot inherit from anonymous class
 166 
 167 # 0: symbol, 1: symbol, 2: symbol
 168 compiler.err.array.and.varargs=\
 169     cannot declare both {0} and {1} in {2}
 170 
 171 compiler.err.array.dimension.missing=\
 172     array dimension missing
 173 
 174 compiler.err.illegal.array.creation.both.dimension.and.initialization=\
 175     array creation with both dimension expression and initialization is illegal
 176 
 177 # 0: type
 178 compiler.err.array.req.but.found=\
 179     array required, but {0} found
 180 
 181 compiler.err.attribute.value.must.be.constant=\
 182     element value must be a constant expression
 183 
 184 # 0: string (statement type)
 185 compiler.err.bad.initializer=\
 186     bad initializer for {0}
 187 
 188 compiler.err.break.outside.switch.loop=\
 189     break outside switch or loop
 190 
 191 compiler.err.break.outside.switch.expression=\
 192     attempt to break out of a switch expression
 193 
 194 compiler.err.continue.outside.switch.expression=\
 195     attempt to continue out of a switch expression
 196 
 197 compiler.err.return.outside.switch.expression=\
 198     attempt to return out of a switch expression
 199 
 200 compiler.err.rule.completes.normally=\
 201     switch rule completes without providing a value\n\
 202     (switch rules in switch expressions must either provide a value or throw)
 203 
 204 compiler.err.switch.expression.completes.normally=\
 205     switch expression completes without providing a value\n\
 206     (switch expressions must either provide a value or throw for all possible input values)
 207 
 208 compiler.err.no.switch.expression =\
 209     yield outside of switch expression
 210 
 211 compiler.err.no.switch.expression.qualify=\
 212     yield outside of switch expression\n\
 213     (to invoke a method called yield, qualify the yield with a receiver or type name)
 214 
 215 compiler.err.invalid.yield=\
 216     invalid use of a restricted identifier &#39;&#39;yield&#39;&#39;\n\
 217     (to invoke a method called yield, qualify the yield with a receiver or type name)
 218 
 219 compiler.warn.invalid.yield=\
 220     &#39;&#39;yield&#39;&#39; may become a restricted identifier in a future release\n\
 221     (to invoke a method called yield, qualify the yield with a receiver or type name)
 222 
 223 compiler.err.switch.expression.empty=\
 224     switch expression does not have any case clauses
 225 
 226 compiler.err.switch.expression.no.result.expressions=\
 227     switch expression does not have any result expressions
 228 
 229 # 0: name
 230 compiler.err.call.must.be.first.stmt.in.ctor=\
 231     call to {0} must be first statement in constructor
 232 
 233 # 0: symbol kind, 1: name, 2: list of type or message segment, 3: list of type or message segment, 4: symbol kind, 5: type, 6: message segment
 234 compiler.err.cant.apply.symbol=\
 235     {0} {1} in {4} {5} cannot be applied to given types;\n\
 236     required: {2}\n\
 237     found:    {3}\n\
 238     reason: {6}
 239 
 240 # 0: symbol kind, 1: name, 2: list of type
 241 compiler.err.cant.apply.symbols=\
 242     no suitable {0} found for {1}({2})
 243 
 244 # 0: symbol kind, 1: name, 2: list of type or message segment, 3: list of type or message segment, 4: symbol kind, 5: type, 6: message segment
 245 compiler.misc.cant.apply.symbol=\
 246     {0} {1} in {4} {5} cannot be applied to given types\n\
 247     required: {2}\n\
 248     found:    {3}\n\
 249     reason: {6}
 250 
 251 # 0: symbol kind, 1: name, 2: list of type
 252 compiler.misc.cant.apply.symbols=\
 253     no suitable {0} found for {1}({2})
 254 
 255 # 0: kind name, 1: symbol
 256 compiler.misc.no.abstracts=\
 257     no abstract method found in {0} {1}
 258 
 259 # 0: kind name, 1: symbol
 260 compiler.misc.incompatible.abstracts=\
 261     multiple non-overriding abstract methods found in {0} {1}
 262 
 263 compiler.err.bad.functional.intf.anno=\
 264     Unexpected @FunctionalInterface annotation
 265 
 266 # 0: message segment
 267 compiler.err.bad.functional.intf.anno.1=\
 268     Unexpected @FunctionalInterface annotation\n\
 269     {0}
 270 
 271 # 0: message segment
 272 compiler.err.anonymous.diamond.method.does.not.override.superclass=\
 273     method does not override or implement a method from a supertype\n\
 274     {0}
 275 
 276 # 0: symbol
 277 compiler.misc.not.a.functional.intf=\
 278     {0} is not a functional interface
 279 
 280 # 0: symbol, 1: message segment
 281 compiler.misc.not.a.functional.intf.1=\
 282     {0} is not a functional interface\n\
 283     {1}
 284 
 285 # 0: type, 1: kind name, 2: symbol
 286 compiler.misc.invalid.generic.lambda.target=\
 287     invalid functional descriptor for lambda expression\n\
 288     method {0} in {1} {2} is generic
 289 
 290 # 0: kind name, 1: symbol
 291 compiler.misc.incompatible.descs.in.functional.intf=\
 292     incompatible function descriptors found in {0} {1}
 293 
 294 # 0: name, 1: list of type, 2: type, 3: list of type
 295 compiler.misc.descriptor=\
 296     descriptor: {2} {0}({1})
 297 
 298 # 0: name, 1: list of type, 2: type, 3: list of type
 299 compiler.misc.descriptor.throws=\
 300     descriptor: {2} {0}({1}) throws {3}
 301 
 302 # 0: type
 303 compiler.misc.no.suitable.functional.intf.inst=\
 304     cannot infer functional interface descriptor for {0}
 305 
 306 # 0: message segment
 307 compiler.misc.bad.intersection.target.for.functional.expr=\
 308     bad intersection type target for lambda or method reference\n\
 309     {0}
 310 
 311 # 0: symbol or type
 312 compiler.misc.not.an.intf.component=\
 313     component type {0} is not an interface
 314 
 315 # 0: kind name, 1: message segment
 316 compiler.err.invalid.mref=\
 317     invalid {0} reference\n\
 318     {1}
 319 
 320 # 0: kind name, 1: message segment
 321 compiler.misc.invalid.mref=\
 322     invalid {0} reference\n\
 323     {1}
 324 
 325 compiler.misc.static.mref.with.targs=\
 326     parameterized qualifier on static method reference
 327 
 328 # 0: symbol
 329 compiler.err.cant.assign.val.to.final.var=\
 330     cannot assign a value to final variable {0}
 331 
 332 compiler.err.cant.assign.val.to.this=\
 333     cannot assign to &#39;&#39;this&#39;&#39;
 334 
 335 # 0: symbol, 1: message segment
 336 compiler.err.cant.ref.non.effectively.final.var=\
 337     local variables referenced from {1} must be final or effectively final
 338 
 339 compiler.err.try.with.resources.expr.needs.var=\
 340     the try-with-resources resource must either be a variable declaration or an expression denoting \
 341 a reference to a final or effectively final variable
 342 
 343 # 0: symbol
 344 compiler.err.try.with.resources.expr.effectively.final.var=\
 345     variable {0} used as a try-with-resources resource neither final nor effectively final
 346 
 347 
 348 compiler.misc.lambda=\
 349     a lambda expression
 350 
 351 compiler.misc.inner.cls=\
 352     an inner class
 353 
 354 # 0: type
 355 compiler.err.cant.deref=\
 356     {0} cannot be dereferenced
 357 
 358 compiler.err.cant.extend.intf.annotation=\
 359     &#39;&#39;extends&#39;&#39; not allowed for @interfaces
 360 
 361 compiler.err.annotation.decl.not.allowed.here=\
 362     annotation type declaration not allowed here
 363 
 364 # 0: symbol
 365 compiler.err.cant.inherit.from.final=\
 366     cannot inherit from final {0}
 367 
 368 # 0: symbol or string
 369 compiler.err.cant.ref.before.ctor.called=\
 370     cannot reference {0} before supertype constructor has been called
 371 
 372 compiler.err.cant.select.static.class.from.param.type=\
 373     cannot select a static class from a parameterized type
 374 
 375 # 0: symbol, 1: string, 2: string
 376 compiler.err.cant.inherit.diff.arg=\
 377     {0} cannot be inherited with different arguments: &lt;{1}&gt; and &lt;{2}&gt;
 378 
 379 compiler.err.catch.without.try=\
 380     &#39;&#39;catch&#39;&#39; without &#39;&#39;try&#39;&#39;
 381 
 382 # 0: kind name, 1: symbol
 383 compiler.err.clash.with.pkg.of.same.name=\
 384     {0} {1} clashes with package of same name
 385 
 386 compiler.err.class.not.allowed=\
 387     class, interface or enum declaration not allowed here
 388 
 389 compiler.err.const.expr.req=\
 390     constant expression required
 391 
 392 compiler.err.cont.outside.loop=\
 393     continue outside of loop
 394 
 395 # 0: symbol or type
 396 compiler.err.cyclic.inheritance=\
 397     cyclic inheritance involving {0}
 398 
 399 # 0: symbol
 400 compiler.err.cyclic.annotation.element=\
 401     type of element {0} is cyclic
 402 
 403 # 0: symbol
 404 compiler.err.call.to.super.not.allowed.in.enum.ctor=\
 405     call to super not allowed in enum constructor
 406 
 407 # 0: type
 408 compiler.err.no.superclass=\
 409     {0} has no superclass.
 410 
 411 # 0: symbol, 1: type, 2: symbol, 3: type, 4: type
 412 compiler.err.concrete.inheritance.conflict=\
 413     methods {0} from {1} and {2} from {3} are inherited with the same signature
 414 
 415 compiler.err.default.allowed.in.intf.annotation.member=\
 416     default value only allowed in an annotation type declaration
 417 
 418 # 0: symbol
 419 compiler.err.doesnt.exist=\
 420     package {0} does not exist
 421 
 422 # 0: type
 423 compiler.err.duplicate.annotation.invalid.repeated=\
 424     annotation {0} is not a valid repeatable annotation
 425 
 426 # 0: name, 1: type
 427 compiler.err.duplicate.annotation.member.value=\
 428     duplicate element &#39;&#39;{0}&#39;&#39; in annotation @{1}.
 429 
 430 # 0: type
 431 compiler.err.duplicate.annotation.missing.container=\
 432     {0} is not a repeatable annotation type
 433 
 434 # 0: symbol
 435 compiler.err.invalid.repeatable.annotation=\
 436     duplicate annotation: {0} is annotated with an invalid @Repeatable annotation
 437 
 438 # 0: symbol or type
 439 compiler.err.invalid.repeatable.annotation.no.value=\
 440     {0} is not a valid @Repeatable, no value element method declared
 441 
 442 # 0: type, 1: number
 443 compiler.err.invalid.repeatable.annotation.multiple.values=\
 444     {0} is not a valid @Repeatable, {1} element methods named &#39;&#39;value&#39;&#39; declared
 445 
 446 # 0: type
 447 compiler.err.invalid.repeatable.annotation.invalid.value=\
 448     {0} is not a valid @Repeatable: invalid value element
 449 
 450 # 0: symbol or type, 1: type, 2: type
 451 compiler.err.invalid.repeatable.annotation.value.return=\
 452     containing annotation type ({0}) must declare an element named &#39;&#39;value&#39;&#39; of type {2}
 453 
 454 # 0: symbol or type, 1: symbol
 455 compiler.err.invalid.repeatable.annotation.elem.nondefault=\
 456     containing annotation type ({0}) does not have a default value for element {1}
 457 
 458 # 0: symbol, 1: string, 2: symbol, 3: string
 459 compiler.err.invalid.repeatable.annotation.retention=\
 460     retention of containing annotation type ({0}) is shorter than the retention of repeatable annotation type ({2})
 461 
 462 # 0: symbol, 1: symbol
 463 compiler.err.invalid.repeatable.annotation.not.documented=\
 464     repeatable annotation type ({1}) is @Documented while containing annotation type ({0}) is not
 465 
 466 # 0: symbol, 1: symbol
 467 compiler.err.invalid.repeatable.annotation.not.inherited=\
 468     repeatable annotation type ({1}) is @Inherited while containing annotation type ({0}) is not
 469 
 470 # 0: symbol, 1: symbol
 471 compiler.err.invalid.repeatable.annotation.incompatible.target=\
 472     containing annotation type ({0}) is applicable to more targets than repeatable annotation type ({1})
 473 
 474 # 0: symbol
 475 compiler.err.invalid.repeatable.annotation.repeated.and.container.present=\
 476     container {0} must not be present at the same time as the element it contains
 477 
 478 # 0: type, 1: symbol
 479 compiler.err.invalid.repeatable.annotation.not.applicable=\
 480     container {0} is not applicable to element {1}
 481 
 482 # 0: type
 483 compiler.err.invalid.repeatable.annotation.not.applicable.in.context=\
 484     container {0} is not applicable in this type context
 485 
 486 # 0: name
 487 compiler.err.duplicate.class=\
 488     duplicate class: {0}
 489 
 490 # 0: name, 1: name
 491 compiler.err.same.binary.name=\
 492     classes: {0} and {1} have the same binary name
 493 
 494 compiler.err.duplicate.case.label=\
 495     duplicate case label
 496 
 497 compiler.err.duplicate.default.label=\
 498     duplicate default label
 499 
 500 compiler.err.else.without.if=\
 501     &#39;&#39;else&#39;&#39; without &#39;&#39;if&#39;&#39;
 502 
 503 compiler.err.empty.char.lit=\
 504     empty character literal
 505 
 506 # 0: symbol
 507 compiler.err.encl.class.required=\
 508     an enclosing instance that contains {0} is required
 509 
 510 compiler.err.enum.annotation.must.be.enum.constant=\
 511     an enum annotation value must be an enum constant
 512 
 513 compiler.err.enum.cant.be.instantiated=\
 514     enum types may not be instantiated
 515 
 516 compiler.err.enum.label.must.be.unqualified.enum=\
 517     an enum switch case label must be the unqualified name of an enumeration constant
 518 
 519 compiler.err.enum.no.subclassing=\
 520     classes cannot directly extend java.lang.Enum
 521 
 522 compiler.err.enum.types.not.extensible=\
 523     enum types are not extensible
 524 
 525 compiler.err.enum.no.finalize=\
 526     enums cannot have finalize methods
 527 
 528 # 0: file name, 1: string
 529 compiler.err.error.reading.file=\
 530     error reading {0}; {1}
 531 
 532 # 0: type
 533 compiler.err.except.already.caught=\
 534     exception {0} has already been caught
 535 
 536 # 0: type
 537 compiler.err.except.never.thrown.in.try=\
 538     exception {0} is never thrown in body of corresponding try statement
 539 
 540 # 0: symbol
 541 compiler.err.final.parameter.may.not.be.assigned=\
 542     final parameter {0} may not be assigned
 543 
 544 # 0: symbol
 545 compiler.err.try.resource.may.not.be.assigned=\
 546     auto-closeable resource {0} may not be assigned
 547 
 548 # 0: symbol
 549 compiler.err.pattern.binding.may.not.be.assigned=\
 550     pattern binding {0} may not be assigned
 551 
 552 # 0: symbol
 553 compiler.err.multicatch.parameter.may.not.be.assigned=\
 554     multi-catch parameter {0} may not be assigned
 555 
 556 # 0: type, 1: type
 557 compiler.err.multicatch.types.must.be.disjoint=\
 558     Alternatives in a multi-catch statement cannot be related by subclassing\n\
 559     Alternative {0} is a subclass of alternative {1}
 560 
 561 compiler.err.finally.without.try=\
 562     &#39;&#39;finally&#39;&#39; without &#39;&#39;try&#39;&#39;
 563 
 564 # 0: type, 1: message segment
 565 compiler.err.foreach.not.applicable.to.type=\
 566     for-each not applicable to expression type\n\
 567     required: {1}\n\
 568     found:    {0}
 569 
 570 compiler.err.fp.number.too.large=\
 571     floating point number too large
 572 
 573 compiler.err.fp.number.too.small=\
 574     floating point number too small
 575 
 576 compiler.err.generic.array.creation=\
 577     generic array creation
 578 
 579 compiler.err.generic.throwable=\
 580     a generic class may not extend java.lang.Throwable
 581 
 582 # 0: symbol
 583 compiler.err.icls.cant.have.static.decl=\
 584     Illegal static declaration in inner class {0}\n\
 585     modifier \&#39;&#39;static\&#39;&#39; is only allowed in constant variable declarations
 586 
 587 # 0: string
 588 compiler.err.illegal.char=\
 589     illegal character: &#39;&#39;{0}&#39;&#39;
 590 
 591 # 0: string, 1: string
 592 compiler.err.illegal.char.for.encoding=\
 593     unmappable character (0x{0}) for encoding {1}
 594 
 595 # 0: set of flag, 1: set of flag
 596 compiler.err.illegal.combination.of.modifiers=\
 597     illegal combination of modifiers: {0} and {1}
 598 
 599 compiler.err.illegal.enum.static.ref=\
 600     illegal reference to static field from initializer
 601 
 602 compiler.err.illegal.esc.char=\
 603     illegal escape character
 604 
 605 compiler.err.illegal.forward.ref=\
 606     illegal forward reference
 607 
 608 # 0: symbol, 1: object
 609 compiler.err.not.in.profile=\
 610     {0} is not available in profile &#39;&#39;{1}&#39;&#39;
 611 
 612 # 0: symbol
 613 compiler.warn.forward.ref=\
 614     reference to variable &#39;&#39;{0}&#39;&#39; before it has been initialized
 615 
 616 compiler.err.illegal.self.ref=\
 617     self-reference in initializer
 618 
 619 # 0: symbol
 620 compiler.warn.self.ref=\
 621     self-reference in initializer of variable &#39;&#39;{0}&#39;&#39;
 622 
 623 compiler.err.illegal.generic.type.for.instof=\
 624     illegal generic type for instanceof
 625 
 626 # 0: type
 627 compiler.err.illegal.initializer.for.type=\
 628     illegal initializer for {0}
 629 
 630 compiler.err.illegal.line.end.in.char.lit=\
 631     illegal line end in character literal
 632 
 633 compiler.err.illegal.text.block.open=\
 634     illegal text block open delimiter sequence, missing line terminator
 635 
 636 compiler.warn.inconsistent.white.space.indentation=\
 637     inconsistent white space indentation
 638 
 639 compiler.warn.trailing.white.space.will.be.removed=\
 640     trailing white space will be removed
 641 
 642 compiler.err.illegal.nonascii.digit=\
 643     illegal non-ASCII digit
 644 
 645 compiler.err.illegal.underscore=\
 646     illegal underscore
 647 
 648 compiler.err.illegal.dot=\
 649     illegal &#39;&#39;.&#39;&#39;
 650 
 651 # 0: symbol
 652 compiler.err.illegal.qual.not.icls=\
 653     illegal qualifier; {0} is not an inner class
 654 
 655 compiler.err.illegal.start.of.expr=\
 656     illegal start of expression
 657 
 658 compiler.err.illegal.start.of.stmt=\
 659     illegal start of statement
 660 
 661 compiler.err.illegal.start.of.type=\
 662     illegal start of type
 663 
 664 compiler.err.illegal.parenthesized.expression=\
 665     illegal parenthesized expression
 666 
 667 compiler.err.illegal.unicode.esc=\
 668     illegal unicode escape
 669 
 670 # 0: symbol
 671 compiler.err.import.requires.canonical=\
 672     import requires canonical name for {0}
 673 
 674 compiler.err.improperly.formed.type.param.missing=\
 675     improperly formed type, some parameters are missing
 676 
 677 compiler.err.improperly.formed.type.inner.raw.param=\
 678     improperly formed type, type arguments given on a raw type
 679 
 680 # 0: type, 1: type
 681 compiler.err.incomparable.types=\
 682     incomparable types: {0} and {1}
 683 
 684 # 0: string
 685 compiler.err.int.number.too.large=\
 686     integer number too large
 687 
 688 compiler.err.intf.annotation.members.cant.have.params=\
 689     elements in annotation type declarations cannot declare formal parameters
 690 
 691 # 0: symbol
 692 compiler.err.intf.annotation.cant.have.type.params=\
 693     annotation type {0} cannot be generic
 694 
 695 compiler.err.intf.annotation.members.cant.have.type.params=\
 696     elements in annotation type declarations cannot be generic methods
 697 
 698 # 0: symbol, 1: type
 699 compiler.err.intf.annotation.member.clash=\
 700     annotation type {1} declares an element with the same name as method {0}
 701 
 702 compiler.err.intf.expected.here=\
 703     interface expected here
 704 
 705 compiler.err.intf.meth.cant.have.body=\
 706     interface abstract methods cannot have body
 707 
 708 compiler.err.invalid.annotation.member.type=\
 709     invalid type for annotation type element
 710 
 711 compiler.err.invalid.binary.number=\
 712     binary numbers must contain at least one binary digit
 713 
 714 compiler.err.invalid.hex.number=\
 715     hexadecimal numbers must contain at least one hexadecimal digit
 716 
 717 compiler.err.invalid.meth.decl.ret.type.req=\
 718     invalid method declaration; return type required
 719 
 720 compiler.err.varargs.and.old.array.syntax=\
 721     legacy array notation not allowed on variable-arity parameter
 722 
 723 compiler.err.varargs.and.receiver =\
 724     varargs notation not allowed on receiver parameter
 725 
 726 compiler.err.varargs.must.be.last =\
 727     varargs parameter must be the last parameter
 728 
 729 compiler.err.array.and.receiver =\
 730     legacy array notation not allowed on receiver parameter
 731 
 732 compiler.err.wrong.receiver =\
 733     wrong receiver parameter name
 734 
 735 compiler.err.variable.not.allowed=\
 736     variable declaration not allowed here
 737 
 738 # 0: name
 739 compiler.err.label.already.in.use=\
 740     label {0} already in use
 741 
 742 # 0: symbol
 743 compiler.err.local.var.accessed.from.icls.needs.final=\
 744     local variable {0} is accessed from within inner class; needs to be declared final
 745 
 746 compiler.err.local.enum=\
 747     enum types must not be local
 748 
 749 compiler.err.cannot.create.array.with.type.arguments=\
 750     cannot create array with type arguments
 751 
 752 compiler.err.cannot.create.array.with.diamond=\
 753     cannot create array with &#39;&#39;&lt;&gt;&#39;&#39;
 754 
 755 compiler.err.invalid.module.directive=\
 756   module directive keyword or &#39;&#39;}&#39;&#39; expected
 757 
 758 #
 759 # limits.  We don&#39;t give the limits in the diagnostic because we expect
 760 # them to change, yet we want to use the same diagnostic.  These are all
 761 # detected during code generation.
 762 #
 763 compiler.err.limit.code=\
 764     code too large
 765 
 766 compiler.err.limit.code.too.large.for.try.stmt=\
 767     code too large for try statement
 768 
 769 compiler.err.limit.dimensions=\
 770     array type has too many dimensions
 771 
 772 compiler.err.limit.locals=\
 773     too many local variables
 774 
 775 compiler.err.limit.parameters=\
 776     too many parameters
 777 
 778 compiler.err.limit.pool=\
 779     too many constants
 780 
 781 compiler.err.limit.pool.in.class=\
 782     too many constants in class {0}
 783 
 784 compiler.err.limit.stack=\
 785     code requires too much stack
 786 
 787 compiler.err.limit.string=\
 788     constant string too long
 789 
 790 # 0: string
 791 compiler.err.limit.string.overflow=\
 792     UTF8 representation for string \&quot;{0}...\&quot; is too long for the constant pool
 793 
 794 compiler.err.malformed.fp.lit=\
 795     malformed floating point literal
 796 
 797 compiler.err.method.does.not.override.superclass=\
 798     method does not override or implement a method from a supertype
 799 
 800 compiler.err.static.methods.cannot.be.annotated.with.override=\
 801     static methods cannot be annotated with @Override
 802 
 803 compiler.err.missing.meth.body.or.decl.abstract=\
 804     missing method body, or declare abstract
 805 
 806 compiler.err.missing.ret.stmt=\
 807     missing return statement
 808 
 809 # 0: type
 810 compiler.misc.missing.ret.val=\
 811     missing return value
 812 
 813 compiler.misc.unexpected.ret.val=\
 814     unexpected return value
 815 
 816 # 0: set of flag
 817 compiler.err.mod.not.allowed.here=\
 818     modifier {0} not allowed here
 819 
 820 # 0: name
 821 compiler.err.modifier.not.allowed.here=\
 822     modifier {0} not allowed here
 823 
 824 compiler.err.intf.not.allowed.here=\
 825     interface not allowed here
 826 
 827 # 0: symbol, 1: symbol
 828 compiler.err.name.clash.same.erasure=\
 829     name clash: {0} and {1} have the same erasure
 830 
 831 # 0: name, 1: list of type, 2: symbol, 3: name, 4: list of type, 5: symbol
 832 compiler.err.name.clash.same.erasure.no.override=\
 833     name clash: {0}({1}) in {2} and {3}({4}) in {5} have the same erasure, yet neither overrides the other
 834 
 835 # 0: string, 1: name, 2: name, 3: list of type, 4: symbol, 5: name, 6: list of type, 7: symbol
 836 compiler.err.name.clash.same.erasure.no.override.1=\
 837     name clash: {0} {1} has two methods with the same erasure, yet neither overrides the other\n\
 838     first method:  {2}({3}) in {4}\n\
 839     second method: {5}({6}) in {7}
 840 
 841 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
 842 compiler.err.name.clash.same.erasure.no.hide=\
 843     name clash: {0} in {1} and {2} in {3} have the same erasure, yet neither hides the other
 844 
 845 compiler.err.name.reserved.for.internal.use=\
 846     {0} is reserved for internal use
 847 
 848 compiler.err.native.meth.cant.have.body=\
 849     native methods cannot have a body
 850 
 851 
 852 # 0: message segment
 853 compiler.misc.incompatible.type.in.conditional=\
 854     bad type in conditional expression\n\
 855     {0}
 856 
 857 compiler.misc.conditional.target.cant.be.void=\
 858     target-type for conditional expression cannot be void
 859 
 860 compiler.misc.switch.expression.target.cant.be.void=\
 861     target-type for switch expression cannot be void
 862 
 863 # 0: message segment
 864 compiler.misc.incompatible.type.in.switch.expression=\
 865     bad type in switch expression\n\
 866     {0}
 867 
 868 # 0: message segment
 869 compiler.misc.incompatible.ret.type.in.lambda=\
 870     bad return type in lambda expression\n\
 871     {0}
 872 
 873 compiler.misc.stat.expr.expected=\
 874     lambda body is not compatible with a void functional interface\n\
 875     (consider using a block lambda body, or use a statement expression instead)
 876 
 877 # 0: message segment
 878 compiler.misc.incompatible.ret.type.in.mref=\
 879     bad return type in method reference\n\
 880     {0}
 881 
 882 compiler.err.lambda.body.neither.value.nor.void.compatible=\
 883     lambda body is neither value nor void compatible
 884 
 885 # 0: list of type
 886 compiler.err.incompatible.thrown.types.in.mref=\
 887     incompatible thrown types {0} in functional expression
 888 
 889 compiler.misc.incompatible.arg.types.in.lambda=\
 890     incompatible parameter types in lambda expression
 891 
 892 compiler.misc.incompatible.arg.types.in.mref=\
 893     incompatible parameter types in method reference
 894 
 895 compiler.err.new.not.allowed.in.annotation=\
 896     &#39;&#39;new&#39;&#39; not allowed in an annotation
 897 
 898 # 0: name, 1: type
 899 compiler.err.no.annotation.member=\
 900     no annotation member {0} in {1}
 901 
 902 # 0: symbol
 903 compiler.err.no.encl.instance.of.type.in.scope=\
 904     no enclosing instance of type {0} is in scope
 905 
 906 compiler.err.no.intf.expected.here=\
 907     no interface expected here
 908 
 909 compiler.err.no.match.entry=\
 910     {0} has no match in entry in {1}; required {2}
 911 
 912 # 0: type
 913 compiler.err.not.annotation.type=\
 914     {0} is not an annotation type
 915 
 916 # 0: symbol, 1: symbol, 2: message segment
 917 compiler.err.not.def.access.package.cant.access=\
 918     {0} is not visible\n\
 919     ({2})
 920 
 921 # 0: symbol, 1: symbol, 2: message segment
 922 compiler.misc.not.def.access.package.cant.access=\
 923     {0} is not visible\n\
 924     ({2})
 925 
 926 # 0: symbol, 1: message segment
 927 compiler.err.package.not.visible=\
 928     package {0} is not visible\n\
 929     ({1})
 930 
 931 # 0: symbol, 1: message segment
 932 compiler.misc.package.not.visible=\
 933     package {0} is not visible\n\
 934     ({1})
 935 
 936 # {0} - current module
 937 # {1} - package in which the invisible class is declared
 938 # {2} - module in which {1} is declared
 939 # 0: symbol, 1: symbol, 2: symbol
 940 compiler.misc.not.def.access.does.not.read=\
 941     package {1} is declared in module {2}, but module {0} does not read it
 942 
 943 # {0} - package in which the invisible class is declared
 944 # {1} - module in which {0} is declared
 945 # 0: symbol, 1: symbol
 946 compiler.misc.not.def.access.does.not.read.from.unnamed=\
 947     package {0} is declared in module {1}, which is not in the module graph
 948 
 949 # {0} - package in which the invisible class is declared
 950 # {1} - current module
 951 # 0: symbol, 1: symbol
 952 compiler.misc.not.def.access.does.not.read.unnamed=\
 953     package {0} is declared in the unnamed module, but module {1} does not read it
 954 
 955 # {0} - package in which the invisible class is declared
 956 # {1} - module in which {0} is declared
 957 # 0: symbol, 1: symbol
 958 compiler.misc.not.def.access.not.exported=\
 959     package {0} is declared in module {1}, which does not export it
 960 
 961 # {0} - package in which the invisible class is declared
 962 # {1} - module in which {0} is declared
 963 # 0: symbol, 1: symbol
 964 compiler.misc.not.def.access.not.exported.from.unnamed=\
 965     package {0} is declared in module {1}, which does not export it
 966 
 967 # {0} - package in which the invisible class is declared
 968 # {1} - module in which {0} is declared
 969 # {2} - current module
 970 # 0: symbol, 1: symbol, 2: symbol
 971 compiler.misc.not.def.access.not.exported.to.module=\
 972     package {0} is declared in module {1}, which does not export it to module {2}
 973 
 974 # {0} - package in which the invisible class is declared
 975 # {1} - module in which {0} is declared
 976 # 0: symbol, 1: symbol
 977 compiler.misc.not.def.access.not.exported.to.module.from.unnamed=\
 978     package {0} is declared in module {1}, which does not export it to the unnamed module
 979 
 980 # 0: symbol, 1: symbol
 981 compiler.err.not.def.access.class.intf.cant.access=\
 982     {1}.{0} is defined in an inaccessible class or interface
 983 
 984 # 0: symbol, 1: symbol
 985 compiler.misc.not.def.access.class.intf.cant.access=\
 986     {1}.{0} is defined in an inaccessible class or interface
 987 
 988 # 0: symbol, 1: symbol, 2: symbol, 3: message segment
 989 compiler.err.not.def.access.class.intf.cant.access.reason=\
 990     {1}.{0} in package {2} is not accessible\n\
 991     ({3})
 992 
 993 # 0: symbol, 1: symbol, 2: symbol, 3: message segment
 994 compiler.misc.not.def.access.class.intf.cant.access.reason=\
 995     {1}.{0} in package {2} is not accessible\n\
 996     ({3})
 997 
 998 # 0: symbol, 1: list of type, 2: type
 999 compiler.misc.cant.access.inner.cls.constr=\
1000     cannot access constructor {0}({1})\n\
1001     an enclosing instance of type {2} is not in scope
1002 
1003 # 0: symbol, 1: symbol
1004 compiler.err.not.def.public.cant.access=\
1005     {0} is not public in {1}; cannot be accessed from outside package
1006 
1007 # 0: symbol, 1: symbol
1008 compiler.err.not.def.public=\
1009     {0} is not public in {1}
1010 
1011 # 0: symbol, 1: symbol
1012 compiler.misc.not.def.public.cant.access=\
1013     {0} is not public in {1}; cannot be accessed from outside package
1014 
1015 # 0: name
1016 compiler.err.not.loop.label=\
1017     not a loop label: {0}
1018 
1019 compiler.err.not.stmt=\
1020     not a statement
1021 
1022 # 0: symbol
1023 compiler.err.not.encl.class=\
1024     not an enclosing class: {0}
1025 
1026 # 0: name, 1: type
1027 compiler.err.operator.cant.be.applied=\
1028     bad operand type {1} for unary operator &#39;&#39;{0}&#39;&#39;
1029 
1030 # 0: name, 1: type, 2: type
1031 compiler.err.operator.cant.be.applied.1=\
1032     bad operand types for binary operator &#39;&#39;{0}&#39;&#39;\n\
1033     first type:  {1}\n\
1034     second type: {2}
1035 
1036 compiler.err.pkg.annotations.sb.in.package-info.java=\
1037     package annotations should be in file package-info.java
1038 
1039 compiler.err.no.pkg.in.module-info.java=\
1040     package declarations not allowed in file module-info.java
1041 
1042 # 0: symbol
1043 compiler.err.pkg.clashes.with.class.of.same.name=\
1044     package {0} clashes with class of same name
1045 
1046 compiler.err.warnings.and.werror=\
1047     warnings found and -Werror specified
1048 
1049 # Errors related to annotation processing
1050 
1051 # 0: symbol, 1: message segment, 2: string (stack-trace)
1052 compiler.err.proc.cant.access=\
1053     cannot access {0}\n\
1054     {1}\n\
1055     Consult the following stack trace for details.\n\
1056     {2}
1057 
1058 # 0: symbol, 1: message segment
1059 compiler.err.proc.cant.access.1=\
1060     cannot access {0}\n\
1061     {1}
1062 
1063 # 0: string
1064 compiler.err.proc.cant.find.class=\
1065     Could not find class file for &#39;&#39;{0}&#39;&#39;.
1066 
1067 # 0: string
1068 compiler.err.proc.cant.load.class=\
1069     Could not load processor class file due to &#39;&#39;{0}&#39;&#39;.
1070 
1071 # Print a client-generated error message; assumed to be localized, no translation required
1072 # 0: string
1073 compiler.err.proc.messager=\
1074     {0}
1075 
1076 # 0: string
1077 compiler.misc.exception.message=\
1078     {0}
1079 
1080 compiler.misc.user.selected.completion.failure=\
1081     user-selected completion failure by class name
1082 
1083 # 0: collection of string
1084 compiler.err.proc.no.explicit.annotation.processing.requested=\
1085     Class names, &#39;&#39;{0}&#39;&#39;, are only accepted if annotation processing is explicitly requested
1086 
1087 compiler.err.proc.no.service=\
1088     A ServiceLoader was not usable and is required for annotation processing.
1089 
1090 # 0: string, 1: string
1091 compiler.err.proc.processor.bad.option.name=\
1092     Bad option name &#39;&#39;{0}&#39;&#39; provided by processor &#39;&#39;{1}&#39;&#39;
1093 
1094 # 0: string
1095 compiler.err.proc.processor.cant.instantiate=\
1096     Could not instantiate an instance of processor &#39;&#39;{0}&#39;&#39;
1097 
1098 # 0: string
1099 compiler.err.proc.processor.not.found=\
1100     Annotation processor &#39;&#39;{0}&#39;&#39; not found
1101 
1102 # 0: string
1103 compiler.err.proc.processor.wrong.type=\
1104     Annotation processor &#39;&#39;{0}&#39;&#39; does not implement javax.annotation.processing.Processor
1105 
1106 compiler.err.proc.service.problem=\
1107     Error creating a service loader to load Processors.
1108 
1109 # 0: string
1110 compiler.err.proc.bad.config.file=\
1111     Bad service configuration file, or exception thrown while constructing Processor object: {0}
1112 
1113 compiler.err.proc.cant.create.loader=\
1114     Could not create class loader for annotation processors: {0}
1115 
1116 # 0: symbol
1117 compiler.err.qualified.new.of.static.class=\
1118     qualified new of static class
1119 
1120 compiler.err.recursive.ctor.invocation=\
1121     recursive constructor invocation
1122 
1123 # 0: name, 1: symbol kind, 2: symbol, 3: symbol, 4: symbol kind, 5: symbol, 6: symbol
1124 compiler.err.ref.ambiguous=\
1125     reference to {0} is ambiguous\n\
1126     both {1} {2} in {3} and {4} {5} in {6} match
1127 
1128 # 0: name, 1: symbol kind, 2: symbol, 3: symbol, 4: symbol kind, 5: symbol, 6: symbol
1129 compiler.misc.ref.ambiguous=\
1130     reference to {0} is ambiguous\n\
1131     both {1} {2} in {3} and {4} {5} in {6} match
1132 
1133 compiler.err.repeated.annotation.target=\
1134     repeated annotation target
1135 
1136 compiler.err.repeated.interface=\
1137     repeated interface
1138 
1139 compiler.err.repeated.modifier=\
1140     repeated modifier
1141 
1142 # 0: symbol, 1: set of modifier, 2: symbol
1143 compiler.err.report.access=\
1144     {0} has {1} access in {2}
1145 
1146 # 0: symbol, 1: set of modifier, 2: symbol
1147 compiler.misc.report.access=\
1148     {0} has {1} access in {2}
1149 
1150 compiler.err.ret.outside.meth=\
1151     return outside method
1152 
1153 compiler.err.signature.doesnt.match.supertype=\
1154     signature does not match {0}; incompatible supertype
1155 
1156 compiler.err.signature.doesnt.match.intf=\
1157     signature does not match {0}; incompatible interfaces
1158 
1159 # 0: symbol, 1: symbol, 2: symbol
1160 compiler.err.does.not.override.abstract=\
1161     {0} is not abstract and does not override abstract method {1} in {2}
1162 
1163 # 0: file object
1164 compiler.err.source.cant.overwrite.input.file=\
1165     error writing source; cannot overwrite input file {0}
1166 
1167 # 0: symbol
1168 compiler.err.stack.sim.error=\
1169     Internal error: stack sim error on {0}
1170 
1171 compiler.err.static.imp.only.classes.and.interfaces=\
1172     static import only from classes and interfaces
1173 
1174 compiler.err.string.const.req=\
1175     constant string expression required
1176 
1177 # 0: symbol, 1: fragment
1178 compiler.err.cannot.generate.class=\
1179     error while generating class {0}\n\
1180     ({1})
1181 
1182 # 0: symbol, 1: symbol
1183 compiler.misc.synthetic.name.conflict=\
1184     the symbol {0} conflicts with a compiler-synthesized symbol in {1}
1185 
1186 # 0: symbol, 1: type
1187 compiler.misc.illegal.signature=\
1188     illegal signature attribute for type {1}
1189 
1190 compiler.err.throws.not.allowed.in.intf.annotation=\
1191     throws clause not allowed in @interface members
1192 
1193 compiler.err.try.without.catch.finally.or.resource.decls=\
1194     &#39;&#39;try&#39;&#39; without &#39;&#39;catch&#39;&#39;, &#39;&#39;finally&#39;&#39; or resource declarations
1195 
1196 # 0: symbol
1197 compiler.err.type.doesnt.take.params=\
1198     type {0} does not take parameters
1199 
1200 compiler.err.type.var.cant.be.deref=\
1201     cannot select from a type variable
1202 
1203 compiler.err.type.var.may.not.be.followed.by.other.bounds=\
1204     a type variable may not be followed by other bounds
1205 
1206 compiler.err.type.var.more.than.once=\
1207     type variable {0} occurs more than once in result type of {1}; cannot be left uninstantiated
1208 
1209 compiler.err.type.var.more.than.once.in.result=\
1210     type variable {0} occurs more than once in type of {1}; cannot be left uninstantiated
1211 
1212 # 0: type, 1: type, 2: fragment
1213 compiler.err.types.incompatible=\
1214     types {0} and {1} are incompatible;\n\
1215     {2}
1216 
1217 # 0: name, 1: list of type
1218 compiler.misc.incompatible.diff.ret=\
1219     both define {0}({1}), but with unrelated return types
1220 
1221 # 0: kind name, 1: type, 2: name, 3: list of type, 4: symbol, 5: symbol
1222 compiler.misc.incompatible.unrelated.defaults=\
1223     {0} {1} inherits unrelated defaults for {2}({3}) from types {4} and {5}
1224 
1225 # 0: kind name, 1: type, 2: name, 3: list of type, 4: symbol, 5: symbol
1226 compiler.misc.incompatible.abstract.default=\
1227     {0} {1} inherits abstract and default for {2}({3}) from types {4} and {5}
1228 
1229 # 0: name, 1: kind name, 2: symbol
1230 compiler.err.default.overrides.object.member=\
1231     default method {0} in {1} {2} overrides a member of java.lang.Object
1232 
1233 # 0: type
1234 compiler.err.illegal.static.intf.meth.call=\
1235     illegal static interface method call\n\
1236     the receiver expression should be replaced with the type qualifier &#39;&#39;{0}&#39;&#39;
1237 
1238 # 0: symbol or type, 1: message segment
1239 compiler.err.illegal.default.super.call=\
1240     bad type qualifier {0} in default super call\n\
1241     {1}
1242 
1243 # 0: symbol, 1: type
1244 compiler.misc.overridden.default=\
1245     method {0} is overridden in {1}
1246 
1247 # 0: symbol, 1: type or symbol
1248 compiler.misc.redundant.supertype=\
1249     redundant interface {0} is extended by {1}
1250 
1251 compiler.err.unclosed.char.lit=\
1252     unclosed character literal
1253 
1254 compiler.err.unclosed.comment=\
1255     unclosed comment
1256 
1257 compiler.err.unclosed.str.lit=\
1258     unclosed string literal
1259 
1260 compiler.err.unclosed.text.block=\
1261     unclosed text block
1262 
1263 # 0: string
1264 compiler.err.unsupported.encoding=\
1265     unsupported encoding: {0}
1266 
1267 compiler.err.io.exception=\
1268     error reading source file: {0}
1269 
1270 # 0: name
1271 compiler.err.undef.label=\
1272     undefined label: {0}
1273 
1274 # 0: name
1275 compiler.err.illegal.ref.to.restricted.type=\
1276     illegal reference to restricted type &#39;&#39;{0}&#39;&#39;
1277 
1278 # 0: name
1279 compiler.warn.illegal.ref.to.restricted.type=\
1280     illegal reference to restricted type &#39;&#39;{0}&#39;&#39;
1281 
1282 # 0: name, 1: source
1283 compiler.err.restricted.type.not.allowed=\
1284     &#39;&#39;{0}&#39;&#39; not allowed here\n\
1285     as of release {1}, &#39;&#39;{0}&#39;&#39; is a restricted type name and cannot be used for type declarations
1286 
1287 # 0: name, 1: source
1288 compiler.warn.restricted.type.not.allowed=\
1289     as of release {1}, &#39;&#39;{0}&#39;&#39; is a restricted type name and cannot be used for type declarations or as the element type of an array
1290 
1291 # 0: name, 1: source
1292 compiler.warn.restricted.type.not.allowed.preview=\
1293     &#39;&#39;{0}&#39;&#39; may become a restricted type name in a future release and may be unusable for type declarations or as the element type of an array
1294 
1295 # 0: name (variable), 1: message segment
1296 compiler.err.cant.infer.local.var.type=\
1297     cannot infer type for local variable {0}\n\
1298     ({1})
1299 
1300 # 0: name
1301 compiler.err.restricted.type.not.allowed.here=\
1302     &#39;&#39;{0}&#39;&#39; is not allowed here
1303 
1304 # 0: name
1305 compiler.err.restricted.type.not.allowed.array=\
1306     &#39;&#39;{0}&#39;&#39; is not allowed as an element type of an array
1307 
1308 # 0: name
1309 compiler.err.restricted.type.not.allowed.compound=\
1310     &#39;&#39;{0}&#39;&#39; is not allowed in a compound declaration
1311 
1312 # 0: fragment
1313 compiler.err.invalid.lambda.parameter.declaration=\
1314     invalid lambda parameter declaration\n\
1315     ({0})
1316 
1317 compiler.misc.implicit.and.explicit.not.allowed=\
1318     cannot mix implicitly-typed and explicitly-typed parameters
1319 
1320 compiler.misc.var.and.explicit.not.allowed=\
1321     cannot mix &#39;&#39;var&#39;&#39; and explicitly-typed parameters
1322 
1323 compiler.misc.var.and.implicit.not.allowed=\
1324     cannot mix &#39;&#39;var&#39;&#39; and implicitly-typed parameters
1325 
1326 compiler.misc.local.cant.infer.null=\
1327     variable initializer is &#39;&#39;null&#39;&#39;
1328 
1329 compiler.misc.local.cant.infer.void=\
1330     variable initializer is &#39;&#39;void&#39;&#39;
1331 
1332 compiler.misc.local.missing.init=\
1333     cannot use &#39;&#39;var&#39;&#39; on variable without initializer
1334 
1335 compiler.misc.local.lambda.missing.target=\
1336     lambda expression needs an explicit target-type
1337 
1338 compiler.misc.local.mref.missing.target=\
1339     method reference needs an explicit target-type
1340 
1341 compiler.misc.local.array.missing.target=\
1342     array initializer needs an explicit target-type
1343 
1344 compiler.misc.local.self.ref=\
1345     cannot use &#39;&#39;var&#39;&#39; on self-referencing variable
1346 
1347 # 0: message segment, 1: unused
1348 compiler.err.cant.apply.diamond=\
1349     cannot infer type arguments for {0}
1350 
1351 # 0: message segment or type, 1: message segment
1352 compiler.err.cant.apply.diamond.1=\
1353     cannot infer type arguments for {0}\n\
1354     reason: {1}
1355 
1356 # 0: message segment or type, 1: message segment
1357 compiler.misc.cant.apply.diamond.1=\
1358     cannot infer type arguments for {0}\n\
1359     reason: {1}
1360 
1361 compiler.err.unreachable.stmt=\
1362     unreachable statement
1363 
1364 compiler.err.not.exhaustive=\
1365     the switch expression does not cover all possible input values
1366 
1367 compiler.err.initializer.must.be.able.to.complete.normally=\
1368     initializer must be able to complete normally
1369 
1370 compiler.err.initializer.not.allowed=\
1371     initializers not allowed in interfaces
1372 
1373 # 0: type
1374 compiler.err.unreported.exception.need.to.catch.or.throw=\
1375     unreported exception {0}; must be caught or declared to be thrown
1376 
1377 # 0: type
1378 compiler.err.unreported.exception.default.constructor=\
1379     unreported exception {0} in default constructor
1380 
1381 # 0: type, 1: name
1382 compiler.err.unreported.exception.implicit.close=\
1383     unreported exception {0}; must be caught or declared to be thrown\n\
1384     exception thrown from implicit call to close() on resource variable &#39;&#39;{1}&#39;&#39;
1385 
1386 compiler.err.void.not.allowed.here=\
1387     &#39;&#39;void&#39;&#39; type not allowed here
1388 
1389 # 0: string
1390 compiler.err.wrong.number.type.args=\
1391     wrong number of type arguments; required {0}
1392 
1393 # 0: symbol
1394 compiler.err.var.might.already.be.assigned=\
1395     variable {0} might already have been assigned
1396 
1397 # 0: symbol
1398 compiler.err.var.might.not.have.been.initialized=\
1399     variable {0} might not have been initialized
1400 
1401 # 0: symbol
1402 compiler.err.var.not.initialized.in.default.constructor=\
1403     variable {0} not initialized in the default constructor
1404 
1405 # 0: symbol
1406 compiler.err.var.might.be.assigned.in.loop=\
1407     variable {0} might be assigned in loop
1408 
1409 # 0: symbol, 1: message segment
1410 compiler.err.varargs.invalid.trustme.anno=\
1411     Invalid {0} annotation. {1}
1412 
1413 # 0: type
1414 compiler.misc.varargs.trustme.on.reifiable.varargs=\
1415     Varargs element type {0} is reifiable.
1416 
1417 # 0: type, 1: type
1418 compiler.err.instanceof.reifiable.not.safe=\
1419     {0} cannot be safely cast to {1}
1420 
1421 # 0: symbol
1422 compiler.misc.varargs.trustme.on.non.varargs.meth=\
1423     Method {0} is not a varargs method.
1424 
1425 # 0: symbol
1426 compiler.misc.varargs.trustme.on.virtual.varargs=\
1427     Instance method {0} is neither final nor private.
1428 
1429 # 0: symbol
1430 compiler.misc.varargs.trustme.on.virtual.varargs.final.only=\
1431     Instance method {0} is not final.
1432 
1433 # 0: type, 1: symbol kind, 2: symbol
1434 compiler.misc.inaccessible.varargs.type=\
1435     formal varargs element type {0} is not accessible from {1} {2}
1436 
1437 # In the following string, {1} will always be the detail message from
1438 # java.io.IOException.
1439 # 0: symbol, 1: string
1440 compiler.err.class.cant.write=\
1441     error while writing {0}: {1}
1442 
1443 # In the following string, {0} is the name of the class in the Java source.
1444 # It really should be used two times..
1445 # 0: kind name, 1: name
1446 compiler.err.class.public.should.be.in.file=\
1447     {0} {1} is public, should be declared in a file named {1}.java
1448 
1449 ## All errors which do not refer to a particular line in the source code are
1450 ## preceded by this string.
1451 compiler.err.error=\
1452     error:\u0020
1453 
1454 # The following error messages do not refer to a line in the source code.
1455 compiler.err.cant.read.file=\
1456     cannot read: {0}
1457 
1458 # 0: string
1459 compiler.err.plugin.not.found=\
1460     plug-in not found: {0}
1461 
1462 # 0: path
1463 compiler.warn.locn.unknown.file.on.module.path=\
1464     unknown file on module path: {0}
1465 
1466 
1467 # 0: path
1468 compiler.err.locn.bad.module-info=\
1469     problem reading module-info.class in {0}
1470 
1471 # 0: path
1472 compiler.err.locn.cant.read.directory=\
1473     cannot read directory {0}
1474 
1475 # 0: path
1476 compiler.err.locn.cant.read.file=\
1477     cannot read file {0}
1478 
1479 # 0: path
1480 compiler.err.locn.cant.get.module.name.for.jar=\
1481     cannot determine module name for {0}
1482 
1483 # 0: path
1484 compiler.err.multi-module.outdir.cannot.be.exploded.module=\
1485     in multi-module mode, the output directory cannot be an exploded module: {0}
1486 
1487 # 0: path
1488 compiler.warn.outdir.is.in.exploded.module=\
1489     the output directory is within an exploded module: {0}
1490 
1491 # 0: file object
1492 compiler.err.locn.module-info.not.allowed.on.patch.path=\
1493     module-info.class not allowed on patch path: {0}
1494 
1495 # 0: string
1496 compiler.err.locn.invalid.arg.for.xpatch=\
1497     invalid argument for --patch-module option: {0}
1498 
1499 compiler.err.file.sb.on.source.or.patch.path.for.module=\
1500     file should be on source path, or on patch path for module
1501 
1502 #####
1503 
1504 # Fatal Errors
1505 
1506 compiler.misc.fatal.err.no.java.lang=\
1507     Fatal Error: Unable to find package java.lang in classpath or bootclasspath
1508 
1509 # 0: name
1510 compiler.misc.fatal.err.cant.locate.meth=\
1511     Fatal Error: Unable to find method {0}
1512 
1513 # 0: name
1514 compiler.misc.fatal.err.cant.locate.field=\
1515     Fatal Error: Unable to find field {0}
1516 
1517 # 0: type
1518 compiler.misc.fatal.err.cant.locate.ctor=\
1519     Fatal Error: Unable to find constructor for {0}
1520 
1521 compiler.misc.fatal.err.cant.close=\
1522     Fatal Error: Cannot close compiler resources
1523 
1524 #####
1525 
1526 ##
1527 ## miscellaneous strings
1528 ##
1529 
1530 compiler.misc.diamond.anonymous.methods.implicitly.override=\
1531     (due to &lt;&gt;, every non-private method declared in this anonymous class must override or implement a method from a supertype)
1532 
1533 compiler.misc.source.unavailable=\
1534     (source unavailable)
1535 
1536 compiler.misc.base.membership=\
1537     all your base class are belong to us
1538 
1539 # 0: string, 1: string, 2: boolean
1540 compiler.misc.x.print.processor.info=\
1541     Processor {0} matches {1} and returns {2}.
1542 
1543 # 0: number, 1: string, 2: set of symbol, 3: boolean
1544 compiler.misc.x.print.rounds=\
1545     Round {0}:\n\tinput files: {1}\n\tannotations: {2}\n\tlast round: {3}
1546 
1547 # 0: file name
1548 compiler.warn.file.from.future=\
1549     Modification date is in the future for file {0}
1550 
1551 #####
1552 
1553 ## The following string will appear before all messages keyed as:
1554 ## &quot;compiler.note&quot;.
1555 
1556 compiler.note.compressed.diags=\
1557     Some messages have been simplified; recompile with -Xdiags:verbose to get full output
1558 
1559 # 0: boolean, 1: symbol
1560 compiler.note.lambda.stat=\
1561     Translating lambda expression\n\
1562     alternate metafactory = {0}\n\
1563     synthetic method = {1}
1564 
1565 # 0: boolean, 1: unused
1566 compiler.note.mref.stat=\
1567     Translating method reference\n\
1568     alternate metafactory = {0}\n\
1569 
1570 # 0: boolean, 1: symbol
1571 compiler.note.mref.stat.1=\
1572     Translating method reference\n\
1573     alternate metafactory = {0}\n\
1574     bridge method = {1}
1575 
1576 compiler.note.note=\
1577     Note:\u0020
1578 
1579 # 0: file name
1580 compiler.note.deprecated.filename=\
1581     {0} uses or overrides a deprecated API.
1582 
1583 compiler.note.deprecated.plural=\
1584     Some input files use or override a deprecated API.
1585 
1586 # The following string may appear after one of the above deprecation
1587 # messages.
1588 compiler.note.deprecated.recompile=\
1589     Recompile with -Xlint:deprecation for details.
1590 
1591 # 0: file name
1592 compiler.note.deprecated.filename.additional=\
1593     {0} has additional uses or overrides of a deprecated API.
1594 
1595 compiler.note.deprecated.plural.additional=\
1596     Some input files additionally use or override a deprecated API.
1597 
1598 # 0: file name
1599 compiler.note.removal.filename=\
1600     {0} uses or overrides a deprecated API that is marked for removal.
1601 
1602 compiler.note.removal.plural=\
1603     Some input files use or override a deprecated API that is marked for removal.
1604 
1605 # The following string may appear after one of the above removal messages.
1606 compiler.note.removal.recompile=\
1607     Recompile with -Xlint:removal for details.
1608 
1609 # 0: file name
1610 compiler.note.removal.filename.additional=\
1611     {0} has additional uses or overrides of a deprecated API that is marked for removal.
1612 
1613 compiler.note.removal.plural.additional=\
1614     Some input files additionally use or override a deprecated API that is marked for removal.
1615 
1616 # 0: file name
1617 compiler.note.unchecked.filename=\
1618     {0} uses unchecked or unsafe operations.
1619 
1620 compiler.note.unchecked.plural=\
1621     Some input files use unchecked or unsafe operations.
1622 
1623 # The following string may appear after one of the above unchecked messages.
1624 compiler.note.unchecked.recompile=\
1625     Recompile with -Xlint:unchecked for details.
1626 
1627 # 0: file name
1628 compiler.note.unchecked.filename.additional=\
1629     {0} has additional unchecked or unsafe operations.
1630 
1631 compiler.note.unchecked.plural.additional=\
1632     Some input files additionally use unchecked or unsafe operations.
1633 
1634 # 0: file name
1635 compiler.note.preview.filename=\
1636     {0} uses preview language features.
1637 
1638 compiler.note.preview.plural=\
1639     Some input files use preview language features.
1640 
1641 # The following string may appear after one of the above deprecation
1642 # messages.
1643 compiler.note.preview.recompile=\
1644     Recompile with -Xlint:preview for details.
1645 
1646 # 0: file name
1647 compiler.note.preview.filename.additional=\
1648     {0} has additional uses of preview language features.
1649 
1650 compiler.note.preview.plural.additional=\
1651     Some input files additionally use preview language features.
1652 
1653 # Notes related to annotation processing
1654 
1655 # Print a client-generated note; assumed to be localized, no translation required
1656 # 0: string
1657 compiler.note.proc.messager=\
1658     {0}
1659 
1660 # 0: string, 1: string, 2: string
1661 compiler.note.multiple.elements=\
1662     Multiple elements named &#39;&#39;{1}&#39;&#39; in modules &#39;&#39;{2}&#39;&#39; were found by javax.lang.model.util.Elements.{0}.
1663 
1664 #####
1665 
1666 # 0: number
1667 compiler.misc.count.error=\
1668     {0} error
1669 
1670 # 0: number
1671 compiler.misc.count.error.plural=\
1672     {0} errors
1673 
1674 # 0: number, 1: number
1675 compiler.misc.count.error.recompile=\
1676     only showing the first {0} errors, of {1} total; use -Xmaxerrs if you would like to see more
1677 
1678 # 0: number, 1: number
1679 compiler.misc.count.warn.recompile=\
1680     only showing the first {0} warnings, of {1} total; use -Xmaxwarns if you would like to see more
1681 
1682 # 0: number
1683 compiler.misc.count.warn=\
1684     {0} warning
1685 
1686 # 0: number
1687 compiler.misc.count.warn.plural=\
1688     {0} warnings
1689 
1690 compiler.misc.version.not.available=\
1691     (version info not available)
1692 
1693 ## extra output when using -verbose (JavaCompiler)
1694 
1695 # 0: symbol
1696 compiler.misc.verbose.checking.attribution=\
1697     [checking {0}]
1698 
1699 # 0: string
1700 compiler.misc.verbose.parsing.done=\
1701     [parsing completed {0}ms]
1702 
1703 # 0: file name
1704 compiler.misc.verbose.parsing.started=\
1705     [parsing started {0}]
1706 
1707 # 0: string
1708 compiler.misc.verbose.total=\
1709     [total {0}ms]
1710 
1711 # 0: file name
1712 compiler.misc.verbose.wrote.file=\
1713     [wrote {0}]
1714 
1715 ## extra output when using -verbose (code/ClassReader)
1716 # 0: string
1717 compiler.misc.verbose.loading=\
1718     [loading {0}]
1719 
1720 # 0: string
1721 compiler.misc.verbose.sourcepath=\
1722     [search path for source files: {0}]
1723 
1724 # 0: string
1725 compiler.misc.verbose.classpath=\
1726     [search path for class files: {0}]
1727 
1728 ## extra output when using -prompt (util/Log)
1729 compiler.misc.resume.abort=\
1730     R)esume, A)bort&gt;
1731 
1732 #####
1733 
1734 ##
1735 ## warnings
1736 ##
1737 
1738 ## All warning messages are preceded by the following string.
1739 compiler.warn.warning=\
1740     warning:\u0020
1741 
1742 ## Warning messages may also include the following prefix to identify a
1743 ## lint option
1744 # 0: option name
1745 compiler.warn.lintOption=\
1746     [{0}]\u0020
1747 
1748 # 0: symbol
1749 compiler.warn.constant.SVUID=\
1750     serialVersionUID must be constant in class {0}
1751 
1752 # 0: path
1753 compiler.warn.dir.path.element.not.found=\
1754     bad path element &quot;{0}&quot;: no such directory
1755 
1756 # 0: file name
1757 compiler.warn.dir.path.element.not.directory=\
1758     bad path element &quot;{0}&quot;: not a directory
1759 
1760 # 0: symbol, 1: symbol, 2: symbol
1761 compiler.warn.missing-explicit-ctor=\
1762     class {0} in exported package {1} declares no explicit constructors, thereby exposing a default constructor to clients of module {2}
1763 
1764 compiler.warn.finally.cannot.complete=\
1765     finally clause cannot complete normally
1766 
1767 # 0: name
1768 compiler.warn.poor.choice.for.module.name=\
1769     module name component {0} should avoid terminal digits
1770 
1771 # 0: string
1772 compiler.warn.incubating.modules=\
1773     using incubating module(s): {0}
1774 
1775 # 0: symbol, 1: symbol
1776 compiler.warn.has.been.deprecated=\
1777     {0} in {1} has been deprecated
1778 
1779 # 0: symbol, 1: symbol
1780 compiler.warn.has.been.deprecated.for.removal=\
1781     {0} in {1} has been deprecated and marked for removal
1782 
1783 # 0: symbol
1784 compiler.warn.is.preview=\
1785     {0} is an API that is part of a preview feature
1786 
1787 # 0: symbol
1788 compiler.err.is.preview=\
1789     {0} is an API that is part of a preview feature
1790 
1791 # 0: symbol
1792 compiler.warn.has.been.deprecated.module=\
1793     module {0} has been deprecated
1794 
1795 # 0: symbol
1796 compiler.warn.has.been.deprecated.for.removal.module=\
1797     module {0} has been deprecated and marked for removal
1798 
1799 # 0: symbol
1800 compiler.warn.sun.proprietary=\
1801     {0} is internal proprietary API and may be removed in a future release
1802 
1803 compiler.warn.illegal.char.for.encoding=\
1804     unmappable character for encoding {0}
1805 
1806 # 0: symbol
1807 compiler.warn.improper.SVUID=\
1808     serialVersionUID must be declared static final in class {0}
1809 
1810 # 0: type, 1: type
1811 compiler.warn.inexact.non-varargs.call=\
1812     non-varargs call of varargs method with inexact argument type for last parameter;\n\
1813     cast to {0} for a varargs call\n\
1814     cast to {1} for a non-varargs call and to suppress this warning
1815 
1816 # 0: list of type
1817 compiler.warn.unreachable.catch=\
1818     unreachable catch clause\n\
1819     thrown type {0} has already been caught
1820 
1821 # 0: list of type
1822 compiler.warn.unreachable.catch.1=\
1823     unreachable catch clause\n\
1824     thrown types {0} have already been caught
1825 
1826 # 0: symbol
1827 compiler.warn.long.SVUID=\
1828     serialVersionUID must be of type long in class {0}
1829 
1830 # 0: symbol
1831 compiler.warn.missing.SVUID=\
1832     serializable class {0} has no definition of serialVersionUID
1833 
1834 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
1835 compiler.warn.potentially.ambiguous.overload=\
1836     {0} in {1} is potentially ambiguous with {2} in {3}
1837 
1838 # 0: message segment
1839 compiler.warn.override.varargs.missing=\
1840     {0}; overridden method has no &#39;&#39;...&#39;&#39;
1841 
1842 # 0: message segment
1843 compiler.warn.override.varargs.extra=\
1844     {0}; overriding method is missing &#39;&#39;...&#39;&#39;
1845 
1846 # 0: message segment
1847 compiler.warn.override.bridge=\
1848     {0}; overridden method is a bridge method
1849 
1850 # 0: symbol
1851 compiler.warn.pkg-info.already.seen=\
1852     a package-info.java file has already been seen for package {0}
1853 
1854 # 0: path
1855 compiler.warn.path.element.not.found=\
1856     bad path element &quot;{0}&quot;: no such file or directory
1857 
1858 compiler.warn.possible.fall-through.into.case=\
1859     possible fall-through into case
1860 
1861 # 0: type
1862 compiler.warn.redundant.cast=\
1863     redundant cast to {0}
1864 
1865 # 0: number
1866 compiler.warn.position.overflow=\
1867     Position encoding overflows at line {0}
1868 
1869 # 0: file name, 1: number, 2: number
1870 compiler.warn.big.major.version=\
1871     {0}: major version {1} is newer than {2}, the highest major version supported by this compiler.\n\
1872     It is recommended that the compiler be upgraded.
1873 
1874 # 0: kind name, 1: symbol
1875 compiler.warn.static.not.qualified.by.type=\
1876     static {0} should be qualified by type name, {1}, instead of by an expression
1877 
1878 # 0: string
1879 compiler.warn.source.no.bootclasspath=\
1880     bootstrap class path not set in conjunction with -source {0}
1881 
1882 # 0: string
1883 compiler.warn.source.no.system.modules.path=\
1884     system modules path not set in conjunction with -source {0}
1885 
1886 # 0: string
1887 compiler.warn.option.obsolete.source=\
1888     source value {0} is obsolete and will be removed in a future release
1889 
1890 # 0: target
1891 compiler.warn.option.obsolete.target=\
1892     target value {0} is obsolete and will be removed in a future release
1893 
1894 # 0: string, 1: string
1895 compiler.err.option.removed.source=\
1896     Source option {0} is no longer supported. Use {1} or later.
1897 
1898 # 0: target, 1: target
1899 compiler.err.option.removed.target=\
1900     Target option {0} is no longer supported. Use {1} or later.
1901 
1902 
1903 # 0: target, 1: target
1904 compiler.warn.option.parameters.unsupported=\
1905     -parameters is not supported for target value {0}. Use {1} or later.
1906 
1907 compiler.warn.option.obsolete.suppression=\
1908     To suppress warnings about obsolete options, use -Xlint:-options.
1909 
1910 # 0: name, 1: number, 2: number, 3: number, 4: number
1911 compiler.warn.future.attr=\
1912     {0} attribute introduced in version {1}.{2} class files is ignored in version {3}.{4} class files
1913 
1914 compiler.warn.requires.automatic=\
1915     requires directive for an automatic module
1916 
1917 compiler.warn.requires.transitive.automatic=\
1918     requires transitive directive for an automatic module
1919 
1920 # Warnings related to annotation processing
1921 # 0: string
1922 compiler.warn.proc.package.does.not.exist=\
1923     package {0} does not exist
1924 
1925 # 0: string
1926 compiler.warn.proc.file.reopening=\
1927     Attempt to create a file for &#39;&#39;{0}&#39;&#39; multiple times
1928 
1929 # 0: string
1930 compiler.warn.proc.type.already.exists=\
1931     A file for type &#39;&#39;{0}&#39;&#39; already exists on the sourcepath or classpath
1932 
1933 # 0: string
1934 compiler.warn.proc.type.recreate=\
1935     Attempt to create a file for type &#39;&#39;{0}&#39;&#39; multiple times
1936 
1937 # 0: string
1938 compiler.warn.proc.illegal.file.name=\
1939     Cannot create file for illegal name &#39;&#39;{0}&#39;&#39;.
1940 
1941 # 0: string, 1: string
1942 compiler.warn.proc.suspicious.class.name=\
1943     Creating file for a type whose name ends in {1}: &#39;&#39;{0}&#39;&#39;
1944 
1945 # 0: string
1946 compiler.warn.proc.file.create.last.round=\
1947     File for type &#39;&#39;{0}&#39;&#39; created in the last round will not be subject to annotation processing.
1948 
1949 # 0: string, 1: string
1950 compiler.warn.proc.malformed.supported.string=\
1951     Malformed string &#39;&#39;{0}&#39;&#39; for a supported annotation type returned by processor &#39;&#39;{1}&#39;&#39;
1952 
1953 # 0: set of string
1954 compiler.warn.proc.annotations.without.processors=\
1955     No processor claimed any of these annotations: {0}
1956 
1957 # 0: source version, 1: string, 2: string
1958 compiler.warn.proc.processor.incompatible.source.version=\
1959     Supported source version &#39;&#39;{0}&#39;&#39; from annotation processor &#39;&#39;{1}&#39;&#39; less than -source &#39;&#39;{2}&#39;&#39;
1960 
1961 # 0: string, 1: string
1962 compiler.warn.proc.duplicate.option.name=\
1963     Duplicate supported option &#39;&#39;{0}&#39;&#39; returned by annotation processor &#39;&#39;{1}&#39;&#39;
1964 
1965 # 0: string, 1: string
1966 compiler.warn.proc.duplicate.supported.annotation=\
1967     Duplicate supported annotation type &#39;&#39;{0}&#39;&#39; returned by annotation processor &#39;&#39;{1}&#39;&#39;
1968 
1969 # 0: string
1970 compiler.warn.proc.redundant.types.with.wildcard=\
1971     Annotation processor &#39;&#39;{0}&#39;&#39; redundantly supports both &#39;&#39;*&#39;&#39; and other annotation types
1972 
1973 compiler.warn.proc.proc-only.requested.no.procs=\
1974     Annotation processing without compilation requested but no processors were found.
1975 
1976 compiler.warn.proc.use.implicit=\
1977     Implicitly compiled files were not subject to annotation processing.\n\
1978     Use -implicit to specify a policy for implicit compilation.
1979 
1980 compiler.warn.proc.use.proc.or.implicit=\
1981     Implicitly compiled files were not subject to annotation processing.\n\
1982     Use -proc:none to disable annotation processing or -implicit to specify a policy for implicit compilation.
1983 
1984 # Print a client-generated warning; assumed to be localized, no translation required
1985 # 0: string
1986 compiler.warn.proc.messager=\
1987     {0}
1988 
1989 # 0: set of string
1990 compiler.warn.proc.unclosed.type.files=\
1991     Unclosed files for the types &#39;&#39;{0}&#39;&#39;; these types will not undergo annotation processing
1992 
1993 # 0: string
1994 compiler.warn.proc.unmatched.processor.options=\
1995     The following options were not recognized by any processor: &#39;&#39;{0}&#39;&#39;
1996 
1997 compiler.warn.try.explicit.close.call=\
1998     explicit call to close() on an auto-closeable resource
1999 
2000 # 0: symbol
2001 compiler.warn.try.resource.not.referenced=\
2002     auto-closeable resource {0} is never referenced in body of corresponding try statement
2003 
2004 # 0: type
2005 compiler.warn.try.resource.throws.interrupted.exc=\
2006     auto-closeable resource {0} has a member method close() that could throw InterruptedException
2007 
2008 compiler.warn.unchecked.assign=\
2009     unchecked assignment: {0} to {1}
2010 
2011 # 0: symbol, 1: type
2012 compiler.warn.unchecked.assign.to.var=\
2013     unchecked assignment to variable {0} as member of raw type {1}
2014 
2015 # 0: symbol, 1: type
2016 compiler.warn.unchecked.call.mbr.of.raw.type=\
2017     unchecked call to {0} as a member of the raw type {1}
2018 
2019 compiler.warn.unchecked.cast.to.type=\
2020     unchecked cast to type {0}
2021 
2022 # 0: kind name, 1: name, 2: object, 3: object, 4: kind name, 5: symbol
2023 compiler.warn.unchecked.meth.invocation.applied=\
2024     unchecked method invocation: {0} {1} in {4} {5} is applied to given types\n\
2025     required: {2}\n\
2026     found:    {3}
2027 
2028 # 0: type
2029 compiler.warn.unchecked.generic.array.creation=\
2030     unchecked generic array creation for varargs parameter of type {0}
2031 
2032 # 0: type
2033 compiler.warn.unchecked.varargs.non.reifiable.type=\
2034     Possible heap pollution from parameterized vararg type {0}
2035 
2036 # 0: symbol
2037 compiler.warn.varargs.unsafe.use.varargs.param=\
2038     Varargs method could cause heap pollution from non-reifiable varargs parameter {0}
2039 
2040 compiler.warn.missing.deprecated.annotation=\
2041     deprecated item is not annotated with @Deprecated
2042 
2043 # 0: kind name
2044 compiler.warn.deprecated.annotation.has.no.effect=\
2045     @Deprecated annotation has no effect on this {0} declaration
2046 
2047 # 0: string
2048 compiler.warn.invalid.path=\
2049     Invalid filename: {0}
2050 
2051 # 0: string
2052 compiler.err.invalid.path=\
2053     Invalid filename: {0}
2054 
2055 
2056 # 0: path
2057 compiler.warn.invalid.archive.file=\
2058     Unexpected file on path: {0}
2059 
2060 # 0: path
2061 compiler.warn.unexpected.archive.file=\
2062     Unexpected extension for archive file: {0}
2063 
2064 # 0: path
2065 compiler.err.no.zipfs.for.archive=\
2066     No file system provider is available to handle this file: {0}
2067 
2068 compiler.warn.div.zero=\
2069     division by zero
2070 
2071 compiler.warn.empty.if=\
2072     empty statement after if
2073 
2074 # 0: type, 1: name
2075 compiler.warn.annotation.method.not.found=\
2076     Cannot find annotation method &#39;&#39;{1}()&#39;&#39; in type &#39;&#39;{0}&#39;&#39;
2077 
2078 # 0: type, 1: name, 2: message segment
2079 compiler.warn.annotation.method.not.found.reason=\
2080     Cannot find annotation method &#39;&#39;{1}()&#39;&#39; in type &#39;&#39;{0}&#39;&#39;: {2}
2081 
2082 # 0: file object, 1: symbol, 2: name
2083 compiler.warn.unknown.enum.constant=\
2084     unknown enum constant {1}.{2}
2085 
2086 # 0: file object, 1: symbol, 2: name, 3: message segment
2087 compiler.warn.unknown.enum.constant.reason=\
2088     unknown enum constant {1}.{2}\n\
2089     reason: {3}
2090 
2091 # 0: type, 1: type
2092 compiler.warn.raw.class.use=\
2093     found raw type: {0}\n\
2094     missing type arguments for generic class {1}
2095 
2096 compiler.warn.diamond.redundant.args=\
2097     Redundant type arguments in new expression (use diamond operator instead).
2098 
2099 compiler.warn.local.redundant.type=\
2100     Redundant type for local variable (replace explicit type with &#39;&#39;var&#39;&#39;).
2101 
2102 compiler.warn.potential.lambda.found=\
2103     This anonymous inner class creation can be turned into a lambda expression.
2104 
2105 compiler.warn.method.redundant.typeargs=\
2106     Redundant type arguments in method call.
2107 
2108 # 0: symbol, 1: message segment
2109 compiler.warn.varargs.redundant.trustme.anno=\
2110     Redundant {0} annotation. {1}
2111 
2112 # 0: symbol
2113 compiler.warn.access.to.member.from.serializable.element=\
2114     access to member {0} from serializable element can be publicly accessible to untrusted code
2115 
2116 # 0: symbol
2117 compiler.warn.access.to.member.from.serializable.lambda=\
2118     access to member {0} from serializable lambda can be publicly accessible to untrusted code
2119 
2120 #####
2121 
2122 ## The following are tokens which are non-terminals in the language. They should
2123 ## be named as JLS3 calls them when translated to the appropriate language.
2124 compiler.misc.token.identifier=\
2125     &lt;identifier&gt;
2126 
2127 compiler.misc.token.character=\
2128     &lt;character&gt;
2129 
2130 compiler.misc.token.string=\
2131     &lt;string&gt;
2132 
2133 compiler.misc.token.integer=\
2134     &lt;integer&gt;
2135 
2136 compiler.misc.token.long-integer=\
2137     &lt;long integer&gt;
2138 
2139 compiler.misc.token.float=\
2140     &lt;float&gt;
2141 
2142 compiler.misc.token.double=\
2143     &lt;double&gt;
2144 
2145 compiler.misc.token.bad-symbol=\
2146     &lt;bad symbol&gt;
2147 
2148 compiler.misc.token.end-of-input=\
2149     &lt;end of input&gt;
2150 
2151 ## The argument to the following string will always be one of the following:
2152 ## 1. one of the above non-terminals
2153 ## 2. a keyword (JLS1.8)
2154 ## 3. a boolean literal (JLS3.10.3)
2155 ## 4. the null literal (JLS3.10.7)
2156 ## 5. a Java separator (JLS3.11)
2157 ## 6. an operator (JLS3.12)
2158 ##
2159 ## This is the only place these tokens will be used.
2160 # 0: token
2161 compiler.err.expected=\
2162     {0} expected
2163 
2164 # 0: string
2165 compiler.err.expected.str=\
2166     {0} expected
2167 
2168 # 0: token, 1: token
2169 compiler.err.expected2=\
2170     {0} or {1} expected
2171 
2172 # 0: token, 1: token, 2: token
2173 compiler.err.expected3=\
2174     {0}, {1}, or {2} expected
2175 
2176 # 0: token, 1: token, 2: token, 3: string
2177 compiler.err.expected4=\
2178     {0}, {1}, {2}, or {3} expected
2179 
2180 compiler.err.premature.eof=\
2181     reached end of file while parsing
2182 
2183 compiler.err.enum.constant.expected=\
2184     enum constant expected here
2185 
2186 compiler.err.enum.constant.not.expected=\
2187     enum constant not expected here
2188 
2189 ## The following are related in form, but do not easily fit the above paradigm.
2190 compiler.err.expected.module=\
2191     &#39;&#39;module&#39;&#39; expected
2192 
2193 compiler.err.expected.module.or.open=\
2194     &#39;&#39;module&#39;&#39; or &#39;&#39;open&#39;&#39; expected
2195 
2196 compiler.err.dot.class.expected=\
2197     &#39;&#39;.class&#39;&#39; expected
2198 
2199 ## The argument to this string will always be either &#39;case&#39; or &#39;default&#39;.
2200 # 0: token
2201 compiler.err.orphaned=\
2202     orphaned {0}
2203 
2204 # 0: name
2205 compiler.misc.anonymous.class=\
2206     &lt;anonymous {0}&gt;
2207 
2208 # 0: name, 1: type
2209 compiler.misc.type.captureof=\
2210     capture#{0} of {1}
2211 
2212 compiler.misc.type.captureof.1=\
2213     capture#{0}
2214 
2215 compiler.misc.type.none=\
2216     &lt;none&gt;
2217 
2218 compiler.misc.unnamed.package=\
2219     unnamed package
2220 
2221 compiler.misc.unnamed.module=\
2222     unnamed module
2223 
2224 #####
2225 
2226 # 0: symbol, 1: message segment
2227 compiler.err.cant.access=\
2228     cannot access {0}\n\
2229     {1}
2230 
2231 # 0: name
2232 compiler.misc.bad.class.file=\
2233     class file is invalid for class {0}
2234 
2235 # 0: file name, 1: string (expected constant pool entry type), 2: number (constant pool index)
2236 compiler.misc.bad.const.pool.entry=\
2237     bad constant pool entry in {0}\n\
2238     expected {1} at index {2}
2239 
2240 # 0: file name, 1: number (constant pool index), 2: number (constant pool size)
2241 compiler.misc.bad.const.pool.index=\
2242     bad constant pool index in {0}\n\
2243     index {1} is not within pool size {2}.
2244 
2245 # 0: file name, 1: message segment
2246 compiler.misc.bad.class.file.header=\
2247     bad class file: {0}\n\
2248     {1}\n\
2249     Please remove or make sure it appears in the correct subdirectory of the classpath.
2250 
2251 # 0: file name, 1: message segment
2252 compiler.misc.bad.source.file.header=\
2253     bad source file: {0}\n\
2254     {1}\n\
2255     Please remove or make sure it appears in the correct subdirectory of the sourcepath.
2256 
2257 ## The following are all possible strings for the second argument ({1}) of the
2258 ## above strings.
2259 compiler.misc.bad.class.signature=\
2260     bad class signature: {0}
2261 
2262 #0: symbol, 1: symbol
2263 compiler.misc.bad.enclosing.class=\
2264     bad enclosing class for {0}: {1}
2265 
2266 # 0: symbol
2267 compiler.misc.bad.enclosing.method=\
2268     bad enclosing method attribute for class {0}
2269 
2270 compiler.misc.bad.runtime.invisible.param.annotations=\
2271     bad RuntimeInvisibleParameterAnnotations attribute: {0}
2272 
2273 compiler.misc.bad.const.pool.tag=\
2274     bad constant pool tag: {0}
2275 
2276 compiler.misc.bad.const.pool.tag.at=\
2277     bad constant pool tag: {0} at {1}
2278 
2279 compiler.misc.unexpected.const.pool.tag.at=\
2280     unexpected constant pool tag: {0} at {1}
2281 
2282 compiler.misc.bad.signature=\
2283     bad signature: {0}
2284 
2285 compiler.misc.bad.type.annotation.value=\
2286     bad type annotation target type value: {0}
2287 
2288 compiler.misc.bad.module-info.name=\
2289     bad class name
2290 
2291 compiler.misc.class.file.wrong.class=\
2292     class file contains wrong class: {0}
2293 
2294 compiler.misc.module.info.invalid.super.class=\
2295     module-info with invalid super class
2296 
2297 # 0: name
2298 compiler.misc.class.file.not.found=\
2299     class file for {0} not found
2300 
2301 # 0: string (constant value), 1: symbol (constant field), 2: type (field type)
2302 compiler.misc.bad.constant.range=\
2303     constant value &#39;&#39;{0}&#39;&#39; for {1} is outside the expected range for {2}
2304 
2305 # 0: string (constant value), 1: symbol (constant field), 2: string (expected class)
2306 compiler.misc.bad.constant.value=\
2307     bad constant value &#39;&#39;{0}&#39;&#39; for {1}, expected {2}
2308 
2309 # 0: type (field type)
2310 compiler.misc.bad.constant.value.type=\
2311     variable of type &#39;&#39;{0}&#39;&#39; cannot have a constant value, but has one specified
2312 
2313 # 0: string (classfile major version), 1: string (classfile minor version)
2314 compiler.misc.invalid.default.interface=\
2315     default method found in version {0}.{1} classfile
2316 
2317 # 0: string (classfile major version), 1: string (classfile minor version)
2318 compiler.misc.invalid.static.interface=\
2319     static method found in version {0}.{1} classfile
2320 
2321 # 0: string (classfile major version), 1: string (classfile minor version)
2322 compiler.misc.anachronistic.module.info=\
2323     module declaration found in version {0}.{1} classfile
2324 
2325 compiler.misc.module.info.definition.expected=\
2326     module-info definition expected
2327 
2328 # 0: name
2329 compiler.misc.file.doesnt.contain.class=\
2330     file does not contain class {0}
2331 
2332 # 0: symbol
2333 compiler.misc.file.does.not.contain.package=\
2334     file does not contain package {0}
2335 
2336 compiler.misc.file.does.not.contain.module=\
2337     file does not contain module declaration
2338 
2339 compiler.misc.illegal.start.of.class.file=\
2340     illegal start of class file
2341 
2342 # 0: name
2343 compiler.misc.method.descriptor.invalid=\
2344     method descriptor invalid for {0}
2345 
2346 compiler.misc.unable.to.access.file=\
2347     unable to access file: {0}
2348 
2349 compiler.misc.unicode.str.not.supported=\
2350     unicode string in class file not supported
2351 
2352 compiler.misc.undecl.type.var=\
2353     undeclared type variable: {0}
2354 
2355 compiler.misc.malformed.vararg.method=\
2356     class file contains malformed variable arity method: {0}
2357 
2358 compiler.misc.wrong.version=\
2359     class file has wrong version {0}.{1}, should be {2}.{3}
2360 
2361 #####
2362 
2363 # 0: type, 1: type or symbol
2364 compiler.err.not.within.bounds=\
2365     type argument {0} is not within bounds of type-variable {1}
2366 
2367 ## The following are all possible strings for the second argument ({1}) of the
2368 ## above string.
2369 
2370 ## none yet...
2371 
2372 #####
2373 
2374 # 0: message segment
2375 compiler.err.prob.found.req=\
2376     incompatible types: {0}
2377 
2378 # 0: message segment
2379 compiler.misc.prob.found.req=\
2380     incompatible types: {0}
2381 
2382 # 0: message segment, 1: type, 2: type
2383 compiler.warn.prob.found.req=\
2384     {0}\n\
2385     required: {2}\n\
2386     found:    {1}
2387 
2388 # 0: type, 1: type
2389 compiler.misc.inconvertible.types=\
2390     {0} cannot be converted to {1}
2391 
2392 # 0: type, 1: type
2393 compiler.misc.possible.loss.of.precision=\
2394     possible lossy conversion from {0} to {1}
2395 
2396 compiler.misc.unchecked.assign=\
2397     unchecked conversion
2398 
2399 # compiler.misc.storecheck=\
2400 #     assignment might cause later store checks to fail
2401 # compiler.misc.unchecked=\
2402 #     assigned array cannot dynamically check its stores
2403 compiler.misc.unchecked.cast.to.type=\
2404     unchecked cast
2405 
2406 # compiler.err.star.expected=\
2407 #     &#39;&#39;*&#39;&#39; expected
2408 # compiler.err.no.elem.type=\
2409 #     \[\*\] cannot have a type
2410 
2411 # 0: message segment
2412 compiler.misc.try.not.applicable.to.type=\
2413     try-with-resources not applicable to variable type\n\
2414     ({0})
2415 
2416 #####
2417 
2418 # 0: object, 1: message segment
2419 compiler.err.type.found.req=\
2420     unexpected type\n\
2421     required: {1}\n\
2422     found:    {0}
2423 
2424 ## The following are all possible strings for the first argument ({0}) of the
2425 ## above string.
2426 compiler.misc.type.req.class=\
2427     class
2428 
2429 compiler.misc.type.req.class.array=\
2430     class or array
2431 
2432 compiler.misc.type.req.array.or.iterable=\
2433     array or java.lang.Iterable
2434 
2435 compiler.misc.type.req.ref=\
2436     reference
2437 
2438 compiler.misc.type.req.exact=\
2439     class or interface without bounds
2440 
2441 # 0: type
2442 compiler.misc.type.parameter=\
2443     type parameter {0}
2444 
2445 #####
2446 
2447 ## The following are all possible strings for the last argument of all those
2448 ## diagnostics whose key ends in &quot;.1&quot;
2449 
2450 # 0: type, 1: list of type
2451 compiler.misc.no.unique.maximal.instance.exists=\
2452     no unique maximal instance exists for type variable {0} with upper bounds {1}
2453 
2454 # 0: type, 1: list of type
2455 compiler.misc.no.unique.minimal.instance.exists=\
2456     no unique minimal instance exists for type variable {0} with lower bounds {1}
2457 
2458 # 0: type, 1: list of type
2459 compiler.misc.incompatible.upper.bounds=\
2460     inference variable {0} has incompatible upper bounds {1}
2461 
2462 # 0: type, 1: list of type
2463 compiler.misc.incompatible.eq.bounds=\
2464     inference variable {0} has incompatible equality constraints {1}
2465 
2466 # 0: type, 1: fragment, 2: fragment
2467 compiler.misc.incompatible.bounds=\
2468     inference variable {0} has incompatible bounds\n\
2469     {1}\n\
2470     {2}
2471 
2472 # 0: list of type
2473 compiler.misc.lower.bounds=\
2474         lower bounds: {0}
2475 
2476 # 0: list of type
2477 compiler.misc.eq.bounds=\
2478         equality constraints: {0}
2479 
2480 # 0: list of type
2481 compiler.misc.upper.bounds=\
2482         lower bounds: {0}
2483 
2484 # 0: list of type, 1: type, 2: type
2485 compiler.misc.infer.no.conforming.instance.exists=\
2486     no instance(s) of type variable(s) {0} exist so that {1} conforms to {2}
2487 
2488 # 0: list of type, 1: message segment
2489 compiler.misc.infer.no.conforming.assignment.exists=\
2490     cannot infer type-variable(s) {0}\n\
2491     (argument mismatch; {1})
2492 
2493 # 0: list of type
2494 compiler.misc.infer.arg.length.mismatch=\
2495     cannot infer type-variable(s) {0}\n\
2496     (actual and formal argument lists differ in length)
2497 
2498 # 0: list of type, 1: message segment
2499 compiler.misc.infer.varargs.argument.mismatch=\
2500     cannot infer type-variable(s) {0}\n\
2501     (varargs mismatch; {1})
2502 
2503 # 0: type, 1: list of type
2504 compiler.misc.inferred.do.not.conform.to.upper.bounds=\
2505     inferred type does not conform to upper bound(s)\n\
2506     inferred: {0}\n\
2507     upper bound(s): {1}
2508 
2509 # 0: type, 1: list of type
2510 compiler.misc.inferred.do.not.conform.to.lower.bounds=\
2511     inferred type does not conform to lower bound(s)\n\
2512     inferred: {0}\n\
2513     lower bound(s): {1}
2514 
2515 # 0: type, 1: list of type
2516 compiler.misc.inferred.do.not.conform.to.eq.bounds=\
2517     inferred type does not conform to equality constraint(s)\n\
2518     inferred: {0}\n\
2519     equality constraints(s): {1}
2520 
2521 # 0: symbol
2522 compiler.misc.diamond=\
2523     {0}&lt;&gt;
2524 
2525 # 0: type
2526 compiler.misc.diamond.non.generic=\
2527     cannot use &#39;&#39;&lt;&gt;&#39;&#39; with non-generic class {0}
2528 
2529 # 0: list of type, 1: message segment
2530 compiler.misc.diamond.invalid.arg=\
2531     type argument {0} inferred for {1} is not allowed in this context\n\
2532     inferred argument is not expressible in the Signature attribute
2533 
2534 # 0: list of type, 1: message segment
2535 compiler.misc.diamond.invalid.args=\
2536     type arguments {0} inferred for {1} are not allowed in this context\n\
2537     inferred arguments are not expressible in the Signature attribute
2538 
2539 # 0: type
2540 compiler.misc.diamond.and.explicit.params=\
2541     cannot use &#39;&#39;&lt;&gt;&#39;&#39; with explicit type parameters for constructor
2542 
2543 compiler.misc.mref.infer.and.explicit.params=\
2544     cannot use raw constructor reference with explicit type parameters for constructor
2545 
2546 # 0: type, 1: list of type
2547 compiler.misc.explicit.param.do.not.conform.to.bounds=\
2548     explicit type argument {0} does not conform to declared bound(s) {1}
2549 
2550 compiler.misc.arg.length.mismatch=\
2551     actual and formal argument lists differ in length
2552 
2553 # 0: string
2554 compiler.misc.wrong.number.type.args=\
2555     wrong number of type arguments; required {0}
2556 
2557 # 0: message segment
2558 compiler.misc.no.conforming.assignment.exists=\
2559     argument mismatch; {0}
2560 
2561 # 0: message segment
2562 compiler.misc.varargs.argument.mismatch=\
2563     varargs mismatch; {0}
2564 
2565 #####
2566 
2567 # 0: symbol or type, 1: file name
2568 compiler.warn.auxiliary.class.accessed.from.outside.of.its.source.file=\
2569     auxiliary class {0} in {1} should not be accessed from outside its own source file
2570 
2571 ## The first argument ({0}) is a &quot;kindname&quot;.
2572 # 0: kind name, 1: symbol, 2: symbol
2573 compiler.err.abstract.cant.be.accessed.directly=\
2574     abstract {0} {1} in {2} cannot be accessed directly
2575 
2576 ## The first argument ({0}) is a &quot;kindname&quot;.
2577 # 0: symbol kind, 1: symbol
2578 compiler.err.non-static.cant.be.ref=\
2579     non-static {0} {1} cannot be referenced from a static context
2580 
2581 # 0: symbol kind, 1: symbol
2582 compiler.misc.bad.static.method.in.unbound.lookup=\
2583     unexpected static {0} {1} found in unbound lookup
2584 
2585 # 0: symbol kind, 1: symbol
2586 compiler.misc.bad.instance.method.in.unbound.lookup=\
2587     unexpected instance {0} {1} found in unbound lookup
2588 
2589 # 0: symbol kind, 1: symbol
2590 compiler.misc.bad.static.method.in.bound.lookup=\
2591     unexpected static {0} {1} found in bound lookup
2592 
2593 ## Both arguments ({0}, {1}) are &quot;kindname&quot;s.  {0} is a comma-separated list
2594 ## of kindnames (the list should be identical to that provided in source.
2595 # 0: set of kind name, 1: set of kind name
2596 compiler.err.unexpected.type=\
2597     unexpected type\n\
2598     required: {0}\n\
2599     found:    {1}
2600 
2601 compiler.err.unexpected.lambda=\
2602    lambda expression not expected here
2603 
2604 compiler.err.unexpected.mref=\
2605    method reference not expected here
2606 
2607 ## The first argument {0} is a &quot;kindname&quot; (e.g. &#39;constructor&#39;, &#39;field&#39;, etc.)
2608 ## The second argument {1} is the non-resolved symbol
2609 ## The third argument {2} is a list of type parameters (non-empty if {1} is a method)
2610 ## The fourth argument {3} is a list of argument types (non-empty if {1} is a method)
2611 # 0: kind name, 1: name, 2: unused, 3: unused
2612 compiler.err.cant.resolve=\
2613     cannot find symbol\n\
2614     symbol: {0} {1}
2615 
2616 # 0: kind name, 1: name, 2: unused, 3: list of type
2617 compiler.err.cant.resolve.args=\
2618     cannot find symbol\n\
2619     symbol: {0} {1}({3})
2620 
2621 # 0: kind name, 1: name, 2: unused, 3: list of type
2622 compiler.misc.cant.resolve.args=\
2623     cannot find symbol\n\
2624     symbol: {0} {1}({3})
2625 
2626 # 0: kind name, 1: name, 2: list of type, 3: list of type
2627 compiler.err.cant.resolve.args.params=\
2628     cannot find symbol\n\
2629     symbol: {0} &lt;{2}&gt;{1}({3})
2630 
2631 ## arguments from {0} to {3} have the same meaning as above
2632 ## The fifth argument {4} is a location subdiagnostic (see below)
2633 # 0: kind name, 1: name, 2: unused, 3: unused, 4: message segment
2634 compiler.err.cant.resolve.location=\
2635     cannot find symbol\n\
2636     symbol:   {0} {1}\n\
2637     location: {4}
2638 
2639 # 0: kind name, 1: name, 2: unused, 3: list of type, 4: message segment
2640 compiler.err.cant.resolve.location.args=\
2641     cannot find symbol\n\
2642     symbol:   {0} {1}({3})\n\
2643     location: {4}
2644 
2645 # 0: kind name, 1: name, 2: list of type, 3: list, 4: message segment
2646 compiler.err.cant.resolve.location.args.params=\
2647     cannot find symbol\n\
2648     symbol:   {0} &lt;{2}&gt;{1}({3})\n\
2649     location: {4}
2650 
2651 ### Following are replicated/used for method reference diagnostics
2652 
2653 # 0: kind name, 1: name, 2: unused, 3: list of type, 4: message segment
2654 compiler.misc.cant.resolve.location.args=\
2655     cannot find symbol\n\
2656     symbol:   {0} {1}({3})\n\
2657     location: {4}
2658 
2659 # 0: kind name, 1: name, 2: list of type, 3: list, 4: message segment
2660 compiler.misc.cant.resolve.location.args.params=\
2661     cannot find symbol\n\
2662     symbol:   {0} &lt;{2}&gt;{1}({3})\n\
2663     location: {4}
2664 
2665 ##a location subdiagnostic is composed as follows:
2666 ## The first argument {0} is the location &quot;kindname&quot; (e.g. &#39;constructor&#39;, &#39;field&#39;, etc.)
2667 ## The second argument {1} is the location name
2668 ## The third argument {2} is the location type (only when {1} is a variable name)
2669 
2670 # 0: kind name, 1: type or symbol, 2: unused
2671 compiler.misc.location=\
2672     {0} {1}
2673 
2674 # 0: kind name, 1: symbol, 2: type
2675 compiler.misc.location.1=\
2676     {0} {1} of type {2}
2677 
2678 ## The following are all possible string for &quot;kindname&quot;.
2679 ## They should be called whatever the JLS calls them after it been translated
2680 ## to the appropriate language.
2681 # compiler.misc.kindname.constructor=\
2682 #     static member
2683 compiler.misc.kindname.annotation=\
2684     @interface
2685 
2686 compiler.misc.kindname.constructor=\
2687     constructor
2688 
2689 compiler.misc.kindname.enum=\
2690     enum
2691 
2692 compiler.misc.kindname.interface=\
2693     interface
2694 
2695 compiler.misc.kindname.static=\
2696     static
2697 
2698 compiler.misc.kindname.type.variable=\
2699     type variable
2700 
2701 compiler.misc.kindname.type.variable.bound=\
2702     bound of type variable
2703 
2704 compiler.misc.kindname.variable=\
2705     variable
2706 
2707 compiler.misc.kindname.value=\
2708     value
2709 
2710 compiler.misc.kindname.method=\
2711     method
2712 
2713 compiler.misc.kindname.class=\
2714     class
2715 
2716 compiler.misc.kindname.package=\
2717     package
2718 
2719 compiler.misc.kindname.module=\
2720     module
2721 
2722 compiler.misc.kindname.static.init=\
2723     static initializer
2724 
2725 compiler.misc.kindname.instance.init=\
2726     instance initializer
2727 
2728 compiler.misc.kindname.record.component=\
2729     record component
2730 
2731 compiler.misc.kindname.record=\
2732     record
2733 
2734 #####
2735 
2736 compiler.misc.no.args=\
2737     no arguments
2738 
2739 # 0: message segment
2740 compiler.err.override.static=\
2741     {0}\n\
2742     overriding method is static
2743 
2744 # 0: message segment, 1: set of flag
2745 compiler.err.override.meth=\
2746     {0}\n\
2747     overridden method is {1}
2748 
2749 # 0: message segment, 1: type
2750 compiler.err.override.meth.doesnt.throw=\
2751     {0}\n\
2752     overridden method does not throw {1}
2753 
2754 # In the following string {1} is a space separated list of Java Keywords, as
2755 # they would have been declared in the source code
2756 # 0: message segment, 1: set of flag or string
2757 compiler.err.override.weaker.access=\
2758     {0}\n\
2759     attempting to assign weaker access privileges; was {1}
2760 
2761 # 0: message segment, 1: type, 2: type
2762 compiler.err.override.incompatible.ret=\
2763     {0}\n\
2764     return type {1} is not compatible with {2}
2765 
2766 # 0: message segment, 1: type, 2: type
2767 compiler.warn.override.unchecked.ret=\
2768     {0}\n\
2769     return type requires unchecked conversion from {1} to {2}
2770 
2771 # 0: message segment, 1: type
2772 compiler.warn.override.unchecked.thrown=\
2773     {0}\n\
2774     overridden method does not throw {1}
2775 
2776 # 0: symbol
2777 compiler.warn.override.equals.but.not.hashcode=\
2778     Class {0} overrides equals, but neither it nor any superclass overrides hashCode method
2779 
2780 ## The following are all possible strings for the first argument ({0}) of the
2781 ## above strings.
2782 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2783 compiler.misc.cant.override=\
2784     {0} in {1} cannot override {2} in {3}
2785 
2786 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2787 compiler.misc.cant.hide=\
2788     {0} in {1} cannot hide {2} in {3}
2789 
2790 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2791 compiler.misc.cant.implement=\
2792     {0} in {1} cannot implement {2} in {3}
2793 
2794 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2795 compiler.misc.clashes.with=\
2796     {0} in {1} clashes with {2} in {3}
2797 
2798 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2799 compiler.misc.unchecked.override=\
2800     {0} in {1} overrides {2} in {3}
2801 
2802 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2803 compiler.misc.unchecked.implement=\
2804     {0} in {1} implements {2} in {3}
2805 
2806 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2807 compiler.misc.unchecked.clash.with=\
2808     {0} in {1} overrides {2} in {3}
2809 
2810 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2811 compiler.misc.varargs.override=\
2812     {0} in {1} overrides {2} in {3}
2813 
2814 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2815 compiler.misc.varargs.implement=\
2816     {0} in {1} implements {2} in {3}
2817 
2818 # 0: symbol, 1: symbol, 2: symbol, 3: symbol
2819 compiler.misc.varargs.clash.with=\
2820     {0} in {1} overrides {2} in {3}
2821 
2822 # 0: kind name, 1: symbol, 2: symbol, 3: message segment
2823 compiler.misc.inapplicable.method=\
2824     {0} {1}.{2} is not applicable\n\
2825     ({3})
2826 
2827 ########################################
2828 # Diagnostics for language feature changes.
2829 # Such diagnostics have a common template which can be customized by using a feature
2830 # diagnostic fragment (one of those given below).
2831 ########################################
2832 
2833 # 0: message segment (feature), 1: string (found version), 2: string (expected version)
2834 compiler.err.feature.not.supported.in.source=\
2835    {0} is not supported in -source {1}\n\
2836     (use -source {2} or higher to enable {0})
2837 
2838 # 0: message segment (feature), 1: string (found version), 2: string (expected version)
2839 compiler.err.feature.not.supported.in.source.plural=\
2840    {0} are not supported in -source {1}\n\
2841     (use -source {2} or higher to enable {0})
2842 
2843 # 0: message segment (feature), 1: string (found version), 2: string (expected version)
2844 compiler.misc.feature.not.supported.in.source=\
2845    {0} is not supported in -source {1}\n\
2846     (use -source {2} or higher to enable {0})
2847 
2848 # 0: message segment (feature), 1: string (found version), 2: string (expected version)
2849 compiler.misc.feature.not.supported.in.source.plural=\
2850    {0} are not supported in -source {1}\n\
2851     (use -source {2} or higher to enable {0})
2852 
2853 # 0: message segment (feature)
2854 compiler.err.preview.feature.disabled=\
2855    {0} is a preview feature and is disabled by default.\n\
2856    (use --enable-preview to enable {0})
2857 
2858 # 0: message segment (feature)
2859 compiler.err.preview.feature.disabled.plural=\
2860    {0} are a preview feature and are disabled by default.\n\
2861    (use --enable-preview to enable {0})
2862 
2863 # 0: file object (classfile), 1: string (expected version)
2864 compiler.err.preview.feature.disabled.classfile=\
2865    classfile for {0} uses preview features of Java SE {1}.\n\
2866    (use --enable-preview to allow loading of classfiles which contain preview features)
2867 
2868 # 0: message segment (feature)
2869 compiler.warn.preview.feature.use=\
2870    {0} is a preview feature and may be removed in a future release.
2871 
2872 # 0: message segment (feature)
2873 compiler.warn.preview.feature.use.plural=\
2874    {0} are a preview feature and may be removed in a future release.
2875 
2876 # 0: file object (classfile), 1: string (expected version)
2877 compiler.warn.preview.feature.use.classfile=\
2878    classfile for {0} uses preview features of Java SE {1}.
2879 
2880 
2881 compiler.misc.feature.modules=\
2882     modules
2883 
2884 compiler.misc.feature.diamond.and.anon.class=\
2885     &#39;&#39;&lt;&gt;&#39;&#39; with anonymous inner classes
2886 
2887 compiler.misc.feature.var.in.try.with.resources=\
2888     variables in try-with-resources
2889 
2890 compiler.misc.feature.type.annotations=\
2891     type annotations
2892 
2893 compiler.misc.feature.annotations.after.type.params=\
2894     annotations after method type parameters
2895 
2896 compiler.misc.feature.repeatable.annotations=\
2897     repeated annotations
2898 
2899 compiler.misc.feature.diamond=\
2900     diamond operator
2901 
2902 compiler.misc.feature.lambda=\
2903     lambda expressions
2904 
2905 compiler.misc.feature.method.references=\
2906     method references
2907 
2908 compiler.misc.feature.default.methods=\
2909     default methods
2910 
2911 compiler.misc.feature.intersection.types.in.cast=\
2912     intersection types
2913 
2914 compiler.misc.feature.static.intf.methods=\
2915     static interface methods
2916 
2917 compiler.misc.feature.static.intf.method.invoke=\
2918     static interface method invocations
2919 
2920 compiler.misc.feature.private.intf.methods=\
2921     private interface methods
2922 
2923 compiler.misc.feature.text.blocks=\
2924     text blocks
2925 
2926 compiler.misc.feature.multiple.case.labels=\
2927     multiple case labels
2928 
2929 compiler.misc.feature.switch.rules=\
2930     switch rules
2931 
2932 compiler.misc.feature.switch.expressions=\
2933     switch expressions
2934 
2935 compiler.misc.feature.var.syntax.in.implicit.lambda=\
2936     var syntax in implicit lambdas
2937 
2938 compiler.misc.feature.pattern.matching.instanceof=\
2939     pattern matching in instanceof
2940 
2941 compiler.misc.feature.reifiable.types.instanceof=\
2942     reifiable types in instanceof
2943 
2944 compiler.misc.feature.records=\
2945     records
2946 
2947 compiler.misc.feature.sealed.classes=\
2948     sealed classes
2949 
2950 compiler.warn.underscore.as.identifier=\
2951     as of release 9, &#39;&#39;_&#39;&#39; is a keyword, and may not be used as an identifier
2952 
2953 compiler.err.underscore.as.identifier=\
2954     as of release 9, &#39;&#39;_&#39;&#39; is a keyword, and may not be used as an identifier
2955 
2956 compiler.err.underscore.as.identifier.in.lambda=\
2957     &#39;&#39;_&#39;&#39; used as an identifier\n\
2958     (use of &#39;&#39;_&#39;&#39; as an identifier is forbidden for lambda parameters)
2959 
2960 compiler.err.enum.as.identifier=\
2961     as of release 5, &#39;&#39;enum&#39;&#39; is a keyword, and may not be used as an identifier
2962 
2963 compiler.err.assert.as.identifier=\
2964     as of release 1.4, &#39;&#39;assert&#39;&#39; is a keyword, and may not be used as an identifier
2965 
2966 # TODO 308: make a better error message
2967 compiler.err.this.as.identifier=\
2968     as of release 8, &#39;&#39;this&#39;&#39; is allowed as the parameter name for the receiver type only\n\
2969     which has to be the first parameter, and cannot be a lambda parameter
2970 
2971 compiler.err.receiver.parameter.not.applicable.constructor.toplevel.class=\
2972     receiver parameter not applicable for constructor of top-level class
2973 
2974 # TODO 308: make a better error message
2975 # 0: annotation
2976 compiler.err.cant.type.annotate.scoping.1=\
2977     scoping construct cannot be annotated with type-use annotation: {0}
2978 
2979 # TODO 308: make a better error message
2980 # 0: list of annotation
2981 compiler.err.cant.type.annotate.scoping=\
2982     scoping construct cannot be annotated with type-use annotations: {0}
2983 
2984 # 0: type, 1: type
2985 compiler.err.incorrect.receiver.name=\
2986     the receiver name does not match the enclosing class type\n\
2987     required: {0}\n\
2988     found:    {1}
2989 
2990 # 0: type, 1: type
2991 compiler.err.incorrect.receiver.type=\
2992     the receiver type does not match the enclosing class type\n\
2993     required: {0}\n\
2994     found:    {1}
2995 
2996 # 0: type, 1: type
2997 compiler.err.incorrect.constructor.receiver.type=\
2998     the receiver type does not match the enclosing outer class type\n\
2999     required: {0}\n\
3000     found:    {1}
3001 
3002 # 0: type, 1: type
3003 compiler.err.incorrect.constructor.receiver.name=\
3004     the receiver name does not match the enclosing outer class type\n\
3005     required: {0}\n\
3006     found:    {1}
3007 
3008 compiler.err.no.annotations.on.dot.class=\
3009     no annotations are allowed in the type of a class literal
3010 
3011 ########################################
3012 # Diagnostics for verbose resolution
3013 # used by Resolve (debug only)
3014 ########################################
3015 
3016 # 0: number, 1: symbol, 2: unused
3017 compiler.misc.applicable.method.found=\
3018     #{0} applicable method found: {1}
3019 
3020 # 0: number, 1: symbol, 2: message segment
3021 compiler.misc.applicable.method.found.1=\
3022     #{0} applicable method found: {1}\n\
3023     ({2})
3024 
3025 # 0: number, 1: symbol, 2: message segment
3026 compiler.misc.not.applicable.method.found=\
3027     #{0} not applicable method found: {1}\n\
3028     ({2})
3029 
3030 # 0: type
3031 compiler.misc.partial.inst.sig=\
3032     partially instantiated to: {0}
3033 
3034 # 0: name, 1: symbol, 2: number, 3: string (method resolution phase), 4: list of type or message segment, 5: list of type or message segment
3035 compiler.note.verbose.resolve.multi=\
3036     resolving method {0} in type {1} to candidate {2}\n\
3037     phase: {3}\n\
3038     with actuals: {4}\n\
3039     with type-args: {5}\n\
3040     candidates:
3041 
3042 # 0: name, 1: symbol, 2: unused, 3: string (method resolution phase), 4: list of type or message segment, 5: list of type or message segment
3043 compiler.note.verbose.resolve.multi.1=\
3044     erroneous resolution for method {0} in type {1}\n\
3045     phase: {3}\n\
3046     with actuals: {4}\n\
3047     with type-args: {5}\n\
3048     candidates:
3049 
3050 # 0: symbol, 1: type, 2: type
3051 compiler.note.deferred.method.inst=\
3052     Deferred instantiation of method {0}\n\
3053     instantiated signature: {1}\n\
3054     target-type: {2}
3055 
3056 ########################################
3057 # Diagnostics for lambda deduplication
3058 # used by LambdaToMethod (debug only)
3059 ########################################
3060 
3061 # 0: symbol
3062 compiler.note.verbose.l2m.deduplicate=\
3063     deduplicating lambda implementation method {0}
3064 
3065 ########################################
3066 # Diagnostics for where clause implementation
3067 # used by the RichDiagnosticFormatter.
3068 ########################################
3069 
3070 compiler.misc.type.null=\
3071     &lt;null&gt;
3072 
3073 # X#n (where n is an int id) is disambiguated tvar name
3074 # 0: name, 1: number
3075 compiler.misc.type.var=\
3076     {0}#{1}
3077 
3078 # CAP#n (where n is an int id) is an abbreviation for &#39;captured type&#39;
3079 # 0: number
3080 compiler.misc.captured.type=\
3081     CAP#{0}
3082 
3083 # &lt;INT#n&gt; (where n is an int id) is an abbreviation for &#39;intersection type&#39;
3084 # 0: number
3085 compiler.misc.intersection.type=\
3086     INT#{0}
3087 
3088 # where clause for captured type: contains upper (&#39;extends {1}&#39;) and lower
3089 # (&#39;super {2}&#39;) bound along with the wildcard that generated this captured type ({3})
3090 # 0: type, 1: type, 2: type, 3: type
3091 compiler.misc.where.captured=\
3092     {0} extends {1} super: {2} from capture of {3}
3093 
3094 # compact where clause for captured type: contains upper (&#39;extends {1}&#39;) along
3095 # with the wildcard that generated this captured type ({3})
3096 # 0: type, 1: type, 2: unused, 3: type
3097 compiler.misc.where.captured.1=\
3098     {0} extends {1} from capture of {3}
3099 
3100 # where clause for type variable: contains upper bound(s) (&#39;extends {1}&#39;) along with
3101 # the kindname ({2}) and location ({3}) in which the typevar has been declared
3102 # 0: type, 1: list of type, 2: symbol kind, 3: symbol
3103 compiler.misc.where.typevar=\
3104     {0} extends {1} declared in {2} {3}
3105 
3106 # compact where clause for type variable: contains the kindname ({2}) and location ({3})
3107 # in which the typevar has been declared
3108 # 0: type, 1: list of type, 2: symbol kind, 3: symbol
3109 compiler.misc.where.typevar.1=\
3110     {0} declared in {2} {3}
3111 
3112 # where clause for fresh type variable: contains upper bound(s) (&#39;extends {1}&#39;).
3113 # Since a fresh type-variable is synthetic - there&#39;s no location/kindname here.
3114 # 0: type, 1: list of type
3115 compiler.misc.where.fresh.typevar=\
3116     {0} extends {1}
3117 
3118 # where clause for type variable: contains all the upper bound(s) (&#39;extends {1}&#39;)
3119 # of this intersection type
3120 # 0: type, 1: list of type
3121 compiler.misc.where.intersection=\
3122     {0} extends {1}
3123 
3124 ### Where clause headers ###
3125 compiler.misc.where.description.captured=\
3126     where {0} is a fresh type-variable:
3127 
3128 # 0: set of type
3129 compiler.misc.where.description.typevar=\
3130     where {0} is a type-variable:
3131 
3132 # 0: set of type
3133 compiler.misc.where.description.intersection=\
3134     where {0} is an intersection type:
3135 
3136 # 0: set of type
3137 compiler.misc.where.description.captured.1=\
3138     where {0} are fresh type-variables:
3139 
3140 # 0: set of type
3141 compiler.misc.where.description.typevar.1=\
3142     where {0} are type-variables:
3143 
3144 # 0: set of type
3145 compiler.misc.where.description.intersection.1=\
3146     where {0} are intersection types:
3147 
3148 ###
3149 # errors related to doc comments
3150 
3151 compiler.err.dc.bad.entity=\
3152     bad HTML entity
3153 
3154 compiler.err.dc.bad.inline.tag=\
3155     incorrect use of inline tag
3156 
3157 compiler.err.dc.identifier.expected=\
3158     identifier expected
3159 
3160 compiler.err.dc.malformed.html=\
3161     malformed HTML
3162 
3163 compiler.err.dc.missing.semicolon=\
3164     semicolon missing
3165 
3166 compiler.err.dc.no.content=\
3167     no content
3168 
3169 compiler.err.dc.no.tag.name=\
3170     no tag name after &#39;@&#39;
3171 
3172 compiler.err.dc.gt.expected=\
3173     &#39;&#39;&gt;&#39;&#39; expected
3174 
3175 compiler.err.dc.ref.bad.parens=\
3176     &#39;&#39;)&#39;&#39; missing in reference
3177 
3178 compiler.err.dc.ref.syntax.error=\
3179     syntax error in reference
3180 
3181 compiler.err.dc.ref.unexpected.input=\
3182     unexpected text
3183 
3184 compiler.err.dc.unexpected.content=\
3185     unexpected content
3186 
3187 compiler.err.dc.unterminated.inline.tag=\
3188     unterminated inline tag
3189 
3190 compiler.err.dc.unterminated.signature=\
3191     unterminated signature
3192 
3193 compiler.err.dc.unterminated.string=\
3194     unterminated string
3195 
3196 ###
3197 # errors related to modules
3198 
3199 compiler.err.expected.module=\
3200     expected &#39;&#39;module&#39;&#39;
3201 
3202 # 0: symbol
3203 compiler.err.module.not.found=\
3204     module not found: {0}
3205 
3206 # 0: symbol
3207 compiler.warn.module.not.found=\
3208     module not found: {0}
3209 
3210 compiler.err.too.many.modules=\
3211     too many module declarations found
3212 
3213 compiler.err.module.not.found.on.module.source.path=\
3214     module not found on module source path
3215 
3216 compiler.err.not.in.module.on.module.source.path=\
3217     not in a module on the module source path
3218 
3219 # 0: symbol
3220 compiler.err.duplicate.module=\
3221     duplicate module: {0}
3222 
3223 # 0: symbol
3224 compiler.err.duplicate.requires=\
3225     duplicate requires: {0}
3226 
3227 # 0: symbol
3228 compiler.err.conflicting.exports=\
3229     duplicate or conflicting exports: {0}
3230 
3231 # 0: symbol
3232 compiler.err.conflicting.opens=\
3233     duplicate or conflicting opens: {0}
3234 
3235 # 0: symbol
3236 compiler.err.conflicting.exports.to.module=\
3237     duplicate or conflicting exports to module: {0}
3238 
3239 # 0: symbol
3240 compiler.err.conflicting.opens.to.module=\
3241     duplicate or conflicting opens to module: {0}
3242 
3243 compiler.err.no.opens.unless.strong=\
3244     &#39;&#39;opens&#39;&#39; only allowed in strong modules
3245 
3246 # 0: symbol
3247 compiler.err.repeated.provides.for.service=\
3248     multiple &#39;&#39;provides&#39;&#39; for service {0}
3249 
3250 # 0: symbol, 1: symbol
3251 compiler.err.duplicate.provides=\
3252     duplicate provides: service {0}, implementation {1}
3253 
3254 # 0: symbol
3255 compiler.err.duplicate.uses=\
3256     duplicate uses: {0}
3257 
3258 # 0: symbol
3259 compiler.err.service.implementation.is.abstract=\
3260     the service implementation is an abstract class: {0}
3261 
3262 compiler.err.service.implementation.must.be.subtype.of.service.interface=\
3263     the service implementation type must be a subtype of the service interface type, or \
3264     have a public static no-args method named &quot;provider&quot; returning the service implementation
3265 
3266 compiler.err.service.implementation.provider.return.must.be.subtype.of.service.interface=\
3267     the &quot;provider&quot; method return type must be a subtype of the service interface type
3268 
3269 # 0: symbol
3270 compiler.err.service.implementation.is.inner=\
3271     the service implementation is an inner class: {0}
3272 
3273 # 0: symbol
3274 compiler.err.service.definition.is.enum=\
3275     the service definition is an enum: {0}
3276 
3277 # 0: symbol
3278 compiler.err.service.implementation.doesnt.have.a.no.args.constructor=\
3279     the service implementation does not have a default constructor: {0}
3280 
3281 # 0: symbol
3282 compiler.err.service.implementation.no.args.constructor.not.public=\
3283     the no arguments constructor of the service implementation is not public: {0}
3284 
3285 # 0: symbol
3286 compiler.err.package.empty.or.not.found=\
3287     package is empty or does not exist: {0}
3288 
3289 # 0: symbol
3290 compiler.warn.package.empty.or.not.found=\
3291     package is empty or does not exist: {0}
3292 
3293 compiler.err.no.output.dir=\
3294     no class output directory specified
3295 
3296 compiler.err.unnamed.pkg.not.allowed.named.modules=\
3297     unnamed package is not allowed in named modules
3298 
3299 # 0: name, 1: name
3300 compiler.err.module.name.mismatch=\
3301     module name {0} does not match expected name {1}
3302 
3303 # 0: name, 1: name
3304 compiler.misc.module.name.mismatch=\
3305     module name {0} does not match expected name {1}
3306 
3307 # 0: name
3308 compiler.err.module.non.zero.opens=\
3309     open module {0} has non-zero opens_count
3310 
3311 # 0: name
3312 compiler.misc.module.non.zero.opens=\
3313     open module {0} has non-zero opens_count
3314 
3315 compiler.err.module.decl.sb.in.module-info.java=\
3316     module declarations should be in a file named module-info.java
3317 
3318 # 0: set of string
3319 compiler.err.too.many.patched.modules=\
3320     too many patched modules ({0}), use --module-source-path
3321 
3322 # 0: name, 1: name
3323 compiler.err.file.patched.and.msp=\
3324     file accessible from both --patch-module and --module-source-path, \
3325     but belongs to a different module on each path: {0}, {1}
3326 
3327 compiler.err.processorpath.no.processormodulepath=\
3328     illegal combination of -processorpath and --processor-module-path
3329 
3330 # 0: symbol
3331 compiler.err.package.in.other.module=\
3332     package exists in another module: {0}
3333 
3334 # 0: symbol, 1: name, 2: symbol, 3: symbol
3335 compiler.err.package.clash.from.requires=\
3336     module {0} reads package {1} from both {2} and {3}
3337 
3338 # 0: name, 1: symbol, 2: symbol
3339 compiler.err.package.clash.from.requires.in.unnamed=\
3340     the unnamed module reads package {0} from both {1} and {2}
3341 
3342 # 0: string
3343 compiler.err.module.not.found.in.module.source.path=\
3344     module {0} not found in module source path
3345 
3346 compiler.err.output.dir.must.be.specified.with.dash.m.option=\
3347     class output directory must be specified if -m option is used
3348 
3349 compiler.err.modulesourcepath.must.be.specified.with.dash.m.option=\
3350     module source path must be specified if -m option is used
3351 
3352 # 0: symbol
3353 compiler.err.service.implementation.not.in.right.module=\
3354     service implementation must be defined in the same module as the provides directive
3355 
3356 # 0: symbol
3357 compiler.err.cyclic.requires=\
3358     cyclic dependence involving {0}
3359 
3360 # 0: fragment, 1: name
3361 compiler.err.duplicate.module.on.path=\
3362     duplicate module on {0}\nmodule in {1}
3363 
3364 # 0: option name, 1: string
3365 compiler.warn.bad.name.for.option=\
3366     bad name in value for {0} option: &#39;&#39;{1}&#39;&#39;
3367 
3368 # 0: option name, 1: string
3369 compiler.err.bad.name.for.option=\
3370     bad name in value for {0} option: &#39;&#39;{1}&#39;&#39;
3371 
3372 # 0: option name, 1: symbol
3373 compiler.warn.module.for.option.not.found=\
3374     module name in {0} option not found: {1}
3375 
3376 compiler.err.addmods.all.module.path.invalid=\
3377     --add-modules ALL-MODULE-PATH can only be used when compiling the unnamed module or \
3378     when compiling in the context of an automatic module
3379 
3380 # 0: symbol
3381 compiler.err.add.exports.with.release=\
3382     exporting a package from system module {0} is not allowed with --release
3383 
3384 # 0: symbol
3385 compiler.err.add.reads.with.release=\
3386     adding read edges for system module {0} is not allowed with --release
3387 
3388 compiler.warn.addopens.ignored=\
3389     --add-opens has no effect at compile time
3390 
3391 compiler.misc.locn.module_source_path=\
3392     module source path
3393 
3394 compiler.misc.locn.upgrade_module_path=\
3395     upgrade module path
3396 
3397 compiler.misc.locn.system_modules=\
3398     system modules
3399 
3400 compiler.misc.locn.module_path=\
3401     application module path
3402 
3403 compiler.misc.cant.resolve.modules=\
3404     cannot resolve modules
3405 
3406 compiler.misc.bad.requires.flag=\
3407     bad requires flag: {0}
3408 
3409 # 0: string
3410 compiler.err.invalid.module.specifier=\
3411     module specifier not allowed: {0}
3412 
3413 # 0: symbol
3414 compiler.warn.service.provided.but.not.exported.or.used=\
3415     service interface provided but not exported or used
3416 
3417 # 0: kind name, 1: symbol, 2: symbol
3418 compiler.warn.leaks.not.accessible=\
3419     {0} {1} in module {2} is not accessible to clients that require this module
3420 # 0: kind name, 1: symbol, 2: symbol
3421 compiler.warn.leaks.not.accessible.unexported=\
3422     {0} {1} in module {2} is not exported
3423 # 0: kind name, 1: symbol, 2: symbol
3424 compiler.warn.leaks.not.accessible.not.required.transitive=\
3425     {0} {1} in module {2} is not indirectly exported using &#39;requires transitive&#39;
3426 # 0: kind name, 1: symbol, 2: symbol
3427 compiler.warn.leaks.not.accessible.unexported.qualified=\
3428     {0} {1} in module {2} may not be visible to all clients that require this module
3429 
3430 ###
3431 # errors related to options
3432 
3433 # 0: string, 1: string
3434 compiler.err.illegal.argument.for.option=\
3435     illegal argument for {0}: {1}
3436 
3437 compiler.err.match.binding.exists=\
3438     illegal attempt to redefine an existing match binding
3439 
3440 compiler.err.switch.null.not.allowed=\
3441     null label in case is not allowed
3442 
3443 compiler.err.switch.case.unexpected.statement=\
3444     unexpected statement in case, expected is an expression, a block or a throw statement
3445 
3446 compiler.err.switch.mixing.case.types=\
3447     different case kinds used in the switch
3448 
3449 ###
3450 # errors related to sealed classes
3451 
3452 # permits clause
3453 # 0: fragment
3454 compiler.err.invalid.permits.clause=\
3455     invalid permits clause\n\
3456     ({0})
3457 
3458 # 0: string
3459 compiler.misc.class.is.not.sealed=\
3460     {0} must be sealed
3461 
3462 # 0: type
3463 compiler.misc.is.a.type.variable=\
3464     must not include type variables: {0}
3465 
3466 # 0: type
3467 compiler.misc.is.duplicated=\
3468     must not contain duplicates: {0}
3469 
3470 # 0: type
3471 compiler.misc.doesnt.extend.sealed=\
3472     subclass {0} must extend sealed class
3473 
3474 compiler.misc.must.not.be.same.class=\
3475     illegal self-reference in permits clause
3476 
3477 # 0: type
3478 compiler.misc.must.not.be.supertype=\
3479     illegal reference to supertype {0}
3480 
3481 # other sealed types related errors
3482 
3483 compiler.err.sealed.class.must.have.subclasses=\
3484     sealed class must have subclasses
3485 
3486 # errors in subclasses of sealed classes
3487 # 0: symbol
3488 compiler.err.cant.inherit.from.sealed=\
3489     class is not allowed to extend sealed class: {0} \
3490     (as it is not listed in its &#39;permits&#39; clause)
3491 
3492 # 0: symbol
3493 compiler.err.class.in.unnamed.module.cant.extend.sealed.in.diff.package=\
3494     class {0} in unnamed module cannot extend a sealed class in a different package
3495 
3496 # 0: symbol, 1: symbol
3497 compiler.err.class.in.module.cant.extend.sealed.in.diff.module=\
3498     class {0} in module {1} cannot extend a sealed class in a different module
3499 
3500 # 0: symbol
3501 compiler.err.non.sealed.with.no.sealed.supertype=\
3502     non-sealed modifier not allowed here\n\
3503     (class {0} does not have any sealed supertypes)
3504 
3505 compiler.err.non.sealed.sealed.or.final.expected=\
3506     sealed, non-sealed or final modifiers expected
3507 
3508 compiler.err.non.sealed.or.sealed.expected=\
3509     sealed or non-sealed modifiers expected
3510 
3511 compiler.err.sealed.or.non.sealed.local.classes.not.allowed=\
3512     sealed or non-sealed local classes are not allowed
3513 
3514 # 0: fragment
3515 compiler.err.local.classes.cant.extend.sealed=\
3516     {0} classes must not extend sealed classes\
3517 
3518 compiler.misc.anonymous=\
3519     anonymous
3520 
3521 compiler.misc.local=\
3522     local
3523 
3524 ###
3525 # errors related to records
3526 
3527 # record components
3528 compiler.err.record.cant.declare.field.modifiers=\
3529     record components cannot have modifiers
3530 
3531 # 0: symbol
3532 compiler.err.illegal.record.component.name=\
3533     illegal record component name {0}
3534 
3535 compiler.err.record.component.and.old.array.syntax=\
3536     legacy array notation not allowed on record components
3537 
3538 # accessor methods
3539 # 0: symbol, 1: fragment
3540 compiler.err.invalid.accessor.method.in.record=\
3541     invalid accessor method in record {0}\n\
3542     ({1})
3543 
3544 compiler.misc.method.must.be.public=\
3545     accessor method must be public
3546 
3547 # 0: symbol, 1: symbol
3548 compiler.misc.accessor.return.type.doesnt.match=\
3549     return type of accessor method {0} must match the type of record component {1}
3550 
3551 compiler.misc.accessor.method.cant.throw.exception=\
3552     throws clause not allowed for accessor method
3553 
3554 compiler.misc.accessor.method.must.not.be.generic=\
3555     accessor method must not be generic
3556 
3557 compiler.misc.accessor.method.must.not.be.static=\
3558     accessor method must not be static
3559 
3560 # canonical constructors
3561 # 0: fragment, 1: name, 2: fragment
3562 compiler.err.invalid.canonical.constructor.in.record=\
3563     invalid {0} constructor in record {1}\n\
3564     ({2})
3565 
3566 compiler.misc.canonical=\
3567     canonical
3568 
3569 compiler.misc.compact=\
3570     compact
3571 
3572 # 0: fragment
3573 compiler.misc.throws.clause.not.allowed.for.canonical.constructor=\
3574     throws clause not allowed for {0} constructor
3575 
3576 compiler.misc.canonical.with.name.mismatch=\
3577     invalid parameter names in canonical constructor
3578 
3579 compiler.misc.canonical.cant.have.return.statement=\
3580     compact constructor must not have return statements
3581 
3582 compiler.misc.canonical.must.not.declare.type.variables=\
3583     canonical constructor must not declare type variables
3584 
3585 compiler.misc.type.must.be.identical.to.corresponding.record.component.type=\
3586     type and arity must match that of the corresponding record component\
3587 
3588 compiler.misc.canonical.must.not.contain.explicit.constructor.invocation=\
3589     canonical constructor must not contain explicit constructor invocation
3590 
3591 # 0: set of flag or string
3592 compiler.misc.canonical.must.not.have.stronger.access=\
3593     attempting to assign stronger access privileges; was {0}
3594 
3595 # other
3596 compiler.err.record.cannot.declare.instance.fields=\
3597     field declaration must be static\n\
3598     (consider replacing field with record component)
3599 
3600 # 0: symbol
3601 compiler.err.invalid.supertype.record=\
3602     classes cannot directly extend {0}
3603 
3604 # 0: symbol
3605 compiler.err.first.statement.must.be.call.to.another.constructor=\
3606     constructor is not canonical, so its first statement must invoke another constructor of class {0}
3607 
3608 compiler.err.instance.initializer.not.allowed.in.records=\
3609     instance initializers not allowed in records
3610 
3611 compiler.err.static.declaration.not.allowed.in.inner.classes=\
3612     static declarations not allowed in inner classes
3613 
3614 compiler.err.record.header.expected=\
3615     record header expected
3616 
3617 ############################################
3618 # messages previously at javac.properties
3619 
3620 compiler.err.empty.A.argument=\
3621     -A requires an argument; use &#39;&#39;-Akey&#39;&#39; or &#39;&#39;-Akey=value&#39;&#39;
3622 
3623 # 0: string
3624 compiler.err.invalid.A.key=\
3625     key in annotation processor option &#39;&#39;{0}&#39;&#39; is not a dot-separated sequence of identifiers
3626 
3627 # 0: string
3628 compiler.err.invalid.flag=\
3629     invalid flag: {0}
3630 
3631 compiler.err.profile.bootclasspath.conflict=\
3632     profile and bootclasspath options cannot be used together
3633 
3634 # 0: string
3635 compiler.err.invalid.profile=\
3636     invalid profile: {0}
3637 
3638 # 0: string
3639 compiler.err.invalid.target=\
3640     invalid target release: {0}
3641 
3642 # 0: option name, 1: target
3643 compiler.err.option.not.allowed.with.target=\
3644     option {0} not allowed with target {1}
3645 
3646 # 0: string
3647 compiler.err.option.too.many=\
3648     option {0} can only be specified once
3649 
3650 compiler.err.no.source.files=\
3651     no source files
3652 
3653 compiler.err.no.source.files.classes=\
3654     no source files or class names
3655 
3656 # 0: string
3657 compiler.err.req.arg=\
3658     {0} requires an argument
3659 
3660 # 0: string
3661 compiler.err.invalid.source=\
3662     invalid source release: {0}
3663 
3664 # 0: string, 1: string
3665 compiler.err.error.writing.file=\
3666     error writing {0}; {1}
3667 
3668 compiler.err.sourcepath.modulesourcepath.conflict=\
3669     cannot specify both --source-path and --module-source-path
3670 
3671 # 0: string, 1: target
3672 compiler.warn.source.target.conflict=\
3673     source release {0} requires target release {1}
3674 
3675 # 0: string, 1: target
3676 compiler.warn.target.default.source.conflict=\
3677     target release {0} conflicts with default source release {1}
3678 
3679 # 0: profile, 1: target
3680 compiler.warn.profile.target.conflict=\
3681     profile {0} is not valid for target release {1}
3682 
3683 # 0: string
3684 compiler.err.file.not.directory=\
3685     not a directory: {0}
3686 
3687 # 0: object
3688 compiler.err.file.not.file=\
3689     not a file: {0}
3690 
3691 compiler.err.two.class.loaders.1=\
3692     javac is split between multiple class loaders: check your configuration
3693 
3694 # 0: url, 1: url
3695 compiler.err.two.class.loaders.2=\
3696     javac is split between multiple class loaders:\n\
3697     one class comes from file: {0}\n\
3698     while javac comes from {1}
3699 
3700 # 0: string, 1: string
3701 compiler.err.bad.value.for.option=\
3702     bad value for {0} option: &#39;&#39;{1}&#39;&#39;
3703 
3704 # 0: string
3705 compiler.err.no.value.for.option=\
3706     no value for {0} option
3707 
3708 # 0: string
3709 compiler.err.repeated.value.for.patch.module=\
3710     --patch-module specified more than once for module {0}
3711 
3712 # 0: string
3713 compiler.err.repeated.value.for.module.source.path=\
3714     --module-source-path specified more than once for module {0}
3715 
3716 compiler.err.multiple.values.for.module.source.path=\
3717     --module-source-path specified more than once with a pattern argument
3718 
3719 # 0: string
3720 compiler.err.unmatched.quote=\
3721     unmatched quote in environment variable {0}
3722 
3723 # 0: option name
3724 compiler.err.release.bootclasspath.conflict=\
3725     option {0} cannot be used together with --release
3726 
3727 # 0: string
3728 compiler.err.unsupported.release.version=\
3729     release version {0} not supported
3730 
3731 # 0: string
3732 compiler.err.file.not.found=\
3733     file not found: {0}
3734 
3735 # 0: string, 1: source
3736 compiler.err.preview.not.latest=\
3737     invalid source release {0} with --enable-preview\n\
3738     (preview language features are only supported for release {1})
3739 
3740 compiler.err.preview.without.source.or.release=\
3741     --enable-preview must be used with either -source or --release
    </pre>
  </body>
</html>