<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavaTokenizer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JavadocTokenizer.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavaTokenizer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 28,124 ***</span>
  import com.sun.tools.javac.code.Lint;
  import com.sun.tools.javac.code.Lint.LintCategory;
  import com.sun.tools.javac.code.Preview;
  import com.sun.tools.javac.code.Source;
  import com.sun.tools.javac.code.Source.Feature;
  import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  import com.sun.tools.javac.resources.CompilerProperties.Errors;
  import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  import com.sun.tools.javac.util.*;
  import com.sun.tools.javac.util.JCDiagnostic.*;
  
<span class="line-removed">- import java.lang.reflect.InvocationTargetException;</span>
<span class="line-removed">- import java.lang.reflect.Method;</span>
  import java.nio.CharBuffer;
<span class="line-removed">- import java.util.HashSet;</span>
  import java.util.Set;
  
  import static com.sun.tools.javac.parser.Tokens.*;
<span class="line-modified">! import static com.sun.tools.javac.util.LayoutCharacters.*;</span>
  
<span class="line-modified">! /** The lexical analyzer maps an input stream consisting of</span>
<span class="line-modified">!  *  ASCII characters and Unicode escapes into a token sequence.</span>
   *
   *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
   *  If you write code that depends on this, you do so at your own risk.
   *  This code and its internal interfaces are subject to change or
   *  deletion without notice.&lt;/b&gt;
   */
<span class="line-modified">! public class JavaTokenizer {</span>
<span class="line-modified">! </span>
      private static final boolean scannerDebug = false;
  
<span class="line-modified">!     /** The source language setting.</span>
       */
      private Source source;
  
<span class="line-modified">!     /** The preview language setting. */</span>
      private Preview preview;
  
<span class="line-modified">!     /** The log to be used for error reporting.</span>
       */
      private final Log log;
  
<span class="line-modified">!     /** The token factory. */</span>
      private final Tokens tokens;
  
<span class="line-modified">!     /** The token kind, set by nextToken().</span>
       */
      protected TokenKind tk;
  
<span class="line-modified">!     /** The token&#39;s radix, set by nextToken().</span>
       */
      protected int radix;
  
<span class="line-modified">!     /** The token&#39;s name, set by nextToken().</span>
       */
      protected Name name;
  
<span class="line-modified">!     /** The position where a lexical error occurred;</span>
       */
      protected int errPos = Position.NOPOS;
  
<span class="line-modified">!     /** The Unicode reader (low-level stream reader).</span>
<span class="line-modified">!      */</span>
<span class="line-removed">-     protected UnicodeReader reader;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** If is a text block</span>
       */
      protected boolean isTextBlock;
  
<span class="line-modified">!     /** If contains escape sequences</span>
       */
      protected boolean hasEscapeSequences;
  
      protected ScannerFactory fac;
  
<span class="line-modified">!     // The set of lint options currently in effect. It is initialized</span>
<span class="line-modified">!     // from the context, and then is set/reset as needed by Attr as it</span>
<span class="line-modified">!     // visits all the various parts of the trees during attribution.</span>
      protected Lint lint;
  
<span class="line-removed">-     private static final boolean hexFloatsWork = hexFloatsWork();</span>
<span class="line-removed">-     private static boolean hexFloatsWork() {</span>
<span class="line-removed">-         try {</span>
<span class="line-removed">-             Float.valueOf(&quot;0x1.0p1&quot;);</span>
<span class="line-removed">-             return true;</span>
<span class="line-removed">-         } catch (NumberFormatException ex) {</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      /**
<span class="line-modified">!      * Create a scanner from the input array.  This method might</span>
<span class="line-removed">-      * modify the array.  To avoid copying the input array, ensure</span>
<span class="line-removed">-      * that {@code inputLength &lt; input.length} or</span>
<span class="line-removed">-      * {@code input[input.length -1]} is a white space character.</span>
       *
<span class="line-modified">!      * @param fac the factory which created this Scanner</span>
<span class="line-modified">!      * @param buf the input, might be modified</span>
<span class="line-removed">-      * Must be positive and less than or equal to input.length.</span>
       */
<span class="line-modified">!     protected JavaTokenizer(ScannerFactory fac, CharBuffer buf) {</span>
<span class="line-modified">!         this(fac, new UnicodeReader(fac, buf));</span>
      }
  
<span class="line-modified">!     protected JavaTokenizer(ScannerFactory fac, char[] buf, int inputLength) {</span>
<span class="line-modified">!         this(fac, new UnicodeReader(fac, buf, inputLength));</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     protected JavaTokenizer(ScannerFactory fac, UnicodeReader reader) {</span>
          this.fac = fac;
          this.log = fac.log;
          this.tokens = fac.tokens;
          this.source = fac.source;
          this.preview = fac.preview;
<span class="line-removed">-         this.reader = reader;</span>
          this.lint = fac.lint;
      }
  
      protected void checkSourceLevel(int pos, Feature feature) {
          if (preview.isPreview(feature) &amp;&amp; !preview.isEnabled()) {
              //preview feature without --preview flag, error
              lexError(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));
          } else if (!feature.allowedInSource(source)) {
<span class="line-new-header">--- 28,151 ---</span>
  import com.sun.tools.javac.code.Lint;
  import com.sun.tools.javac.code.Lint.LintCategory;
  import com.sun.tools.javac.code.Preview;
  import com.sun.tools.javac.code.Source;
  import com.sun.tools.javac.code.Source.Feature;
<span class="line-added">+ import com.sun.tools.javac.file.JavacFileManager;</span>
  import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  import com.sun.tools.javac.resources.CompilerProperties.Errors;
  import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  import com.sun.tools.javac.util.*;
  import com.sun.tools.javac.util.JCDiagnostic.*;
  
  import java.nio.CharBuffer;
  import java.util.Set;
<span class="line-added">+ import java.util.regex.Pattern;</span>
  
  import static com.sun.tools.javac.parser.Tokens.*;
<span class="line-modified">! import static com.sun.tools.javac.util.LayoutCharacters.EOI;</span>
  
<span class="line-modified">! /**</span>
<span class="line-modified">!  * The lexical analyzer maps an input stream consisting of UTF-8 characters and unicode</span>
<span class="line-added">+  * escape sequences into a token sequence.</span>
   *
   *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
   *  If you write code that depends on this, you do so at your own risk.
   *  This code and its internal interfaces are subject to change or
   *  deletion without notice.&lt;/b&gt;
   */
<span class="line-modified">! public class JavaTokenizer extends UnicodeReader {</span>
<span class="line-modified">!     /**</span>
<span class="line-added">+      * If true then prints token information after each nextToken().</span>
<span class="line-added">+      */</span>
      private static final boolean scannerDebug = false;
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Sentinal for non-value.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private int NOT_FOUND = -1;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * The source language setting. Copied from scanner factory.</span>
       */
      private Source source;
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * The preview language setting. Copied from scanner factory.</span>
<span class="line-added">+      */</span>
      private Preview preview;
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * The log to be used for error reporting. Copied from scanner factory.</span>
       */
      private final Log log;
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * The token factory. Copied from scanner factory.</span>
<span class="line-added">+      */</span>
      private final Tokens tokens;
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * The names factory. Copied from scanner factory.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private final Names names;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * The token kind, set by nextToken().</span>
       */
      protected TokenKind tk;
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * The token&#39;s radix, set by nextToken().</span>
       */
      protected int radix;
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * The token&#39;s name, set by nextToken().</span>
       */
      protected Name name;
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * The position where a lexical error occurred;</span>
       */
      protected int errPos = Position.NOPOS;
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * true if is a text block, set by nextToken().</span>
       */
      protected boolean isTextBlock;
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * true if contains escape sequences, set by nextToken().</span>
       */
      protected boolean hasEscapeSequences;
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Buffer for building literals, used by nextToken().</span>
<span class="line-added">+      */</span>
<span class="line-added">+     protected StringBuilder sb;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Origin scanner factory.</span>
<span class="line-added">+      */</span>
      protected ScannerFactory fac;
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * The set of lint options currently in effect. It is initialized</span>
<span class="line-modified">!      * from the context, and then is set/reset as needed by Attr as it</span>
<span class="line-added">+      * visits all the various parts of the trees during attribution.</span>
<span class="line-added">+      */</span>
      protected Lint lint;
  
      /**
<span class="line-modified">!      * Construct a Java token scanner from the input character buffer.</span>
       *
<span class="line-modified">!      * @param fac  the factory which created this Scanner.</span>
<span class="line-modified">!      * @param cb   the input character buffer.</span>
       */
<span class="line-modified">!     protected JavaTokenizer(ScannerFactory fac, CharBuffer cb) {</span>
<span class="line-modified">!         this(fac, JavacFileManager.toArray(cb), cb.limit());</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Construct a Java token scanner from the input character array.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @param fac     the factory which created this Scanner</span>
<span class="line-modified">!      * @param array   the input character array.</span>
<span class="line-added">+      * @param length  The length of the meaningful content in the array.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     protected JavaTokenizer(ScannerFactory fac, char[] array, int length) {</span>
<span class="line-added">+         super(fac, array, length);</span>
          this.fac = fac;
          this.log = fac.log;
<span class="line-added">+         this.names = fac.names;</span>
          this.tokens = fac.tokens;
          this.source = fac.source;
          this.preview = fac.preview;
          this.lint = fac.lint;
<span class="line-added">+         this.sb = new StringBuilder(256);</span>
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Check the source level for a lexical feature.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param pos      position in input buffer.</span>
<span class="line-added">+      * @param feature  feature to verify.</span>
<span class="line-added">+      */</span>
      protected void checkSourceLevel(int pos, Feature feature) {
          if (preview.isPreview(feature) &amp;&amp; !preview.isEnabled()) {
              //preview feature without --preview flag, error
              lexError(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));
          } else if (!feature.allowedInSource(source)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,486 ***</span>
              //use of preview feature, warn
              preview.warnPreview(pos, feature);
          }
      }
  
<span class="line-modified">!     /** Report an error at the given position using the provided arguments.</span>
       */
      protected void lexError(int pos, JCDiagnostic.Error key) {
          log.error(pos, key);
          tk = TokenKind.ERROR;
          errPos = pos;
      }
  
      protected void lexError(DiagnosticFlag flags, int pos, JCDiagnostic.Error key) {
          log.error(flags, pos, key);
          tk = TokenKind.ERROR;
          errPos = pos;
      }
  
      protected void lexWarning(LintCategory lc, int pos, JCDiagnostic.Warning key) {
          DiagnosticPosition dp = new SimpleDiagnosticPosition(pos) ;
          log.warning(lc, dp, key);
      }
  
<span class="line-modified">!     /** Read next character in character or string literal and copy into sbuf.</span>
<span class="line-modified">!      *      pos - start of literal offset</span>
<span class="line-modified">!      *      translateEscapesNow - true if String::translateEscapes is not available</span>
<span class="line-modified">!      *                            in the java.base libs. Occurs during bootstrapping.</span>
<span class="line-removed">-      *      multiline - true if scanning a text block. Allows newlines to be embedded</span>
<span class="line-removed">-      *                  in the result.</span>
       */
<span class="line-modified">!     private void scanLitChar(int pos, boolean translateEscapesNow, boolean multiline) {</span>
<span class="line-modified">!          if (reader.ch == &#39;\\&#39;) {</span>
<span class="line-removed">-             if (reader.peekChar() == &#39;\\&#39; &amp;&amp; !reader.isUnicode()) {</span>
<span class="line-removed">-                 reader.skipChar();</span>
<span class="line-removed">-                 if (!translateEscapesNow) {</span>
<span class="line-removed">-                     reader.putChar(false);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 reader.putChar(true);</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 reader.nextChar(translateEscapesNow);</span>
<span class="line-removed">-                 switch (reader.ch) {</span>
<span class="line-removed">-                 case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;:</span>
<span class="line-removed">-                 case &#39;4&#39;: case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;:</span>
<span class="line-removed">-                     char leadch = reader.ch;</span>
<span class="line-removed">-                     int oct = reader.digit(pos, 8);</span>
<span class="line-removed">-                     reader.nextChar(translateEscapesNow);</span>
<span class="line-removed">-                     if (&#39;0&#39; &lt;= reader.ch &amp;&amp; reader.ch &lt;= &#39;7&#39;) {</span>
<span class="line-removed">-                         oct = oct * 8 + reader.digit(pos, 8);</span>
<span class="line-removed">-                         reader.nextChar(translateEscapesNow);</span>
<span class="line-removed">-                         if (leadch &lt;= &#39;3&#39; &amp;&amp; &#39;0&#39; &lt;= reader.ch &amp;&amp; reader.ch &lt;= &#39;7&#39;) {</span>
<span class="line-removed">-                             oct = oct * 8 + reader.digit(pos, 8);</span>
<span class="line-removed">-                             reader.nextChar(translateEscapesNow);</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     if (translateEscapesNow) {</span>
<span class="line-removed">-                         reader.putChar((char)oct);</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 case &#39;b&#39;:</span>
<span class="line-removed">-                     reader.putChar(translateEscapesNow ? &#39;\b&#39; : &#39;b&#39;, true); break;</span>
<span class="line-removed">-                 case &#39;t&#39;:</span>
<span class="line-removed">-                     reader.putChar(translateEscapesNow ? &#39;\t&#39; : &#39;t&#39;, true); break;</span>
<span class="line-removed">-                 case &#39;n&#39;:</span>
<span class="line-removed">-                     reader.putChar(translateEscapesNow ? &#39;\n&#39; : &#39;n&#39;, true); break;</span>
<span class="line-removed">-                 case &#39;f&#39;:</span>
<span class="line-removed">-                     reader.putChar(translateEscapesNow ? &#39;\f&#39; : &#39;f&#39;, true); break;</span>
<span class="line-removed">-                 case &#39;r&#39;:</span>
<span class="line-removed">-                     reader.putChar(translateEscapesNow ? &#39;\r&#39; : &#39;r&#39;, true); break;</span>
<span class="line-removed">-                 case &#39;\&#39;&#39;:</span>
<span class="line-removed">-                 case &#39;\&quot;&#39;:</span>
<span class="line-removed">-                 case &#39;\\&#39;:</span>
<span class="line-removed">-                     reader.putChar(true); break;</span>
<span class="line-removed">-                 case &#39;s&#39;:</span>
<span class="line-removed">-                     checkSourceLevel(reader.bp, Feature.TEXT_BLOCKS);</span>
<span class="line-removed">-                     reader.putChar(translateEscapesNow ? &#39; &#39; : &#39;s&#39;, true); break;</span>
<span class="line-removed">-                 case &#39;\n&#39;:</span>
<span class="line-removed">-                 case &#39;\r&#39;:</span>
<span class="line-removed">-                     if (!multiline) {</span>
<span class="line-removed">-                         lexError(reader.bp, Errors.IllegalEscChar);</span>
<span class="line-removed">-                     } else {</span>
<span class="line-removed">-                         checkSourceLevel(reader.bp, Feature.TEXT_BLOCKS);</span>
<span class="line-removed">-                         int start = reader.bp;</span>
<span class="line-removed">-                         if (reader.ch == &#39;\r&#39; &amp;&amp; reader.peekChar() == &#39;\n&#39;) {</span>
<span class="line-removed">-                            reader.nextChar(translateEscapesNow);</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                         reader.nextChar(translateEscapesNow);</span>
<span class="line-removed">-                         processLineTerminator(start, reader.bp);</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 default:</span>
<span class="line-removed">-                     lexError(reader.bp, Errors.IllegalEscChar);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         } else if (reader.bp != reader.buflen) {</span>
<span class="line-removed">-             reader.putChar(true);</span>
<span class="line-removed">-         }</span>
      }
  
<span class="line-modified">!     /** Interim access to String methods used to support text blocks.</span>
<span class="line-modified">!      *  Required to handle bootstrapping with pre-text block jdks.</span>
<span class="line-modified">!      *  Should be replaced with direct calls in the &#39;next&#39; jdk.</span>
       */
<span class="line-modified">!     static class TextBlockSupport {</span>
<span class="line-modified">!         /** Reflection method to remove incidental indentation.</span>
<span class="line-modified">!          */</span>
<span class="line-removed">-         private static final Method stripIndent;</span>
  
<span class="line-modified">!         /** Reflection method to translate escape sequences.</span>
<span class="line-modified">!          */</span>
<span class="line-modified">!         private static final Method translateEscapes;</span>
  
<span class="line-modified">!         /** true if stripIndent and translateEscapes are available in the bootstrap jdk.</span>
<span class="line-modified">!          */</span>
<span class="line-modified">!         private static final boolean hasSupport;</span>
  
<span class="line-modified">!         /** Get a string method via refection or null if not available.</span>
<span class="line-modified">!          */</span>
<span class="line-modified">!         private static Method getStringMethodOrNull(String name) {</span>
<span class="line-modified">!             try {</span>
<span class="line-modified">!                 return String.class.getMethod(name);</span>
<span class="line-removed">-             } catch (Exception ex) {</span>
<span class="line-removed">-                 // Method not available, return null.</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return null;</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         static {</span>
<span class="line-modified">!             // Get text block string methods.</span>
<span class="line-removed">-             stripIndent = getStringMethodOrNull(&quot;stripIndent&quot;);</span>
<span class="line-removed">-             translateEscapes = getStringMethodOrNull(&quot;translateEscapes&quot;);</span>
<span class="line-removed">-             // true if stripIndent and translateEscapes are available in the bootstrap jdk.</span>
<span class="line-removed">-             hasSupport = stripIndent != null &amp;&amp; translateEscapes != null;</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         /** Return true if stripIndent and translateEscapes are available in the bootstrap jdk.</span>
<span class="line-modified">!          */</span>
<span class="line-modified">!         static boolean hasSupport() {</span>
<span class="line-modified">!             return hasSupport;</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         /** Return the leading whitespace count (indentation) of the line.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         private static int indent(String line) {</span>
<span class="line-removed">-             return line.length() - line.stripLeading().length();</span>
          }
  
<span class="line-modified">!         enum WhitespaceChecks {</span>
<span class="line-modified">!             INCONSISTENT,</span>
<span class="line-removed">-             TRAILING</span>
<span class="line-removed">-         };</span>
  
<span class="line-modified">!         /** Check that the use of white space in content is not problematic.</span>
<span class="line-modified">!          */</span>
<span class="line-modified">!         static Set&lt;WhitespaceChecks&gt; checkWhitespace(String string) {</span>
<span class="line-modified">!             // Start with empty result set.</span>
<span class="line-modified">!             Set&lt;WhitespaceChecks&gt; checks = new HashSet&lt;&gt;();</span>
<span class="line-modified">!             // No need to check empty strings.</span>
<span class="line-modified">!             if (string.isEmpty()) {</span>
<span class="line-modified">!                 return checks;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             // Maximum common indentation.</span>
<span class="line-modified">!             int outdent = 0;</span>
<span class="line-modified">!             // No need to check indentation if opting out (last line is empty.)</span>
<span class="line-modified">!             char lastChar = string.charAt(string.length() - 1);</span>
<span class="line-removed">-             boolean optOut = lastChar == &#39;\n&#39; || lastChar == &#39;\r&#39;;</span>
<span class="line-removed">-             // Split string based at line terminators.</span>
<span class="line-removed">-             String[] lines = string.split(&quot;\\R&quot;);</span>
<span class="line-removed">-             int length = lines.length;</span>
<span class="line-removed">-             // Extract last line.</span>
<span class="line-removed">-             String lastLine = length == 0 ? &quot;&quot; : lines[length - 1];</span>
<span class="line-removed">-              if (!optOut) {</span>
<span class="line-removed">-                 // Prime with the last line indentation (may be blank.)</span>
<span class="line-removed">-                 outdent = indent(lastLine);</span>
<span class="line-removed">-                 for (String line : lines) {</span>
<span class="line-removed">-                     // Blanks lines have no influence (last line accounted for.)</span>
<span class="line-removed">-                     if (!line.isBlank()) {</span>
<span class="line-removed">-                         outdent = Integer.min(outdent, indent(line));</span>
<span class="line-removed">-                         if (outdent == 0) {</span>
<span class="line-removed">-                             break;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             // Last line is representative.</span>
<span class="line-removed">-             String start = lastLine.substring(0, outdent);</span>
<span class="line-removed">-             for (String line : lines) {</span>
<span class="line-removed">-                 // Fail if a line does not have the same indentation.</span>
<span class="line-removed">-                 if (!line.isBlank() &amp;&amp; !line.startsWith(start)) {</span>
<span class="line-removed">-                     // Mix of different white space</span>
<span class="line-removed">-                     checks.add(WhitespaceChecks.INCONSISTENT);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 // Line has content even after indent is removed.</span>
<span class="line-removed">-                 if (outdent &lt; line.length()) {</span>
<span class="line-removed">-                     // Is the last character a white space.</span>
<span class="line-removed">-                     lastChar = line.charAt(line.length() - 1);</span>
<span class="line-removed">-                     if (Character.isWhitespace(lastChar)) {</span>
<span class="line-removed">-                         // Has trailing white space.</span>
<span class="line-removed">-                         checks.add(WhitespaceChecks.TRAILING);</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return checks;</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         /** Invoke String::stripIndent through reflection.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         static String stripIndent(String string) {</span>
<span class="line-removed">-             try {</span>
<span class="line-removed">-                 string = (String)stripIndent.invoke(string);</span>
<span class="line-removed">-             } catch (InvocationTargetException | IllegalAccessException ex) {</span>
<span class="line-removed">-                 throw new RuntimeException(ex);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return string;</span>
          }
  
<span class="line-modified">!         /** Invoke String::translateEscapes through reflection.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         static String translateEscapes(String string) {</span>
<span class="line-removed">-             try {</span>
<span class="line-removed">-                 string = (String)translateEscapes.invoke(string);</span>
<span class="line-removed">-             } catch (InvocationTargetException | IllegalAccessException ex) {</span>
<span class="line-removed">-                 throw new RuntimeException(ex);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return string;</span>
<span class="line-removed">-         }</span>
      }
  
<span class="line-modified">!     /** Test for EOLN.</span>
       */
      private boolean isEOLN() {
<span class="line-modified">!         return reader.ch == LF || reader.ch == CR;</span>
      }
  
<span class="line-modified">!     /** Test for CRLF.</span>
       */
<span class="line-modified">!     private boolean isCRLF() {</span>
<span class="line-modified">!         return reader.ch == CR &amp;&amp; reader.peekChar() == LF;</span>
      }
  
<span class="line-modified">!     /** Count and skip repeated occurrences of the specified character.</span>
       */
<span class="line-modified">!     private int countChar(char ch, int max) {</span>
<span class="line-modified">!         int count = 0;</span>
<span class="line-modified">!         for ( ; count &lt; max &amp;&amp; reader.bp &lt; reader.buflen &amp;&amp; reader.ch == ch; count++) {</span>
<span class="line-removed">-             reader.scanChar();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return count;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     /** Skip and process a line terminator.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     private void skipLineTerminator() {</span>
<span class="line-modified">!         int start = reader.bp;</span>
<span class="line-modified">!         if (isCRLF()) {</span>
<span class="line-modified">!             reader.scanChar();</span>
          }
<span class="line-removed">-         reader.scanChar();</span>
<span class="line-removed">-         processLineTerminator(start, reader.bp);</span>
      }
  
<span class="line-modified">!     /** Scan a string literal or text block.</span>
       */
      private void scanString(int pos) {
<span class="line-modified">!         // Clear flags.</span>
<span class="line-modified">!         isTextBlock = false;</span>
<span class="line-removed">-         hasEscapeSequences = false;</span>
          // Track the end of first line for error recovery.
<span class="line-modified">!         int firstEOLN = -1;</span>
<span class="line-modified">!         // Attempt to scan for up to 3 double quotes.</span>
<span class="line-modified">!         int openCount = countChar(&#39;\&quot;&#39;, 3);</span>
<span class="line-modified">!         switch (openCount) {</span>
<span class="line-modified">!         case 1: // Starting a string literal.</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case 2: // Starting an empty string literal.</span>
<span class="line-removed">-             tk = Tokens.TokenKind.STRINGLITERAL;</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         case 3: // Starting a text block.</span>
              // Check if preview feature is enabled for text blocks.
              checkSourceLevel(pos, Feature.TEXT_BLOCKS);
<span class="line-modified">!             isTextBlock = true;</span>
              // Verify the open delimiter sequence.
<span class="line-modified">!             while (reader.bp &lt; reader.buflen) {</span>
<span class="line-modified">!                 char ch = reader.ch;</span>
<span class="line-modified">!                 if (ch != &#39; &#39; &amp;&amp; ch != &#39;\t&#39; &amp;&amp; ch != FF) {</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 reader.scanChar();</span>
<span class="line-removed">-             }</span>
              if (isEOLN()) {
                  skipLineTerminator();
              } else {
<span class="line-modified">!                 // Error if the open delimiter sequence is not</span>
<span class="line-removed">-                 //     &quot;&quot;&quot;&lt;white space&gt;*&lt;LineTerminator&gt;.</span>
<span class="line-removed">-                 lexError(reader.bp, Errors.IllegalTextBlockOpen);</span>
                  return;
              }
<span class="line-modified">!             break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         // While characters are available.</span>
<span class="line-modified">!         while (reader.bp &lt; reader.buflen) {</span>
<span class="line-removed">-             // If possible close delimiter sequence.</span>
<span class="line-removed">-             if (reader.ch == &#39;\&quot;&#39;) {</span>
<span class="line-removed">-                 // Check to see if enough double quotes are present.</span>
<span class="line-removed">-                 int closeCount = countChar(&#39;\&quot;&#39;, openCount);</span>
<span class="line-removed">-                 if (openCount == closeCount) {</span>
<span class="line-removed">-                     // Good result.</span>
<span class="line-removed">-                     tk = Tokens.TokenKind.STRINGLITERAL;</span>
                      return;
                  }
<span class="line-modified">!                 // False alarm, add double quotes to string buffer.</span>
<span class="line-modified">!                 reader.repeat(&#39;\&quot;&#39;, closeCount);</span>
<span class="line-modified">!             } else if (isEOLN()) {</span>
<span class="line-modified">!                 // Line terminator in string literal is an error.</span>
<span class="line-modified">!                 // Fall out to unclosed string literal error.</span>
<span class="line-modified">!                 if (openCount == 1) {</span>
<span class="line-modified">!                     break;</span>
                  }
<span class="line-modified">!                 skipLineTerminator();</span>
<span class="line-modified">!                 // Add line terminator to string buffer.</span>
<span class="line-modified">!                 reader.putChar(&#39;\n&#39;, false);</span>
<span class="line-modified">!                 // Record first line terminator for error recovery.</span>
<span class="line-modified">!                 if (firstEOLN == -1) {</span>
<span class="line-modified">!                     firstEOLN = reader.bp;</span>
                  }
<span class="line-removed">-             } else if (reader.ch == &#39;\\&#39;) {</span>
<span class="line-removed">-                 // Handle escape sequences.</span>
<span class="line-removed">-                 hasEscapeSequences = true;</span>
<span class="line-removed">-                 // Translate escapes immediately if TextBlockSupport is not available</span>
<span class="line-removed">-                 // during bootstrapping.</span>
<span class="line-removed">-                 boolean translateEscapesNow = !TextBlockSupport.hasSupport();</span>
<span class="line-removed">-                 scanLitChar(pos, translateEscapesNow, openCount != 1);</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 // Add character to string buffer.</span>
<span class="line-removed">-                 reader.putChar(true);</span>
              }
          }
          // String ended without close delimiter sequence.
<span class="line-modified">!         lexError(pos, openCount == 1 ? Errors.UnclosedStrLit : Errors.UnclosedTextBlock);</span>
<span class="line-modified">!         if (firstEOLN  != -1) {</span>
<span class="line-modified">!             // Reset recovery position to point after open delimiter sequence.</span>
<span class="line-modified">!             reader.reset(firstEOLN);</span>
          }
      }
  
      private void scanDigits(int pos, int digitRadix) {
<span class="line-modified">!         char saveCh;</span>
<span class="line-modified">!         int savePos;</span>
          do {
<span class="line-modified">!             if (reader.ch != &#39;_&#39;) {</span>
<span class="line-modified">!                 reader.putChar(false);</span>
              }
<span class="line-modified">!             saveCh = reader.ch;</span>
<span class="line-modified">!             savePos = reader.bp;</span>
<span class="line-modified">!             reader.scanChar();</span>
<span class="line-modified">!         } while (reader.digit(pos, digitRadix) &gt;= 0 || reader.ch == &#39;_&#39;);</span>
<span class="line-modified">!         if (saveCh == &#39;_&#39;)</span>
<span class="line-modified">!             lexError(savePos, Errors.IllegalUnderscore);</span>
      }
  
<span class="line-modified">!     /** Read fractional part of hexadecimal floating point number.</span>
       */
      private void scanHexExponentAndSuffix(int pos) {
<span class="line-modified">!         if (reader.ch == &#39;p&#39; || reader.ch == &#39;P&#39;) {</span>
<span class="line-removed">-             reader.putChar(true);</span>
              skipIllegalUnderscores();
<span class="line-modified">!             if (reader.ch == &#39;+&#39; || reader.ch == &#39;-&#39;) {</span>
<span class="line-removed">-                 reader.putChar(true);</span>
<span class="line-removed">-             }</span>
              skipIllegalUnderscores();
<span class="line-modified">!             if (reader.digit(pos, 10) &gt;= 0) {</span>
                  scanDigits(pos, 10);
<span class="line-modified">!                 if (!hexFloatsWork)</span>
<span class="line-removed">-                     lexError(pos, Errors.UnsupportedCrossFpLit);</span>
<span class="line-removed">-             } else</span>
                  lexError(pos, Errors.MalformedFpLit);
          } else {
              lexError(pos, Errors.MalformedFpLit);
          }
<span class="line-modified">!         if (reader.ch == &#39;f&#39; || reader.ch == &#39;F&#39;) {</span>
<span class="line-modified">!             reader.putChar(true);</span>
              tk = TokenKind.FLOATLITERAL;
              radix = 16;
          } else {
<span class="line-modified">!             if (reader.ch == &#39;d&#39; || reader.ch == &#39;D&#39;) {</span>
<span class="line-removed">-                 reader.putChar(true);</span>
<span class="line-removed">-             }</span>
              tk = TokenKind.DOUBLELITERAL;
              radix = 16;
          }
      }
  
<span class="line-modified">!     /** Read fractional part of floating point number.</span>
       */
      private void scanFraction(int pos) {
          skipIllegalUnderscores();
<span class="line-modified">!         if (reader.digit(pos, 10) &gt;= 0) {</span>
              scanDigits(pos, 10);
          }
<span class="line-modified">!         int sp1 = reader.sp;</span>
<span class="line-modified">!         if (reader.ch == &#39;e&#39; || reader.ch == &#39;E&#39;) {</span>
<span class="line-modified">!             reader.putChar(true);</span>
              skipIllegalUnderscores();
<span class="line-modified">!             if (reader.ch == &#39;+&#39; || reader.ch == &#39;-&#39;) {</span>
<span class="line-removed">-                 reader.putChar(true);</span>
<span class="line-removed">-             }</span>
              skipIllegalUnderscores();
<span class="line-modified">!             if (reader.digit(pos, 10) &gt;= 0) {</span>
                  scanDigits(pos, 10);
                  return;
              }
              lexError(pos, Errors.MalformedFpLit);
<span class="line-modified">!             reader.sp = sp1;</span>
          }
      }
  
<span class="line-modified">!     /** Read fractional part and &#39;d&#39; or &#39;f&#39; suffix of floating point number.</span>
       */
      private void scanFractionAndSuffix(int pos) {
          radix = 10;
          scanFraction(pos);
<span class="line-modified">!         if (reader.ch == &#39;f&#39; || reader.ch == &#39;F&#39;) {</span>
<span class="line-modified">!             reader.putChar(true);</span>
<span class="line-modified">!             tk = TokenKind.FLOATLITERAL;</span>
          } else {
<span class="line-modified">!             if (reader.ch == &#39;d&#39; || reader.ch == &#39;D&#39;) {</span>
<span class="line-removed">-                 reader.putChar(true);</span>
<span class="line-removed">-             }</span>
              tk = TokenKind.DOUBLELITERAL;
          }
      }
  
<span class="line-modified">!     /** Read fractional part and &#39;d&#39; or &#39;f&#39; suffix of floating point number.</span>
       */
      private void scanHexFractionAndSuffix(int pos, boolean seendigit) {
          radix = 16;
<span class="line-modified">!         Assert.check(reader.ch == &#39;.&#39;);</span>
<span class="line-modified">!         reader.putChar(true);</span>
          skipIllegalUnderscores();
<span class="line-modified">!         if (reader.digit(pos, 16) &gt;= 0) {</span>
              seendigit = true;
              scanDigits(pos, 16);
          }
          if (!seendigit)
              lexError(pos, Errors.InvalidHexNumber);
          else
              scanHexExponentAndSuffix(pos);
      }
  
      private void skipIllegalUnderscores() {
<span class="line-modified">!         if (reader.ch == &#39;_&#39;) {</span>
<span class="line-modified">!             lexError(reader.bp, Errors.IllegalUnderscore);</span>
<span class="line-modified">!             while (reader.ch == &#39;_&#39;)</span>
<span class="line-removed">-                 reader.scanChar();</span>
          }
      }
  
<span class="line-modified">!     /** Read a number.</span>
<span class="line-modified">!      *  @param radix  The radix of the number; one of 2, 8, 10, 16.</span>
       */
      private void scanNumber(int pos, int radix) {
          // for octal, allow base-10 digit in case it&#39;s a float literal
          this.radix = radix;
          int digitRadix = (radix == 8 ? 10 : radix);
<span class="line-modified">!         int firstDigit = reader.digit(pos, Math.max(10, digitRadix));</span>
          boolean seendigit = firstDigit &gt;= 0;
          boolean seenValidDigit = firstDigit &gt;= 0 &amp;&amp; firstDigit &lt; digitRadix;
          if (seendigit) {
              scanDigits(pos, digitRadix);
          }
<span class="line-modified">!         if (radix == 16 &amp;&amp; reader.ch == &#39;.&#39;) {</span>
              scanHexFractionAndSuffix(pos, seendigit);
<span class="line-modified">!         } else if (seendigit &amp;&amp; radix == 16 &amp;&amp; (reader.ch == &#39;p&#39; || reader.ch == &#39;P&#39;)) {</span>
              scanHexExponentAndSuffix(pos);
<span class="line-modified">!         } else if (digitRadix == 10 &amp;&amp; reader.ch == &#39;.&#39;) {</span>
<span class="line-modified">!             reader.putChar(true);</span>
              scanFractionAndSuffix(pos);
<span class="line-modified">!         } else if (digitRadix == 10 &amp;&amp;</span>
<span class="line-removed">-                    (reader.ch == &#39;e&#39; || reader.ch == &#39;E&#39; ||</span>
<span class="line-removed">-                     reader.ch == &#39;f&#39; || reader.ch == &#39;F&#39; ||</span>
<span class="line-removed">-                     reader.ch == &#39;d&#39; || reader.ch == &#39;D&#39;)) {</span>
              scanFractionAndSuffix(pos);
          } else {
              if (!seenValidDigit) {
                  switch (radix) {
                  case 2:
<span class="line-new-header">--- 182,452 ---</span>
              //use of preview feature, warn
              preview.warnPreview(pos, feature);
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Report an error at the given position using the provided arguments.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param pos  position in input buffer.</span>
<span class="line-added">+      * @param key  error key to report.</span>
       */
      protected void lexError(int pos, JCDiagnostic.Error key) {
          log.error(pos, key);
          tk = TokenKind.ERROR;
          errPos = pos;
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Report an error at the given position using the provided arguments.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param flags  diagnostic flags.</span>
<span class="line-added">+      * @param pos    position in input buffer.</span>
<span class="line-added">+      * @param key    error key to report.</span>
<span class="line-added">+      */</span>
      protected void lexError(DiagnosticFlag flags, int pos, JCDiagnostic.Error key) {
          log.error(flags, pos, key);
          tk = TokenKind.ERROR;
          errPos = pos;
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Report an error at the given position using the provided arguments.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param lc     lint category.</span>
<span class="line-added">+      * @param pos    position in input buffer.</span>
<span class="line-added">+      * @param key    error key to report.</span>
<span class="line-added">+      */</span>
      protected void lexWarning(LintCategory lc, int pos, JCDiagnostic.Warning key) {
          DiagnosticPosition dp = new SimpleDiagnosticPosition(pos) ;
          log.warning(lc, dp, key);
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Add a character to the literal buffer.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @param ch  character to add.</span>
       */
<span class="line-modified">!     protected void put(char ch) {</span>
<span class="line-modified">!         sb.append(ch);</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Add a codepoint to the literal buffer.</span>
<span class="line-modified">!      *</span>
<span class="line-added">+      * @param codePoint  codepoint to add.</span>
       */
<span class="line-modified">!     protected void putCodePoint(int codePoint) {</span>
<span class="line-modified">!         sb.appendCodePoint(codePoint);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Add current character or codepoint to the literal buffer.</span>
<span class="line-modified">!      */</span>
<span class="line-added">+     protected void put() {</span>
<span class="line-added">+         if (isSurrogate()) {</span>
<span class="line-added">+             putCodePoint(getCodepoint());</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             put(get());</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Add a string to the literal buffer.</span>
<span class="line-modified">!      */</span>
<span class="line-added">+     protected void put(String string) {</span>
<span class="line-added">+         sb.append(string);</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Add current character or codepoint to the literal buffer then return next character.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     protected char putThenNext() {</span>
<span class="line-modified">!         put();</span>
  
<span class="line-modified">!         return next();</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * If the specified character ch matches the current character then add current character</span>
<span class="line-modified">!      * to the literal buffer and then advance.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @param ch  character to match.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return true if ch matches current character.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     protected boolean acceptThenPut(char ch) {</span>
<span class="line-added">+         if (is(ch)) {</span>
<span class="line-added">+             put(get());</span>
<span class="line-added">+             next();</span>
  
<span class="line-modified">!             return true;</span>
          }
  
<span class="line-modified">!         return false;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * If either ch1 or ch2 matches the current character then add current character</span>
<span class="line-modified">!      * to the literal buffer and then advance.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @param ch1  first character to match.</span>
<span class="line-modified">!      * @param ch2  second character to match.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @return true if either ch1 or ch2 matches current character.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     protected boolean acceptOneOfThenPut(char ch1, char ch2) {</span>
<span class="line-modified">!         if (isOneOf(ch1, ch2)) {</span>
<span class="line-modified">!             put(get());</span>
<span class="line-modified">!             next();</span>
  
<span class="line-modified">!             return true;</span>
          }
  
<span class="line-modified">!         return false;</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Test if the current character is a line terminator.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return true if current character is a line terminator.</span>
       */
      private boolean isEOLN() {
<span class="line-modified">!         return isOneOf(&#39;\n&#39;, &#39;\r&#39;);</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Skip and process a line terminator sequence.</span>
       */
<span class="line-modified">!     private void skipLineTerminator() {</span>
<span class="line-modified">!         int start = position();</span>
<span class="line-added">+         accept(&#39;\r&#39;);</span>
<span class="line-added">+         accept(&#39;\n&#39;);</span>
<span class="line-added">+         processLineTerminator(start, position());</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Processes the current character and places in the literal buffer. If the current</span>
<span class="line-added">+      * character is a backslash then the next character is validated as a proper</span>
<span class="line-added">+      * escape character. Conversion of escape sequences takes place at end of nextToken().</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param pos position of the first character in literal.</span>
       */
<span class="line-modified">!     private void scanLitChar(int pos) {</span>
<span class="line-modified">!         if (acceptThenPut(&#39;\\&#39;)) {</span>
<span class="line-modified">!             hasEscapeSequences = true;</span>
  
<span class="line-modified">!             switch (get()) {</span>
<span class="line-modified">!                 case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;:</span>
<span class="line-modified">!                 case &#39;4&#39;: case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;:</span>
<span class="line-modified">!                     char leadch = get();</span>
<span class="line-modified">!                     putThenNext();</span>
<span class="line-modified">! </span>
<span class="line-added">+                     if (inRange(&#39;0&#39;, &#39;7&#39;)) {</span>
<span class="line-added">+                         putThenNext();</span>
<span class="line-added">+ </span>
<span class="line-added">+                         if (leadch &lt;= &#39;3&#39; &amp;&amp; inRange(&#39;0&#39;, &#39;7&#39;)) {</span>
<span class="line-added">+                             putThenNext();</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 case &#39;b&#39;:</span>
<span class="line-added">+                 case &#39;t&#39;:</span>
<span class="line-added">+                 case &#39;n&#39;:</span>
<span class="line-added">+                 case &#39;f&#39;:</span>
<span class="line-added">+                 case &#39;r&#39;:</span>
<span class="line-added">+                 case &#39;\&#39;&#39;:</span>
<span class="line-added">+                 case &#39;\&quot;&#39;:</span>
<span class="line-added">+                 case &#39;\\&#39;:</span>
<span class="line-added">+                     putThenNext();</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 case &#39;s&#39;:</span>
<span class="line-added">+                     checkSourceLevel(position(), Feature.TEXT_BLOCKS);</span>
<span class="line-added">+                     putThenNext();</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 case &#39;\n&#39;:</span>
<span class="line-added">+                 case &#39;\r&#39;:</span>
<span class="line-added">+                     if (isTextBlock) {</span>
<span class="line-added">+                         skipLineTerminator();</span>
<span class="line-added">+                         // Normalize line terminator.</span>
<span class="line-added">+                         put(&#39;\n&#39;);</span>
<span class="line-added">+                     } else {</span>
<span class="line-added">+                         lexError(position(), Errors.IllegalEscChar);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 default:</span>
<span class="line-added">+                     lexError(position(), Errors.IllegalEscChar);</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             putThenNext();</span>
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Scan a string literal or text block.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param pos  position of the first character in literal.</span>
       */
      private void scanString(int pos) {
<span class="line-modified">!         // Assume the best.</span>
<span class="line-modified">!         tk = Tokens.TokenKind.STRINGLITERAL;</span>
          // Track the end of first line for error recovery.
<span class="line-modified">!         int firstEOLN = NOT_FOUND;</span>
<span class="line-modified">!         // Check for text block delimiter.</span>
<span class="line-modified">!         isTextBlock = accept(&quot;\&quot;\&quot;\&quot;&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (isTextBlock) {</span>
              // Check if preview feature is enabled for text blocks.
              checkSourceLevel(pos, Feature.TEXT_BLOCKS);
<span class="line-modified">! </span>
              // Verify the open delimiter sequence.
<span class="line-modified">!             // Error if the open delimiter sequence is not &quot;&quot;&quot;&lt;white space&gt;*&lt;LineTerminator&gt;.</span>
<span class="line-modified">!             skipWhitespace();</span>
<span class="line-modified">! </span>
              if (isEOLN()) {
                  skipLineTerminator();
              } else {
<span class="line-modified">!                 lexError(position(), Errors.IllegalTextBlockOpen);</span>
                  return;
              }
<span class="line-modified">! </span>
<span class="line-modified">!             // While characters are available.</span>
<span class="line-modified">!             while (isAvailable()) {</span>
<span class="line-modified">!                 if (accept(&quot;\&quot;\&quot;\&quot;&quot;)) {</span>
                      return;
                  }
<span class="line-modified">! </span>
<span class="line-modified">!                 if (isEOLN()) {</span>
<span class="line-modified">!                     skipLineTerminator();</span>
<span class="line-modified">!                     // Add normalized line terminator to literal buffer.</span>
<span class="line-modified">!                     put(&#39;\n&#39;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     // Record first line terminator for error recovery.</span>
<span class="line-added">+                     if (firstEOLN == NOT_FOUND) {</span>
<span class="line-added">+                         firstEOLN = position();</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     // Add character to string buffer.</span>
<span class="line-added">+                     scanLitChar(pos);</span>
                  }
<span class="line-modified">!             }</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             // Skip first quote.</span>
<span class="line-modified">!             next();</span>
<span class="line-modified">! </span>
<span class="line-modified">!             // While characters are available.</span>
<span class="line-added">+             while (isAvailable()) {</span>
<span class="line-added">+                 if (accept(&#39;\&quot;&#39;)) {</span>
<span class="line-added">+                     return;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 if (isEOLN()) {</span>
<span class="line-added">+                     // Line terminator in string literal is an error.</span>
<span class="line-added">+                     // Fall out to unclosed string literal error.</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     // Add character to string buffer.</span>
<span class="line-added">+                     scanLitChar(pos);</span>
                  }
              }
          }
<span class="line-added">+ </span>
          // String ended without close delimiter sequence.
<span class="line-modified">!         lexError(pos, isTextBlock ? Errors.UnclosedTextBlock : Errors.UnclosedStrLit);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (firstEOLN  != NOT_FOUND) {</span>
<span class="line-modified">!             // Reset recovery position to point after text block open delimiter sequence.</span>
<span class="line-added">+             reset(firstEOLN);</span>
          }
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Scan sequence of digits.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param pos         position of the first character in literal.</span>
<span class="line-added">+      * @param digitRadix  radix of numeric literal.</span>
<span class="line-added">+      */</span>
      private void scanDigits(int pos, int digitRadix) {
<span class="line-modified">!         int leadingUnderscorePos = is(&#39;_&#39;) ? position() : NOT_FOUND;</span>
<span class="line-modified">!         int trailingUnderscorePos;</span>
<span class="line-added">+ </span>
          do {
<span class="line-modified">!             if (!is(&#39;_&#39;)) {</span>
<span class="line-modified">!                 put();</span>
<span class="line-added">+                 trailingUnderscorePos = NOT_FOUND;</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 trailingUnderscorePos = position();</span>
              }
<span class="line-modified">! </span>
<span class="line-modified">!             next();</span>
<span class="line-modified">!         } while (digit(pos, digitRadix) &gt;= 0 || is(&#39;_&#39;));</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (leadingUnderscorePos != NOT_FOUND) {</span>
<span class="line-modified">!             lexError(leadingUnderscorePos, Errors.IllegalUnderscore);</span>
<span class="line-added">+         } else if (trailingUnderscorePos != NOT_FOUND) {</span>
<span class="line-added">+             lexError(trailingUnderscorePos, Errors.IllegalUnderscore);</span>
<span class="line-added">+         }</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Read fractional part of hexadecimal floating point number.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param pos  position of the first character in literal.</span>
       */
      private void scanHexExponentAndSuffix(int pos) {
<span class="line-modified">!         if (acceptOneOfThenPut(&#39;p&#39;, &#39;P&#39;)) {</span>
              skipIllegalUnderscores();
<span class="line-modified">!             acceptOneOfThenPut(&#39;+&#39;, &#39;-&#39;);</span>
              skipIllegalUnderscores();
<span class="line-modified">! </span>
<span class="line-added">+             if (digit(pos, 10) &gt;= 0) {</span>
                  scanDigits(pos, 10);
<span class="line-modified">!             } else {</span>
                  lexError(pos, Errors.MalformedFpLit);
<span class="line-added">+             }</span>
          } else {
              lexError(pos, Errors.MalformedFpLit);
          }
<span class="line-modified">! </span>
<span class="line-modified">!         if (acceptOneOfThenPut(&#39;f&#39;, &#39;F&#39;)) {</span>
              tk = TokenKind.FLOATLITERAL;
              radix = 16;
          } else {
<span class="line-modified">!             acceptOneOfThenPut(&#39;d&#39;, &#39;D&#39;);</span>
              tk = TokenKind.DOUBLELITERAL;
              radix = 16;
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Read fractional part of floating point number.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param pos  position of the first character in literal.</span>
       */
      private void scanFraction(int pos) {
          skipIllegalUnderscores();
<span class="line-modified">! </span>
<span class="line-added">+         if (digit(pos, 10) &gt;= 0) {</span>
              scanDigits(pos, 10);
          }
<span class="line-modified">! </span>
<span class="line-modified">!         int index = sb.length();</span>
<span class="line-modified">! </span>
<span class="line-added">+         if (acceptOneOfThenPut(&#39;e&#39;, &#39;E&#39;)) {</span>
              skipIllegalUnderscores();
<span class="line-modified">!             acceptOneOfThenPut(&#39;+&#39;, &#39;-&#39;);</span>
              skipIllegalUnderscores();
<span class="line-modified">! </span>
<span class="line-added">+             if (digit(pos, 10) &gt;= 0) {</span>
                  scanDigits(pos, 10);
                  return;
              }
<span class="line-added">+ </span>
              lexError(pos, Errors.MalformedFpLit);
<span class="line-modified">!             sb.setLength(index);</span>
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Read fractional part and &#39;d&#39; or &#39;f&#39; suffix of floating point number.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param pos  position of the first character in literal.</span>
       */
      private void scanFractionAndSuffix(int pos) {
          radix = 10;
          scanFraction(pos);
<span class="line-modified">! </span>
<span class="line-modified">!         if (acceptOneOfThenPut(&#39;f&#39;, &#39;F&#39;)) {</span>
<span class="line-modified">!              tk = TokenKind.FLOATLITERAL;</span>
          } else {
<span class="line-modified">!             acceptOneOfThenPut(&#39;d&#39;, &#39;D&#39;);</span>
              tk = TokenKind.DOUBLELITERAL;
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Read fractional part and &#39;d&#39; or &#39;f&#39; suffix of hexadecimal floating point number.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param pos  position of the first character in literal.</span>
       */
      private void scanHexFractionAndSuffix(int pos, boolean seendigit) {
          radix = 16;
<span class="line-modified">!         Assert.check(is(&#39;.&#39;));</span>
<span class="line-modified">!         putThenNext();</span>
          skipIllegalUnderscores();
<span class="line-modified">! </span>
<span class="line-added">+         if (digit(pos, 16) &gt;= 0) {</span>
              seendigit = true;
              scanDigits(pos, 16);
          }
<span class="line-added">+ </span>
          if (!seendigit)
              lexError(pos, Errors.InvalidHexNumber);
          else
              scanHexExponentAndSuffix(pos);
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Skip over underscores and report as a error if found.</span>
<span class="line-added">+      */</span>
      private void skipIllegalUnderscores() {
<span class="line-modified">!         if (is(&#39;_&#39;)) {</span>
<span class="line-modified">!             lexError(position(), Errors.IllegalUnderscore);</span>
<span class="line-modified">!             skip(&#39;_&#39;);</span>
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Read a number. (Spec. 3.10)</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param pos    position of the first character in literal.</span>
<span class="line-added">+      * @param radix  the radix of the number; one of 2, 8, 10, 16.</span>
       */
      private void scanNumber(int pos, int radix) {
          // for octal, allow base-10 digit in case it&#39;s a float literal
          this.radix = radix;
          int digitRadix = (radix == 8 ? 10 : radix);
<span class="line-modified">!         int firstDigit = digit(pos, Math.max(10, digitRadix));</span>
          boolean seendigit = firstDigit &gt;= 0;
          boolean seenValidDigit = firstDigit &gt;= 0 &amp;&amp; firstDigit &lt; digitRadix;
<span class="line-added">+ </span>
          if (seendigit) {
              scanDigits(pos, digitRadix);
          }
<span class="line-modified">! </span>
<span class="line-added">+         if (radix == 16 &amp;&amp; is(&#39;.&#39;)) {</span>
              scanHexFractionAndSuffix(pos, seendigit);
<span class="line-modified">!         } else if (seendigit &amp;&amp; radix == 16 &amp;&amp; isOneOf(&#39;p&#39;, &#39;P&#39;)) {</span>
              scanHexExponentAndSuffix(pos);
<span class="line-modified">!         } else if (digitRadix == 10 &amp;&amp; is(&#39;.&#39;)) {</span>
<span class="line-modified">!             putThenNext();</span>
              scanFractionAndSuffix(pos);
<span class="line-modified">!         } else if (digitRadix == 10 &amp;&amp; isOneOf(&#39;e&#39;, &#39;E&#39;, &#39;f&#39;, &#39;F&#39;, &#39;d&#39;, &#39;D&#39;)) {</span>
              scanFractionAndSuffix(pos);
          } else {
              if (!seenValidDigit) {
                  switch (radix) {
                  case 2:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 643,27 ***</span>
                  case 16:
                      lexError(pos, Errors.InvalidHexNumber);
                      break;
                  }
              }
<span class="line-modified">!             if (reader.ch == &#39;l&#39; || reader.ch == &#39;L&#39;) {</span>
<span class="line-modified">!                 reader.scanChar();</span>
                  tk = TokenKind.LONGLITERAL;
              } else {
                  tk = TokenKind.INTLITERAL;
              }
          }
      }
  
<span class="line-modified">!     /** Read an identifier.</span>
       */
      private void scanIdent() {
<span class="line-modified">!         boolean isJavaIdentifierPart;</span>
<span class="line-modified">!         char high;</span>
<span class="line-removed">-         reader.putChar(true);</span>
          do {
<span class="line-modified">!             switch (reader.ch) {</span>
              case &#39;A&#39;: case &#39;B&#39;: case &#39;C&#39;: case &#39;D&#39;: case &#39;E&#39;:
              case &#39;F&#39;: case &#39;G&#39;: case &#39;H&#39;: case &#39;I&#39;: case &#39;J&#39;:
              case &#39;K&#39;: case &#39;L&#39;: case &#39;M&#39;: case &#39;N&#39;: case &#39;O&#39;:
              case &#39;P&#39;: case &#39;Q&#39;: case &#39;R&#39;: case &#39;S&#39;: case &#39;T&#39;:
              case &#39;U&#39;: case &#39;V&#39;: case &#39;W&#39;: case &#39;X&#39;: case &#39;Y&#39;:
<span class="line-new-header">--- 636,35 ---</span>
                  case 16:
                      lexError(pos, Errors.InvalidHexNumber);
                      break;
                  }
              }
<span class="line-modified">! </span>
<span class="line-modified">!             if (acceptOneOf(&#39;l&#39;, &#39;L&#39;)) {</span>
                  tk = TokenKind.LONGLITERAL;
              } else {
                  tk = TokenKind.INTLITERAL;
              }
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Determines if the sequence in the literal buffer is a token (keyword, operator.)</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private void checkIdent() {</span>
<span class="line-added">+         name = names.fromString(sb.toString());</span>
<span class="line-added">+         tk = tokens.lookupKind(name);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Read an identifier. (Spec. 3.8)</span>
       */
      private void scanIdent() {
<span class="line-modified">!         putThenNext();</span>
<span class="line-modified">! </span>
          do {
<span class="line-modified">!             switch (get()) {</span>
              case &#39;A&#39;: case &#39;B&#39;: case &#39;C&#39;: case &#39;D&#39;: case &#39;E&#39;:
              case &#39;F&#39;: case &#39;G&#39;: case &#39;H&#39;: case &#39;I&#39;: case &#39;J&#39;:
              case &#39;K&#39;: case &#39;L&#39;: case &#39;M&#39;: case &#39;N&#39;: case &#39;O&#39;:
              case &#39;P&#39;: case &#39;Q&#39;: case &#39;R&#39;: case &#39;S&#39;: case &#39;T&#39;:
              case &#39;U&#39;: case &#39;V&#39;: case &#39;W&#39;: case &#39;X&#39;: case &#39;Y&#39;:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 676,123 ***</span>
              case &#39;z&#39;:
              case &#39;$&#39;: case &#39;_&#39;:
              case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
              case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:
                  break;
              case &#39;\u0000&#39;: case &#39;\u0001&#39;: case &#39;\u0002&#39;: case &#39;\u0003&#39;:
              case &#39;\u0004&#39;: case &#39;\u0005&#39;: case &#39;\u0006&#39;: case &#39;\u0007&#39;:
              case &#39;\u0008&#39;: case &#39;\u000E&#39;: case &#39;\u000F&#39;: case &#39;\u0010&#39;:
              case &#39;\u0011&#39;: case &#39;\u0012&#39;: case &#39;\u0013&#39;: case &#39;\u0014&#39;:
              case &#39;\u0015&#39;: case &#39;\u0016&#39;: case &#39;\u0017&#39;:
              case &#39;\u0018&#39;: case &#39;\u0019&#39;: case &#39;\u001B&#39;:
              case &#39;\u007F&#39;:
<span class="line-modified">!                 reader.scanChar();</span>
                  continue;
              case &#39;\u001A&#39;: // EOI is also a legal identifier part
<span class="line-modified">!                 if (reader.bp &gt;= reader.buflen) {</span>
<span class="line-modified">!                     name = reader.name();</span>
<span class="line-modified">!                     tk = tokens.lookupKind(name);</span>
<span class="line-removed">-                     return;</span>
                  }
<span class="line-modified">!                 reader.scanChar();</span>
<span class="line-modified">!                 continue;</span>
              default:
<span class="line-modified">!                 if (reader.ch &lt; &#39;\u0080&#39;) {</span>
                      // all ASCII range chars already handled, above
                      isJavaIdentifierPart = false;
                  } else {
<span class="line-modified">!                     if (Character.isIdentifierIgnorable(reader.ch)) {</span>
<span class="line-modified">!                         reader.scanChar();</span>
                          continue;
<span class="line-removed">-                     } else {</span>
<span class="line-removed">-                         int codePoint = reader.peekSurrogates();</span>
<span class="line-removed">-                         if (codePoint &gt;= 0) {</span>
<span class="line-removed">-                             if (isJavaIdentifierPart = Character.isJavaIdentifierPart(codePoint)) {</span>
<span class="line-removed">-                                 reader.putChar(true);</span>
<span class="line-removed">-                             }</span>
<span class="line-removed">-                         } else {</span>
<span class="line-removed">-                             isJavaIdentifierPart = Character.isJavaIdentifierPart(reader.ch);</span>
<span class="line-removed">-                         }</span>
                      }
                  }
                  if (!isJavaIdentifierPart) {
<span class="line-modified">!                     name = reader.name();</span>
<span class="line-removed">-                     tk = tokens.lookupKind(name);</span>
                      return;
                  }
              }
<span class="line-modified">!             reader.putChar(true);</span>
          } while (true);
      }
  
<span class="line-modified">!     /** Return true if reader.ch can be part of an operator.</span>
       */
      private boolean isSpecial(char ch) {
          switch (ch) {
          case &#39;!&#39;: case &#39;%&#39;: case &#39;&amp;&#39;: case &#39;*&#39;: case &#39;?&#39;:
          case &#39;+&#39;: case &#39;-&#39;: case &#39;:&#39;: case &#39;&lt;&#39;: case &#39;=&#39;:
          case &#39;&gt;&#39;: case &#39;^&#39;: case &#39;|&#39;: case &#39;~&#39;:
          case &#39;@&#39;:
              return true;
          default:
              return false;
          }
      }
  
<span class="line-modified">!     /** Read longest possible sequence of special characters and convert</span>
<span class="line-modified">!      *  to token.</span>
       */
      private void scanOperator() {
          while (true) {
<span class="line-modified">!             reader.putChar(false);</span>
<span class="line-modified">!             Name newname = reader.name();</span>
<span class="line-modified">!             TokenKind tk1 = tokens.lookupKind(newname);</span>
<span class="line-modified">!             if (tk1 == TokenKind.IDENTIFIER) {</span>
<span class="line-modified">!                 reader.sp--;</span>
                  break;
              }
<span class="line-removed">-             tk = tk1;</span>
<span class="line-removed">-             reader.scanChar();</span>
<span class="line-removed">-             if (!isSpecial(reader.ch)) break;</span>
          }
      }
  
<span class="line-modified">!     /** Read token.</span>
       */
      public Token readToken() {
<span class="line-modified">! </span>
<span class="line-removed">-         reader.sp = 0;</span>
          name = null;
          radix = 0;
  
<span class="line-modified">!         int pos = 0;</span>
<span class="line-removed">-         int endPos = 0;</span>
          List&lt;Comment&gt; comments = null;
  
          try {
              loop: while (true) {
<span class="line-modified">!                 pos = reader.bp;</span>
<span class="line-modified">!                 switch (reader.ch) {</span>
<span class="line-modified">!                 case &#39; &#39;: // (Spec 3.6)</span>
                  case &#39;\t&#39;: // (Spec 3.6)
<span class="line-modified">!                 case FF: // (Spec 3.6)</span>
<span class="line-modified">!                     do {</span>
<span class="line-modified">!                         reader.scanChar();</span>
<span class="line-removed">-                     } while (reader.ch == &#39; &#39; || reader.ch == &#39;\t&#39; || reader.ch == FF);</span>
<span class="line-removed">-                     processWhiteSpace(pos, reader.bp);</span>
                      break;
<span class="line-modified">!                 case LF: // (Spec 3.4)</span>
<span class="line-modified">!                     reader.scanChar();</span>
<span class="line-modified">!                     processLineTerminator(pos, reader.bp);</span>
                      break;
<span class="line-modified">!                 case CR: // (Spec 3.4)</span>
<span class="line-modified">!                     reader.scanChar();</span>
<span class="line-modified">!                     if (reader.ch == LF) {</span>
<span class="line-modified">!                         reader.scanChar();</span>
<span class="line-modified">!                     }</span>
<span class="line-removed">-                     processLineTerminator(pos, reader.bp);</span>
                      break;
                  case &#39;A&#39;: case &#39;B&#39;: case &#39;C&#39;: case &#39;D&#39;: case &#39;E&#39;:
                  case &#39;F&#39;: case &#39;G&#39;: case &#39;H&#39;: case &#39;I&#39;: case &#39;J&#39;:
                  case &#39;K&#39;: case &#39;L&#39;: case &#39;M&#39;: case &#39;N&#39;: case &#39;O&#39;:
                  case &#39;P&#39;: case &#39;Q&#39;: case &#39;R&#39;: case &#39;S&#39;: case &#39;T&#39;:
                  case &#39;U&#39;: case &#39;V&#39;: case &#39;W&#39;: case &#39;X&#39;: case &#39;Y&#39;:
<span class="line-new-header">--- 677,135 ---</span>
              case &#39;z&#39;:
              case &#39;$&#39;: case &#39;_&#39;:
              case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
              case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:
                  break;
<span class="line-added">+ </span>
              case &#39;\u0000&#39;: case &#39;\u0001&#39;: case &#39;\u0002&#39;: case &#39;\u0003&#39;:
              case &#39;\u0004&#39;: case &#39;\u0005&#39;: case &#39;\u0006&#39;: case &#39;\u0007&#39;:
              case &#39;\u0008&#39;: case &#39;\u000E&#39;: case &#39;\u000F&#39;: case &#39;\u0010&#39;:
              case &#39;\u0011&#39;: case &#39;\u0012&#39;: case &#39;\u0013&#39;: case &#39;\u0014&#39;:
              case &#39;\u0015&#39;: case &#39;\u0016&#39;: case &#39;\u0017&#39;:
              case &#39;\u0018&#39;: case &#39;\u0019&#39;: case &#39;\u001B&#39;:
              case &#39;\u007F&#39;:
<span class="line-modified">!                 next();</span>
                  continue;
<span class="line-added">+ </span>
              case &#39;\u001A&#39;: // EOI is also a legal identifier part
<span class="line-modified">!                 if (isAvailable()) {</span>
<span class="line-modified">!                     next();</span>
<span class="line-modified">!                     continue;</span>
                  }
<span class="line-modified">! </span>
<span class="line-modified">!                 checkIdent();</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+ </span>
              default:
<span class="line-modified">!                 boolean isJavaIdentifierPart;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 if (isASCII()) {</span>
                      // all ASCII range chars already handled, above
                      isJavaIdentifierPart = false;
                  } else {
<span class="line-modified">!                     if (Character.isIdentifierIgnorable(get())) {</span>
<span class="line-modified">!                         next();</span>
                          continue;
                      }
<span class="line-added">+ </span>
<span class="line-added">+                     isJavaIdentifierPart = isSurrogate()</span>
<span class="line-added">+                             ? Character.isJavaIdentifierPart(getCodepoint())</span>
<span class="line-added">+                             : Character.isJavaIdentifierPart(get());</span>
                  }
<span class="line-added">+ </span>
                  if (!isJavaIdentifierPart) {
<span class="line-modified">!                     checkIdent();</span>
                      return;
                  }
              }
<span class="line-modified">! </span>
<span class="line-added">+             putThenNext();</span>
          } while (true);
      }
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Return true if ch can be part of an operator.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param ch  character to check.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return true if ch can be part of an operator.</span>
       */
      private boolean isSpecial(char ch) {
          switch (ch) {
          case &#39;!&#39;: case &#39;%&#39;: case &#39;&amp;&#39;: case &#39;*&#39;: case &#39;?&#39;:
          case &#39;+&#39;: case &#39;-&#39;: case &#39;:&#39;: case &#39;&lt;&#39;: case &#39;=&#39;:
          case &#39;&gt;&#39;: case &#39;^&#39;: case &#39;|&#39;: case &#39;~&#39;:
          case &#39;@&#39;:
              return true;
<span class="line-added">+ </span>
          default:
              return false;
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Read longest possible sequence of special characters and convert to token.</span>
       */
      private void scanOperator() {
          while (true) {
<span class="line-modified">!             put();</span>
<span class="line-modified">!             TokenKind newtk = tokens.lookupKind(sb.toString());</span>
<span class="line-modified">! </span>
<span class="line-modified">!             if (newtk == TokenKind.IDENTIFIER) {</span>
<span class="line-modified">!                 sb.setLength(sb.length() - 1);</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             tk = newtk;</span>
<span class="line-added">+             next();</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (!isSpecial(get())) {</span>
                  break;
              }
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Read token (main entrypoint.)</span>
       */
      public Token readToken() {
<span class="line-modified">!         sb.setLength(0);</span>
          name = null;
          radix = 0;
<span class="line-added">+         isTextBlock = false;</span>
<span class="line-added">+         hasEscapeSequences = false;</span>
  
<span class="line-modified">!         int pos;</span>
          List&lt;Comment&gt; comments = null;
  
          try {
              loop: while (true) {
<span class="line-modified">!                 pos = position();</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 switch (get()) {</span>
<span class="line-added">+                 case &#39; &#39;:  // (Spec 3.6)</span>
                  case &#39;\t&#39;: // (Spec 3.6)
<span class="line-modified">!                 case &#39;\f&#39;: // (Spec 3.6)</span>
<span class="line-modified">!                     skipWhitespace();</span>
<span class="line-modified">!                     processWhiteSpace(pos, position());</span>
                      break;
<span class="line-modified">! </span>
<span class="line-modified">!                 case &#39;\n&#39;: // (Spec 3.4)</span>
<span class="line-modified">!                     next();</span>
<span class="line-added">+                     processLineTerminator(pos, position());</span>
                      break;
<span class="line-modified">! </span>
<span class="line-modified">!                 case &#39;\r&#39;: // (Spec 3.4)</span>
<span class="line-modified">!                     next();</span>
<span class="line-modified">!                     accept(&#39;\n&#39;);</span>
<span class="line-modified">!                     processLineTerminator(pos, position());</span>
                      break;
<span class="line-added">+ </span>
                  case &#39;A&#39;: case &#39;B&#39;: case &#39;C&#39;: case &#39;D&#39;: case &#39;E&#39;:
                  case &#39;F&#39;: case &#39;G&#39;: case &#39;H&#39;: case &#39;I&#39;: case &#39;J&#39;:
                  case &#39;K&#39;: case &#39;L&#39;: case &#39;M&#39;: case &#39;N&#39;: case &#39;O&#39;:
                  case &#39;P&#39;: case &#39;Q&#39;: case &#39;R&#39;: case &#39;S&#39;: case &#39;T&#39;:
                  case &#39;U&#39;: case &#39;V&#39;: case &#39;W&#39;: case &#39;X&#39;: case &#39;Y&#39;:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 801,419 ***</span>
                  case &#39;f&#39;: case &#39;g&#39;: case &#39;h&#39;: case &#39;i&#39;: case &#39;j&#39;:
                  case &#39;k&#39;: case &#39;l&#39;: case &#39;m&#39;: case &#39;n&#39;: case &#39;o&#39;:
                  case &#39;p&#39;: case &#39;q&#39;: case &#39;r&#39;: case &#39;s&#39;: case &#39;t&#39;:
                  case &#39;u&#39;: case &#39;v&#39;: case &#39;w&#39;: case &#39;x&#39;: case &#39;y&#39;:
                  case &#39;z&#39;:
<span class="line-modified">!                 case &#39;$&#39;: case &#39;_&#39;:</span>
                      scanIdent();
                      break loop;
<span class="line-modified">!                 case &#39;0&#39;:</span>
<span class="line-modified">!                     reader.scanChar();</span>
<span class="line-modified">!                     if (reader.ch == &#39;x&#39; || reader.ch == &#39;X&#39;) {</span>
<span class="line-modified">!                         reader.scanChar();</span>
                          skipIllegalUnderscores();
                          scanNumber(pos, 16);
<span class="line-modified">!                     } else if (reader.ch == &#39;b&#39; || reader.ch == &#39;B&#39;) {</span>
<span class="line-removed">-                         reader.scanChar();</span>
                          skipIllegalUnderscores();
                          scanNumber(pos, 2);
                      } else {
<span class="line-modified">!                         reader.putChar(&#39;0&#39;);</span>
<span class="line-modified">!                         if (reader.ch == &#39;_&#39;) {</span>
<span class="line-modified">!                             int savePos = reader.bp;</span>
<span class="line-modified">!                             do {</span>
<span class="line-modified">!                                 reader.scanChar();</span>
<span class="line-modified">!                             } while (reader.ch == &#39;_&#39;);</span>
<span class="line-modified">!                             if (reader.digit(pos, 10) &lt; 0) {</span>
                                  lexError(savePos, Errors.IllegalUnderscore);
                              }
                          }
                          scanNumber(pos, 8);
                      }
                      break loop;
                  case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
<span class="line-modified">!                 case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:</span>
                      scanNumber(pos, 10);
                      break loop;
<span class="line-modified">!                 case &#39;.&#39;:</span>
<span class="line-modified">!                     reader.scanChar();</span>
<span class="line-modified">!                     if (reader.digit(pos, 10) &gt;= 0) {</span>
<span class="line-modified">!                         reader.putChar(&#39;.&#39;);</span>
<span class="line-modified">!                         scanFractionAndSuffix(pos);</span>
<span class="line-modified">!                     } else if (reader.ch == &#39;.&#39;) {</span>
<span class="line-modified">!                         int savePos = reader.bp;</span>
<span class="line-modified">!                         reader.putChar(&#39;.&#39;); reader.putChar(&#39;.&#39;, true);</span>
<span class="line-modified">!                         if (reader.ch == &#39;.&#39;) {</span>
<span class="line-modified">!                             reader.scanChar();</span>
<span class="line-removed">-                             reader.putChar(&#39;.&#39;);</span>
<span class="line-removed">-                             tk = TokenKind.ELLIPSIS;</span>
<span class="line-removed">-                         } else {</span>
                              lexError(savePos, Errors.IllegalDot);
                          }
<span class="line-removed">-                     } else {</span>
<span class="line-removed">-                         tk = TokenKind.DOT;</span>
                      }
                      break loop;
<span class="line-modified">!                 case &#39;,&#39;:</span>
<span class="line-modified">!                     reader.scanChar(); tk = TokenKind.COMMA; break loop;</span>
<span class="line-modified">!                 case &#39;;&#39;:</span>
<span class="line-modified">!                     reader.scanChar(); tk = TokenKind.SEMI; break loop;</span>
<span class="line-modified">!                 case &#39;(&#39;:</span>
<span class="line-modified">!                     reader.scanChar(); tk = TokenKind.LPAREN; break loop;</span>
<span class="line-modified">!                 case &#39;)&#39;:</span>
<span class="line-modified">!                     reader.scanChar(); tk = TokenKind.RPAREN; break loop;</span>
<span class="line-modified">!                 case &#39;[&#39;:</span>
<span class="line-modified">!                     reader.scanChar(); tk = TokenKind.LBRACKET; break loop;</span>
<span class="line-modified">!                 case &#39;]&#39;:</span>
<span class="line-modified">!                     reader.scanChar(); tk = TokenKind.RBRACKET; break loop;</span>
<span class="line-modified">!                 case &#39;{&#39;:</span>
<span class="line-modified">!                     reader.scanChar(); tk = TokenKind.LBRACE; break loop;</span>
<span class="line-modified">!                 case &#39;}&#39;:</span>
<span class="line-modified">!                     reader.scanChar(); tk = TokenKind.RBRACE; break loop;</span>
                  case &#39;/&#39;:
<span class="line-modified">!                     reader.scanChar();</span>
<span class="line-modified">!                     if (reader.ch == &#39;/&#39;) {</span>
<span class="line-modified">!                         do {</span>
<span class="line-modified">!                             reader.scanCommentChar();</span>
<span class="line-modified">!                         } while (reader.ch != CR &amp;&amp; reader.ch != LF &amp;&amp; reader.bp &lt; reader.buflen);</span>
<span class="line-modified">!                         if (reader.bp &lt; reader.buflen) {</span>
<span class="line-modified">!                             comments = addComment(comments, processComment(pos, reader.bp, CommentStyle.LINE));</span>
                          }
                          break;
<span class="line-modified">!                     } else if (reader.ch == &#39;*&#39;) {</span>
                          boolean isEmpty = false;
<span class="line-removed">-                         reader.scanChar();</span>
                          CommentStyle style;
<span class="line-modified">!                         if (reader.ch == &#39;*&#39;) {</span>
                              style = CommentStyle.JAVADOC;
<span class="line-modified">!                             reader.scanCommentChar();</span>
<span class="line-modified">!                             if (reader.ch == &#39;/&#39;) {</span>
                                  isEmpty = true;
                              }
                          } else {
                              style = CommentStyle.BLOCK;
                          }
<span class="line-modified">!                         while (!isEmpty &amp;&amp; reader.bp &lt; reader.buflen) {</span>
<span class="line-modified">!                             if (reader.ch == &#39;*&#39;) {</span>
<span class="line-modified">!                                 reader.scanChar();</span>
<span class="line-modified">!                                 if (reader.ch == &#39;/&#39;) break;</span>
<span class="line-modified">!                             } else {</span>
<span class="line-modified">!                                 reader.scanCommentChar();</span>
                              }
                          }
<span class="line-modified">!                         if (reader.ch == &#39;/&#39;) {</span>
<span class="line-modified">!                             reader.scanChar();</span>
<span class="line-modified">!                             comments = addComment(comments, processComment(pos, reader.bp, style));</span>
                              break;
                          } else {
                              lexError(pos, Errors.UnclosedComment);
                              break loop;
                          }
<span class="line-modified">!                     } else if (reader.ch == &#39;=&#39;) {</span>
<span class="line-modified">!                         tk = TokenKind.SLASHEQ;</span>
<span class="line-removed">-                         reader.scanChar();</span>
                      } else {
<span class="line-modified">!                         tk = TokenKind.SLASH;</span>
                      }
                      break loop;
<span class="line-modified">!                 case &#39;\&#39;&#39;:</span>
<span class="line-modified">!                     reader.scanChar();</span>
<span class="line-modified">!                     if (reader.ch == &#39;\&#39;&#39;) {</span>
                          lexError(pos, Errors.EmptyCharLit);
<span class="line-removed">-                         reader.scanChar();</span>
                      } else {
<span class="line-modified">!                         if (isEOLN())</span>
                              lexError(pos, Errors.IllegalLineEndInCharLit);
<span class="line-modified">!                         scanLitChar(pos, true, false);</span>
<span class="line-modified">!                         if (reader.ch == &#39;\&#39;&#39;) {</span>
<span class="line-modified">!                             reader.scanChar();</span>
                              tk = TokenKind.CHARLITERAL;
                          } else {
                              lexError(pos, Errors.UnclosedCharLit);
                          }
                      }
                      break loop;
<span class="line-modified">!                 case &#39;\&quot;&#39;:</span>
                      scanString(pos);
                      break loop;
                  default:
<span class="line-modified">!                     if (isSpecial(reader.ch)) {</span>
                          scanOperator();
                      } else {
                          boolean isJavaIdentifierStart;
<span class="line-modified">!                         int codePoint = -1;</span>
<span class="line-modified">!                         if (reader.ch &lt; &#39;\u0080&#39;) {</span>
                              // all ASCII range chars already handled, above
                              isJavaIdentifierStart = false;
                          } else {
<span class="line-modified">!                             codePoint = reader.peekSurrogates();</span>
<span class="line-modified">!                             if (codePoint &gt;= 0) {</span>
<span class="line-modified">!                                 if (isJavaIdentifierStart = Character.isJavaIdentifierStart(codePoint)) {</span>
<span class="line-removed">-                                     reader.putChar(true);</span>
<span class="line-removed">-                                 }</span>
<span class="line-removed">-                             } else {</span>
<span class="line-removed">-                                 isJavaIdentifierStart = Character.isJavaIdentifierStart(reader.ch);</span>
<span class="line-removed">-                             }</span>
                          }
                          if (isJavaIdentifierStart) {
                              scanIdent();
<span class="line-modified">!                         } else if (reader.digit(pos, 10) &gt;= 0) {</span>
                              scanNumber(pos, 10);
<span class="line-modified">!                         } else if (reader.bp == reader.buflen || reader.ch == EOI &amp;&amp; reader.bp + 1 == reader.buflen) { // JLS 3.5</span>
                              tk = TokenKind.EOF;
<span class="line-modified">!                             pos = reader.realLength;</span>
                          } else {
                              String arg;
  
<span class="line-modified">!                             if (codePoint &gt;= 0) {</span>
<span class="line-modified">!                                 char high = reader.ch;</span>
<span class="line-modified">!                                 reader.scanChar();</span>
<span class="line-modified">!                                 arg = String.format(&quot;\\u%04x\\u%04x&quot;, (int) high, (int)reader.ch);</span>
                              } else {
<span class="line-modified">!                                 arg = (32 &lt; reader.ch &amp;&amp; reader.ch &lt; 127) ?</span>
<span class="line-modified">!                                                 String.format(&quot;%s&quot;, reader.ch) :</span>
<span class="line-modified">!                                                 String.format(&quot;\\u%04x&quot;, (int)reader.ch);</span>
                              }
                              lexError(pos, Errors.IllegalChar(arg));
<span class="line-modified">!                             reader.scanChar();</span>
                          }
                      }
                      break loop;
                  }
              }
<span class="line-modified">!             endPos = reader.bp;</span>
<span class="line-modified">!             switch (tk.tag) {</span>
<span class="line-modified">!                 case DEFAULT: return new Token(tk, pos, endPos, comments);</span>
<span class="line-modified">!                 case NAMED: return new NamedToken(tk, pos, endPos, name, comments);</span>
<span class="line-modified">!                 case STRING: {</span>
<span class="line-modified">!                     // Get characters from string buffer.</span>
<span class="line-modified">!                     String string = reader.chars();</span>
<span class="line-modified">!                     // If a text block.</span>
<span class="line-modified">!                     if (isTextBlock &amp;&amp; TextBlockSupport.hasSupport()) {</span>
<span class="line-modified">!                         // Verify that the incidental indentation is consistent.</span>
<span class="line-modified">!                         if (lint.isEnabled(LintCategory.TEXT_BLOCKS)) {</span>
<span class="line-modified">!                             Set&lt;TextBlockSupport.WhitespaceChecks&gt; checks =</span>
<span class="line-modified">!                                     TextBlockSupport.checkWhitespace(string);</span>
<span class="line-modified">!                             if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {</span>
<span class="line-modified">!                                 lexWarning(LintCategory.TEXT_BLOCKS, pos,</span>
<span class="line-modified">!                                         Warnings.InconsistentWhiteSpaceIndentation);</span>
<span class="line-modified">!                             }</span>
<span class="line-modified">!                             if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {</span>
<span class="line-modified">!                                 lexWarning(LintCategory.TEXT_BLOCKS, pos,</span>
<span class="line-modified">!                                         Warnings.TrailingWhiteSpaceWillBeRemoved);</span>
<span class="line-removed">-                             }</span>
                          }
<span class="line-modified">!                         // Remove incidental indentation.</span>
<span class="line-modified">!                         try {</span>
<span class="line-modified">!                             string = TextBlockSupport.stripIndent(string);</span>
<span class="line-removed">-                         } catch (Exception ex) {</span>
<span class="line-removed">-                             // Error already reported, just use unstripped string.</span>
                          }
                      }
<span class="line-modified">!                     // Translate escape sequences if present.</span>
<span class="line-modified">!                     if (hasEscapeSequences &amp;&amp; TextBlockSupport.hasSupport()) {</span>
<span class="line-modified">!                         try {</span>
<span class="line-modified">!                             string = TextBlockSupport.translateEscapes(string);</span>
<span class="line-modified">!                         } catch (Exception ex) {</span>
<span class="line-modified">!                             // Error already reported, just use untranslated string.</span>
<span class="line-modified">!                         }</span>
                      }
                      // Build string token.
                      return new StringToken(tk, pos, endPos, string, comments);
                  }
<span class="line-removed">-                 case NUMERIC: return new NumericToken(tk, pos, endPos, reader.chars(), radix, comments);</span>
<span class="line-removed">-                 default: throw new AssertionError();</span>
              }
<span class="line-modified">!         }</span>
<span class="line-modified">!         finally {</span>
              if (scannerDebug) {
                      System.out.println(&quot;nextToken(&quot; + pos
                                         + &quot;,&quot; + endPos + &quot;)=|&quot; +
<span class="line-modified">!                                        new String(reader.getRawCharacters(pos, endPos))</span>
                                         + &quot;|&quot;);
              }
          }
      }
<span class="line-removed">-     //where</span>
<span class="line-removed">-         List&lt;Comment&gt; addComment(List&lt;Comment&gt; comments, Comment comment) {</span>
<span class="line-removed">-             return comments == null ?</span>
<span class="line-removed">-                     List.of(comment) :</span>
<span class="line-removed">-                     comments.prepend(comment);</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!     /** Return the position where a lexical error occurred;</span>
       */
      public int errPos() {
          return errPos;
      }
  
<span class="line-modified">!     /** Set the position where a lexical error occurred;</span>
       */
      public void errPos(int pos) {
          errPos = pos;
      }
  
      /**
       * Called when a complete comment has been scanned. pos and endPos
       * will mark the comment boundary.
       */
      protected Tokens.Comment processComment(int pos, int endPos, CommentStyle style) {
<span class="line-modified">!         if (scannerDebug)</span>
              System.out.println(&quot;processComment(&quot; + pos
<span class="line-modified">!                                + &quot;,&quot; + endPos + &quot;,&quot; + style + &quot;)=|&quot;</span>
<span class="line-modified">!                                + new String(reader.getRawCharacters(pos, endPos))</span>
<span class="line-modified">!                                + &quot;|&quot;);</span>
<span class="line-modified">!         char[] buf = reader.getRawCharacters(pos, endPos);</span>
<span class="line-modified">!         return new BasicComment&lt;&gt;(new UnicodeReader(fac, buf, buf.length), style);</span>
      }
  
      /**
       * Called when a complete whitespace run has been scanned. pos and endPos
       * will mark the whitespace boundary.
       */
      protected void processWhiteSpace(int pos, int endPos) {
<span class="line-modified">!         if (scannerDebug)</span>
              System.out.println(&quot;processWhitespace(&quot; + pos
<span class="line-modified">!                                + &quot;,&quot; + endPos + &quot;)=|&quot; +</span>
<span class="line-modified">!                                new String(reader.getRawCharacters(pos, endPos))</span>
<span class="line-modified">!                                + &quot;|&quot;);</span>
      }
  
      /**
       * Called when a line terminator has been processed.
       */
      protected void processLineTerminator(int pos, int endPos) {
<span class="line-modified">!         if (scannerDebug)</span>
              System.out.println(&quot;processTerminator(&quot; + pos
<span class="line-modified">!                                + &quot;,&quot; + endPos + &quot;)=|&quot; +</span>
<span class="line-modified">!                                new String(reader.getRawCharacters(pos, endPos))</span>
<span class="line-modified">!                                + &quot;|&quot;);</span>
      }
  
<span class="line-modified">!     /** Build a map for translating between line numbers and</span>
<span class="line-modified">!      * positions in the input.</span>
       *
<span class="line-modified">!      * @return a LineMap */</span>
      public Position.LineMap getLineMap() {
<span class="line-modified">!         return Position.makeLineMap(reader.getRawCharacters(), reader.buflen, false);</span>
      }
  
<span class="line-removed">- </span>
      /**
<span class="line-modified">!     * Scan a documentation comment; determine if a deprecated tag is present.</span>
<span class="line-modified">!     * Called once the initial /, * have been skipped, positioned at the second *</span>
<span class="line-modified">!     * (which is treated as the beginning of the first line).</span>
<span class="line-modified">!     * Stops positioned at the closing &#39;/&#39;.</span>
<span class="line-modified">!     */</span>
<span class="line-modified">!     protected static class BasicComment&lt;U extends UnicodeReader&gt; implements Comment {</span>
<span class="line-modified">! </span>
          CommentStyle cs;
<span class="line-removed">-         U comment_reader;</span>
  
          protected boolean deprecatedFlag = false;
          protected boolean scanned = false;
  
<span class="line-modified">!         protected BasicComment(U comment_reader, CommentStyle cs) {</span>
<span class="line-modified">!             this.comment_reader = comment_reader;</span>
              this.cs = cs;
          }
  
          public String getText() {
              return null;
          }
  
          public int getSourcePos(int pos) {
              return -1;
          }
  
          public CommentStyle getStyle() {
              return cs;
          }
  
          public boolean isDeprecated() {
              if (!scanned &amp;&amp; cs == CommentStyle.JAVADOC) {
                  scanDocComment();
              }
              return deprecatedFlag;
          }
  
<span class="line-modified">!         @SuppressWarnings(&quot;fallthrough&quot;)</span>
          protected void scanDocComment() {
              try {
                  boolean deprecatedPrefix = false;
<span class="line-modified">! </span>
<span class="line-removed">-                 comment_reader.bp += 3; // &#39;/**&#39;</span>
<span class="line-removed">-                 comment_reader.ch = comment_reader.buf[comment_reader.bp];</span>
  
                  forEachLine:
<span class="line-modified">!                 while (comment_reader.bp &lt; comment_reader.buflen) {</span>
<span class="line-removed">- </span>
                      // Skip optional WhiteSpace at beginning of line
<span class="line-modified">!                     while (comment_reader.bp &lt; comment_reader.buflen &amp;&amp; (comment_reader.ch == &#39; &#39; || comment_reader.ch == &#39;\t&#39; || comment_reader.ch == FF)) {</span>
<span class="line-removed">-                         comment_reader.scanCommentChar();</span>
<span class="line-removed">-                     }</span>
  
                      // Skip optional consecutive Stars
<span class="line-modified">!                     while (comment_reader.bp &lt; comment_reader.buflen &amp;&amp; comment_reader.ch == &#39;*&#39;) {</span>
<span class="line-modified">!                         comment_reader.scanCommentChar();</span>
<span class="line-removed">-                         if (comment_reader.ch == &#39;/&#39;) {</span>
                              return;
                          }
                      }
  
                      // Skip optional WhiteSpace after Stars
<span class="line-modified">!                     while (comment_reader.bp &lt; comment_reader.buflen &amp;&amp; (comment_reader.ch == &#39; &#39; || comment_reader.ch == &#39;\t&#39; || comment_reader.ch == FF)) {</span>
<span class="line-removed">-                         comment_reader.scanCommentChar();</span>
<span class="line-removed">-                     }</span>
  
<span class="line-removed">-                     deprecatedPrefix = false;</span>
                      // At beginning of line in the JavaDoc sense.
<span class="line-modified">!                     if (!deprecatedFlag) {</span>
<span class="line-removed">-                         String deprecated = &quot;@deprecated&quot;;</span>
<span class="line-removed">-                         int i = 0;</span>
<span class="line-removed">-                         while (comment_reader.bp &lt; comment_reader.buflen &amp;&amp; comment_reader.ch == deprecated.charAt(i)) {</span>
<span class="line-removed">-                             comment_reader.scanCommentChar();</span>
<span class="line-removed">-                             i++;</span>
<span class="line-removed">-                             if (i == deprecated.length()) {</span>
<span class="line-removed">-                                 deprecatedPrefix = true;</span>
<span class="line-removed">-                                 break;</span>
<span class="line-removed">-                             }</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
  
<span class="line-modified">!                     if (deprecatedPrefix &amp;&amp; comment_reader.bp &lt; comment_reader.buflen) {</span>
<span class="line-modified">!                         if (Character.isWhitespace(comment_reader.ch)) {</span>
                              deprecatedFlag = true;
<span class="line-modified">!                         } else if (comment_reader.ch == &#39;*&#39;) {</span>
<span class="line-modified">!                             comment_reader.scanCommentChar();</span>
<span class="line-removed">-                             if (comment_reader.ch == &#39;/&#39;) {</span>
                                  deprecatedFlag = true;
                                  return;
                              }
                          }
                      }
  
                      // Skip rest of line
<span class="line-modified">!                     while (comment_reader.bp &lt; comment_reader.buflen) {</span>
<span class="line-modified">!                         switch (comment_reader.ch) {</span>
                              case &#39;*&#39;:
<span class="line-modified">!                                 comment_reader.scanCommentChar();</span>
<span class="line-modified">!                                 if (comment_reader.ch == &#39;/&#39;) {</span>
                                      return;
                                  }
                                  break;
<span class="line-modified">!                             case CR: // (Spec 3.4)</span>
<span class="line-modified">!                                 comment_reader.scanCommentChar();</span>
<span class="line-modified">!                                 if (comment_reader.ch != LF) {</span>
<span class="line-modified">!                                     continue forEachLine;</span>
<span class="line-removed">-                                 }</span>
<span class="line-removed">-                             /* fall through to LF case */</span>
<span class="line-removed">-                             case LF: // (Spec 3.4)</span>
<span class="line-removed">-                                 comment_reader.scanCommentChar();</span>
                                  continue forEachLine;
                              default:
<span class="line-modified">!                                 comment_reader.scanCommentChar();</span>
                          }
                      } // rest of line
                  } // forEachLine
                  return;
              } finally {
<span class="line-new-header">--- 814,522 ---</span>
                  case &#39;f&#39;: case &#39;g&#39;: case &#39;h&#39;: case &#39;i&#39;: case &#39;j&#39;:
                  case &#39;k&#39;: case &#39;l&#39;: case &#39;m&#39;: case &#39;n&#39;: case &#39;o&#39;:
                  case &#39;p&#39;: case &#39;q&#39;: case &#39;r&#39;: case &#39;s&#39;: case &#39;t&#39;:
                  case &#39;u&#39;: case &#39;v&#39;: case &#39;w&#39;: case &#39;x&#39;: case &#39;y&#39;:
                  case &#39;z&#39;:
<span class="line-modified">!                 case &#39;$&#39;: case &#39;_&#39;: // (Spec. 3.8)</span>
                      scanIdent();
                      break loop;
<span class="line-modified">! </span>
<span class="line-modified">!                 case &#39;0&#39;: // (Spec. 3.10)</span>
<span class="line-modified">!                     next();</span>
<span class="line-modified">! </span>
<span class="line-added">+                     if (acceptOneOf(&#39;x&#39;, &#39;X&#39;)) {</span>
                          skipIllegalUnderscores();
                          scanNumber(pos, 16);
<span class="line-modified">!                     } else if (acceptOneOf(&#39;b&#39;, &#39;B&#39;)) {</span>
                          skipIllegalUnderscores();
                          scanNumber(pos, 2);
                      } else {
<span class="line-modified">!                         put(&#39;0&#39;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                         if (is(&#39;_&#39;)) {</span>
<span class="line-modified">!                             int savePos = position();</span>
<span class="line-modified">!                             skip(&#39;_&#39;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                             if (digit(pos, 10) &lt; 0) {</span>
                                  lexError(savePos, Errors.IllegalUnderscore);
                              }
                          }
<span class="line-added">+ </span>
                          scanNumber(pos, 8);
                      }
                      break loop;
<span class="line-added">+ </span>
                  case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
<span class="line-modified">!                 case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:  // (Spec. 3.10)</span>
                      scanNumber(pos, 10);
                      break loop;
<span class="line-modified">! </span>
<span class="line-modified">!                 case &#39;.&#39;: // (Spec. 3.12)</span>
<span class="line-modified">!                     if (accept(&quot;...&quot;)) {</span>
<span class="line-modified">!                         put(&quot;...&quot;);</span>
<span class="line-modified">!                         tk = TokenKind.ELLIPSIS;</span>
<span class="line-modified">!                     } else {</span>
<span class="line-modified">!                         next();</span>
<span class="line-modified">!                         int savePos = position();</span>
<span class="line-modified">! </span>
<span class="line-modified">!                         if (accept(&#39;.&#39;)) {</span>
                              lexError(savePos, Errors.IllegalDot);
<span class="line-added">+                         } else if (digit(pos, 10) &gt;= 0) {</span>
<span class="line-added">+                             put(&#39;.&#39;);</span>
<span class="line-added">+                             scanFractionAndSuffix(pos); // (Spec. 3.10)</span>
<span class="line-added">+                         } else {</span>
<span class="line-added">+                             tk = TokenKind.DOT;</span>
                          }
                      }
                      break loop;
<span class="line-modified">! </span>
<span class="line-modified">!                 case &#39;,&#39;: // (Spec. 3.12)</span>
<span class="line-modified">!                     next();</span>
<span class="line-modified">!                     tk = TokenKind.COMMA;</span>
<span class="line-modified">!                     break loop;</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 case &#39;;&#39;: // (Spec. 3.12)</span>
<span class="line-modified">!                     next();</span>
<span class="line-modified">!                     tk = TokenKind.SEMI;</span>
<span class="line-modified">!                     break loop;</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 case &#39;(&#39;: // (Spec. 3.12)</span>
<span class="line-modified">!                     next();</span>
<span class="line-modified">!                     tk = TokenKind.LPAREN;</span>
<span class="line-modified">!                     break loop;</span>
<span class="line-modified">! </span>
<span class="line-added">+                 case &#39;)&#39;: // (Spec. 3.12)</span>
<span class="line-added">+                     next();</span>
<span class="line-added">+                     tk = TokenKind.RPAREN;</span>
<span class="line-added">+                     break loop;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 case &#39;[&#39;: // (Spec. 3.12)</span>
<span class="line-added">+                     next();</span>
<span class="line-added">+                     tk = TokenKind.LBRACKET;</span>
<span class="line-added">+                     break loop;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 case &#39;]&#39;: // (Spec. 3.12)</span>
<span class="line-added">+                     next();</span>
<span class="line-added">+                     tk = TokenKind.RBRACKET;</span>
<span class="line-added">+                     break loop;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 case &#39;{&#39;: // (Spec. 3.12)</span>
<span class="line-added">+                     next();</span>
<span class="line-added">+                     tk = TokenKind.LBRACE;</span>
<span class="line-added">+                     break loop;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 case &#39;}&#39;: // (Spec. 3.12)</span>
<span class="line-added">+                     next();</span>
<span class="line-added">+                     tk = TokenKind.RBRACE;</span>
<span class="line-added">+                     break loop;</span>
<span class="line-added">+ </span>
                  case &#39;/&#39;:
<span class="line-modified">!                     next();</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     if (accept(&#39;/&#39;)) { // (Spec. 3.7)</span>
<span class="line-modified">!                         skipToEOLN();</span>
<span class="line-modified">! </span>
<span class="line-modified">!                         if (isAvailable()) {</span>
<span class="line-modified">!                             comments = appendComment(comments, processComment(pos, position(), CommentStyle.LINE));</span>
                          }
                          break;
<span class="line-modified">!                     } else if (accept(&#39;*&#39;)) { // (Spec. 3.7)</span>
                          boolean isEmpty = false;
                          CommentStyle style;
<span class="line-modified">! </span>
<span class="line-added">+                         if (accept(&#39;*&#39;)) {</span>
                              style = CommentStyle.JAVADOC;
<span class="line-modified">! </span>
<span class="line-modified">!                             if (is(&#39;/&#39;)) {</span>
                                  isEmpty = true;
                              }
                          } else {
                              style = CommentStyle.BLOCK;
                          }
<span class="line-modified">! </span>
<span class="line-modified">!                         if (!isEmpty) {</span>
<span class="line-modified">!                             while (isAvailable()) {</span>
<span class="line-modified">!                                 if (accept(&#39;*&#39;)) {</span>
<span class="line-modified">!                                     if (is(&#39;/&#39;)) {</span>
<span class="line-modified">!                                         break;</span>
<span class="line-added">+                                     }</span>
<span class="line-added">+                                 } else {</span>
<span class="line-added">+                                     next();</span>
<span class="line-added">+                                 }</span>
                              }
                          }
<span class="line-modified">! </span>
<span class="line-modified">!                         if (accept(&#39;/&#39;)) {</span>
<span class="line-modified">!                             comments = appendComment(comments, processComment(pos, position(), style));</span>
<span class="line-added">+ </span>
                              break;
                          } else {
                              lexError(pos, Errors.UnclosedComment);
<span class="line-added">+ </span>
                              break loop;
                          }
<span class="line-modified">!                     } else if (accept(&#39;=&#39;)) {</span>
<span class="line-modified">!                         tk = TokenKind.SLASHEQ; // (Spec. 3.12)</span>
                      } else {
<span class="line-modified">!                         tk = TokenKind.SLASH; // (Spec. 3.12)</span>
                      }
                      break loop;
<span class="line-modified">! </span>
<span class="line-modified">!                 case &#39;\&#39;&#39;: // (Spec. 3.10)</span>
<span class="line-modified">!                     next();</span>
<span class="line-added">+ </span>
<span class="line-added">+                     if (accept(&#39;\&#39;&#39;)) {</span>
                          lexError(pos, Errors.EmptyCharLit);
                      } else {
<span class="line-modified">!                         if (isEOLN()) {</span>
                              lexError(pos, Errors.IllegalLineEndInCharLit);
<span class="line-modified">!                         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!                         scanLitChar(pos);</span>
<span class="line-added">+ </span>
<span class="line-added">+                         if (accept(&#39;\&#39;&#39;)) {</span>
                              tk = TokenKind.CHARLITERAL;
                          } else {
                              lexError(pos, Errors.UnclosedCharLit);
                          }
                      }
                      break loop;
<span class="line-modified">! </span>
<span class="line-added">+                 case &#39;\&quot;&#39;: // (Spec. 3.10)</span>
                      scanString(pos);
                      break loop;
<span class="line-added">+ </span>
                  default:
<span class="line-modified">!                     if (isSpecial(get())) {</span>
                          scanOperator();
                      } else {
                          boolean isJavaIdentifierStart;
<span class="line-modified">! </span>
<span class="line-modified">!                         if (isASCII()) {</span>
                              // all ASCII range chars already handled, above
                              isJavaIdentifierStart = false;
                          } else {
<span class="line-modified">!                             isJavaIdentifierStart = isSurrogate()</span>
<span class="line-modified">!                                     ? Character.isJavaIdentifierStart(getCodepoint())</span>
<span class="line-modified">!                                     : Character.isJavaIdentifierStart(get());</span>
                          }
<span class="line-added">+ </span>
                          if (isJavaIdentifierStart) {
                              scanIdent();
<span class="line-modified">!                         } else if (digit(pos, 10) &gt;= 0) {</span>
                              scanNumber(pos, 10);
<span class="line-modified">!                         } else if (is((char)EOI) || !isAvailable()) {</span>
                              tk = TokenKind.EOF;
<span class="line-modified">!                             pos = position();</span>
                          } else {
                              String arg;
  
<span class="line-modified">!                             if (isSurrogate()) {</span>
<span class="line-modified">!                                 int codePoint = getCodepoint();</span>
<span class="line-modified">!                                 char hi = Character.highSurrogate(codePoint);</span>
<span class="line-modified">!                                 char lo = Character.lowSurrogate(codePoint);</span>
<span class="line-added">+                                 arg = String.format(&quot;\\u%04x\\u%04x&quot;, (int) hi, (int) lo);</span>
                              } else {
<span class="line-modified">!                                 char ch = get();</span>
<span class="line-modified">!                                 arg = (32 &lt; ch &amp;&amp; ch &lt; 127) ? String.format(&quot;%s&quot;, ch) :</span>
<span class="line-modified">!                                                               String.format(&quot;\\u%04x&quot;, (int) ch);</span>
                              }
<span class="line-added">+ </span>
                              lexError(pos, Errors.IllegalChar(arg));
<span class="line-modified">!                             next();</span>
                          }
                      }
                      break loop;
                  }
              }
<span class="line-modified">! </span>
<span class="line-modified">!             int endPos = position();</span>
<span class="line-modified">! </span>
<span class="line-modified">!             if (tk.tag == Token.Tag.DEFAULT) {</span>
<span class="line-modified">!                 return new Token(tk, pos, endPos, comments);</span>
<span class="line-modified">!             } else  if (tk.tag == Token.Tag.NAMED) {</span>
<span class="line-modified">!                 return new NamedToken(tk, pos, endPos, name, comments);</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 // Get characters from string buffer.</span>
<span class="line-modified">!                 String string = sb.toString();</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 // If a text block.</span>
<span class="line-modified">!                 if (isTextBlock) {</span>
<span class="line-modified">!                     // Verify that the incidental indentation is consistent.</span>
<span class="line-modified">!                     if (lint.isEnabled(LintCategory.TEXT_BLOCKS)) {</span>
<span class="line-modified">!                         Set&lt;TextBlockSupport.WhitespaceChecks&gt; checks =</span>
<span class="line-modified">!                                 TextBlockSupport.checkWhitespace(string);</span>
<span class="line-modified">!                         if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {</span>
<span class="line-modified">!                             lexWarning(LintCategory.TEXT_BLOCKS, pos,</span>
<span class="line-modified">!                                     Warnings.InconsistentWhiteSpaceIndentation);</span>
                          }
<span class="line-modified">!                         if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {</span>
<span class="line-modified">!                             lexWarning(LintCategory.TEXT_BLOCKS, pos,</span>
<span class="line-modified">!                                     Warnings.TrailingWhiteSpaceWillBeRemoved);</span>
                          }
                      }
<span class="line-modified">!                     // Remove incidental indentation.</span>
<span class="line-modified">!                     try {</span>
<span class="line-modified">!                         string = string.stripIndent();</span>
<span class="line-modified">!                     } catch (Exception ex) {</span>
<span class="line-modified">!                         // Error already reported, just use unstripped string.</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // Translate escape sequences if present.</span>
<span class="line-added">+                 if (hasEscapeSequences) {</span>
<span class="line-added">+                     try {</span>
<span class="line-added">+                         string = string.translateEscapes();</span>
<span class="line-added">+                     } catch (Exception ex) {</span>
<span class="line-added">+                         // Error already reported, just use untranslated string.</span>
                      }
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 if (tk.tag == Token.Tag.STRING) {</span>
                      // Build string token.
                      return new StringToken(tk, pos, endPos, string, comments);
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     // Build numeric token.</span>
<span class="line-added">+                     return new NumericToken(tk, pos, endPos, string, radix, comments);</span>
                  }
              }
<span class="line-modified">!         } finally {</span>
<span class="line-modified">!             int endPos = position();</span>
<span class="line-added">+ </span>
              if (scannerDebug) {
                      System.out.println(&quot;nextToken(&quot; + pos
                                         + &quot;,&quot; + endPos + &quot;)=|&quot; +
<span class="line-modified">!                                        new String(getRawCharacters(pos, endPos))</span>
                                         + &quot;|&quot;);
              }
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Appends a comment to the list of comments preceding the current token.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param comments  existing list of comments.</span>
<span class="line-added">+      * @param comment   comment to append.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return new list with comment prepended to the existing list.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     List&lt;Comment&gt; appendComment(List&lt;Comment&gt; comments, Comment comment) {</span>
<span class="line-added">+         return comments == null ?</span>
<span class="line-added">+                 List.of(comment) :</span>
<span class="line-added">+                 comments.prepend(comment);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Return the position where a lexical error occurred.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return position in the input buffer of where the error occurred.</span>
       */
      public int errPos() {
          return errPos;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Set the position where a lexical error occurred.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param pos  position in the input buffer of where the error occurred.</span>
       */
      public void errPos(int pos) {
          errPos = pos;
      }
  
      /**
       * Called when a complete comment has been scanned. pos and endPos
       * will mark the comment boundary.
<span class="line-added">+      *</span>
<span class="line-added">+      * @param pos     position of the opening / in the input buffer.</span>
<span class="line-added">+      * @param endPos  position + 1 of the closing / in the input buffer.</span>
<span class="line-added">+      * @param style   style of comment.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return the constructed BasicComment.</span>
       */
      protected Tokens.Comment processComment(int pos, int endPos, CommentStyle style) {
<span class="line-modified">!         if (scannerDebug) {</span>
              System.out.println(&quot;processComment(&quot; + pos
<span class="line-modified">!                                 + &quot;,&quot; + endPos + &quot;,&quot; + style + &quot;)=|&quot;</span>
<span class="line-modified">!                                 + new String(getRawCharacters(pos, endPos))</span>
<span class="line-modified">!                                 + &quot;|&quot;);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-added">+         char[] buf = getRawCharacters(pos, endPos);</span>
<span class="line-added">+ </span>
<span class="line-added">+         return new BasicComment(style, fac, buf, pos);</span>
      }
  
      /**
       * Called when a complete whitespace run has been scanned. pos and endPos
       * will mark the whitespace boundary.
<span class="line-added">+      *</span>
<span class="line-added">+      * (Spec 3.6)</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param pos     position in input buffer of first whitespace character.</span>
<span class="line-added">+      * @param endPos  position + 1 in input buffer of last whitespace character.</span>
       */
      protected void processWhiteSpace(int pos, int endPos) {
<span class="line-modified">!         if (scannerDebug) {</span>
              System.out.println(&quot;processWhitespace(&quot; + pos
<span class="line-modified">!                                 + &quot;,&quot; + endPos + &quot;)=|&quot; +</span>
<span class="line-modified">!                                 new String(getRawCharacters(pos, endPos))</span>
<span class="line-modified">!                                 + &quot;|&quot;);</span>
<span class="line-added">+         }</span>
      }
  
      /**
       * Called when a line terminator has been processed.
<span class="line-added">+      *</span>
<span class="line-added">+      * @param pos     position in input buffer of first character in sequence.</span>
<span class="line-added">+      * @param endPos  position + 1 in input buffer of last character in sequence.</span>
       */
      protected void processLineTerminator(int pos, int endPos) {
<span class="line-modified">!         if (scannerDebug) {</span>
              System.out.println(&quot;processTerminator(&quot; + pos
<span class="line-modified">!                                 + &quot;,&quot; + endPos + &quot;)=|&quot; +</span>
<span class="line-modified">!                                 new String(getRawCharacters(pos, endPos))</span>
<span class="line-modified">!                                 + &quot;|&quot;);</span>
<span class="line-added">+         }</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Build a map for translating between line numbers and positions in the input.</span>
       *
<span class="line-modified">!      * @return a LineMap</span>
<span class="line-added">+      */</span>
      public Position.LineMap getLineMap() {
<span class="line-modified">!         return Position.makeLineMap(getRawCharacters(), length(), false);</span>
      }
  
      /**
<span class="line-modified">!      * Scan a documentation comment; determine if a deprecated tag is present.</span>
<span class="line-modified">!      * Called once the initial /, * have been skipped, positioned at the second *</span>
<span class="line-modified">!      * (which is treated as the beginning of the first line).</span>
<span class="line-modified">!      * Stops positioned at the closing &#39;/&#39;.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     protected static class BasicComment extends PositionTrackingReader implements Comment {</span>
<span class="line-modified">!         /**</span>
<span class="line-added">+          * Style of comment</span>
<span class="line-added">+          *   LINE starting with //</span>
<span class="line-added">+          *   BLOCK starting with /*</span>
<span class="line-added">+          *   JAVADOC starting with /**</span>
<span class="line-added">+          */</span>
          CommentStyle cs;
  
<span class="line-added">+         /**</span>
<span class="line-added">+          * true if comment contains @deprecated at beginning of a line.</span>
<span class="line-added">+          */</span>
          protected boolean deprecatedFlag = false;
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * true if comment has been fully scanned.</span>
<span class="line-added">+          */</span>
          protected boolean scanned = false;
  
<span class="line-modified">!         /**</span>
<span class="line-modified">!          * Constructor.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * @param cs      comment style</span>
<span class="line-added">+          * @param sf      Scan factory.</span>
<span class="line-added">+          * @param array   Array containing contents of source.</span>
<span class="line-added">+          * @param offset  Position offset in original source buffer.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         protected BasicComment(CommentStyle cs, ScannerFactory sf, char[] array, int offset) {</span>
<span class="line-added">+             super(sf, array, offset);</span>
              this.cs = cs;
          }
  
<span class="line-added">+         /**</span>
<span class="line-added">+          * Return comment body text minus comment adornments or null if not scanned.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * @return comment body text.</span>
<span class="line-added">+          */</span>
          public String getText() {
              return null;
          }
  
<span class="line-added">+         /**</span>
<span class="line-added">+          * Return buffer position in original buffer mapped from buffer position in comment.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * @param pos  buffer position in comment.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * @return buffer position in original buffer.</span>
<span class="line-added">+          */</span>
          public int getSourcePos(int pos) {
              return -1;
          }
  
<span class="line-added">+         /**</span>
<span class="line-added">+          * Return style of comment.</span>
<span class="line-added">+          *   LINE starting with //</span>
<span class="line-added">+          *   BLOCK starting with /*</span>
<span class="line-added">+          *   JAVADOC starting with /**</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * @return</span>
<span class="line-added">+          */</span>
          public CommentStyle getStyle() {
              return cs;
          }
  
<span class="line-added">+         /**</span>
<span class="line-added">+          * true if comment contains @deprecated at beginning of a line.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * @return true if comment contains @deprecated.</span>
<span class="line-added">+          */</span>
          public boolean isDeprecated() {
              if (!scanned &amp;&amp; cs == CommentStyle.JAVADOC) {
                  scanDocComment();
              }
<span class="line-added">+ </span>
              return deprecatedFlag;
          }
  
<span class="line-modified">!         /**</span>
<span class="line-added">+          * Scan JAVADOC comment for details.</span>
<span class="line-added">+          */</span>
          protected void scanDocComment() {
              try {
                  boolean deprecatedPrefix = false;
<span class="line-modified">!                 accept(&quot;/**&quot;);</span>
  
                  forEachLine:
<span class="line-modified">!                 while (isAvailable()) {</span>
                      // Skip optional WhiteSpace at beginning of line
<span class="line-modified">!                     skipWhitespace();</span>
  
                      // Skip optional consecutive Stars
<span class="line-modified">!                     while (accept(&#39;*&#39;)) {</span>
<span class="line-modified">!                         if (is(&#39;/&#39;)) {</span>
                              return;
                          }
                      }
  
                      // Skip optional WhiteSpace after Stars
<span class="line-modified">!                     skipWhitespace();</span>
  
                      // At beginning of line in the JavaDoc sense.
<span class="line-modified">!                     deprecatedPrefix = deprecatedFlag || accept(&quot;@deprecated&quot;);</span>
  
<span class="line-modified">!                     if (deprecatedPrefix &amp;&amp; isAvailable()) {</span>
<span class="line-modified">!                         if (Character.isWhitespace(get())) {</span>
                              deprecatedFlag = true;
<span class="line-modified">!                         } else if (accept(&#39;*&#39;)) {</span>
<span class="line-modified">!                             if (is(&#39;/&#39;)) {</span>
                                  deprecatedFlag = true;
                                  return;
                              }
                          }
                      }
  
                      // Skip rest of line
<span class="line-modified">!                     while (isAvailable()) {</span>
<span class="line-modified">!                         switch (get()) {</span>
                              case &#39;*&#39;:
<span class="line-modified">!                                 next();</span>
<span class="line-modified">! </span>
<span class="line-added">+                                 if (is(&#39;/&#39;)) {</span>
                                      return;
                                  }
<span class="line-added">+ </span>
                                  break;
<span class="line-modified">!                             case &#39;\r&#39;: // (Spec 3.4)</span>
<span class="line-modified">!                             case &#39;\n&#39;: // (Spec 3.4)</span>
<span class="line-modified">!                                 accept(&#39;\r&#39;);</span>
<span class="line-modified">!                                 accept(&#39;\n&#39;);</span>
                                  continue forEachLine;
<span class="line-added">+ </span>
                              default:
<span class="line-modified">!                                 next();</span>
<span class="line-added">+                                 break;</span>
                          }
                      } // rest of line
                  } // forEachLine
                  return;
              } finally {
</pre>
<center>&lt; prev <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JavadocTokenizer.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>