<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/parser/UnicodeReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.parser;
 27 
 28 import java.util.Arrays;
 29 
 30 import com.sun.tools.javac.resources.CompilerProperties.Errors;
 31 import com.sun.tools.javac.util.Log;
 32 
 33 import static com.sun.tools.javac.util.LayoutCharacters.EOI;
 34 import static com.sun.tools.javac.util.LayoutCharacters.tabulate;
 35 
 36 /**
 37  * The unicode character reader used by the javac/javadoc lexer/tokenizer, returns characters
 38  * one by one as contained in the input stream, handling unicode escape sequences accordingly.
 39  *
 40  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 41  *  If you write code that depends on this, you do so at your own risk.
 42  *  This code and its internal interfaces are subject to change or
 43  *  deletion without notice.&lt;/b&gt;&lt;/p&gt;
 44  */
 45 public class UnicodeReader {
 46     /**
 47      * Buffer containing characters from source file. May contain extraneous characters
 48      * beyond this.length.
 49      */
 50     private final char[] buffer;
 51 
 52     /**
 53      * Length of meaningful content in buffer.
 54      */
 55     private final int length;
 56 
 57     /**
 58      * Character buffer index of character currently being observed.
 59      */
 60     private int position;
 61 
 62     /**
 63      * Number of characters combined to provide character currently being observed. Typically
 64      * one, but may be more when combinations of surrogate pairs and unicode escape sequences
 65      * are read.
 66      */
 67     private int width;
 68 
 69     /**
 70      * Character currently being observed. If a surrogate pair is read then will be the high
 71      * member of the pair.
 72      */
 73     private char character;
 74 
 75     /**
 76      * Codepoint of character currently being observed. Typically equivalent to the character
 77      * but will have a value greater that 0xFFFF when a surrogate pair.
 78      */
 79     private int codepoint;
 80 
 81     /**
 82      * true if the last character was a backslash. This is used to handle the special case
 83      * when a backslash precedes an unicode escape. In that case, the second backslash
 84      * is treated as a backslash and not part of an unicode escape.
 85      */
 86     private boolean wasBackslash;
 87 
 88     /**
 89      * Log for error reporting.
 90      */
 91     private final Log log;
 92 
 93     /**
 94      * Constructor.
 95      *
 96      * @param sf      scan factory.
 97      * @param array   array containing contents of source.
 98      * @param length  length of meaningful content in buffer.
 99      */
100     protected UnicodeReader(ScannerFactory sf, char[] array, int length) {
101         this.buffer = array;
102         this.length = length;
103         this.position = 0;
104         this.width = 0;
105         this.character = &#39;\0&#39;;
106         this.codepoint = 0;
107         this.wasBackslash = false;
108         this.log = sf.log;
109 
110         nextCodePoint();
111     }
112 
113     /**
114      * Returns the length of the buffer. This is length of meaningful content in buffer and
115      * not the length of the buffer array.
116      *
117      * @return length of the buffer.
118      */
119     protected int length() {
120         return length;
121     }
122 
123     /**
124      * Return true if current position is within the meaningful part of the buffer.
125      *
126      * @return true if current position is within the meaningful part of the buffer.
127      */
128     protected boolean isAvailable() {
129         return position &lt; length;
130     }
131 
132     /**
133      * Fetches the next 16-bit character from the buffer and places it in this.character.
134      */
135     private void nextCodeUnit() {
136         // Index of next character in buffer.
137         int index = position + width;
138 
139         // If past end of buffer.
140         if (length &lt;= index) {
141             // End of file is marked with EOI.
142             character = EOI;
143         } else {
144             // Next character in buffer.
145             character = buffer[index];
146             // Increment length of codepoint.
147             width++;
148         }
149     }
150 
151     /**
152      * Fetches the next 16-bit character from the buffer. If an unicode escape
153      * is detected then converts the unicode escape to a character.
154      */
155     private void nextUnicodeInputCharacter() {
156         // Position to next codepoint.
157         position += width;
158         // Codepoint has no characters yet.
159         width = 0;
160 
161         // Fetch next character.
162         nextCodeUnit();
163 
164         // If second backslash is detected.
165         if (wasBackslash) {
166             // Treat like a normal character (not part of unicode escape.)
167             wasBackslash = false;
168         } else if (character == &#39;\\&#39;) {
169             // May be an unicode escape.
170             wasBackslash = !unicodeEscape();
171         }
172 
173         // Codepoint and character match if not surrogate.
174         codepoint = (int)character;
175     }
176 
177     /**
178      * Fetches the nextcode point from the buffer. If an unicode escape is recognized
179      * then converts unicode escape to a character. If two characters are a surrogate pair
180      * then converts to a codepoint.
181      */
182     private void nextCodePoint() {
183         // Next unicode character.
184         nextUnicodeInputCharacter();
185 
186         // Return early if ASCII or not a surrogate pair.
187         if (isASCII() || !Character.isHighSurrogate(character)) {
188             return;
189         }
190 
191         // Capture high surrogate and position.
192         char hi = character;
193         int savePosition = position;
194         int saveWidth = width;
195 
196         // Get potential low surrogate.
197         nextUnicodeInputCharacter();
198         char lo = character;
199 
200         if (Character.isLowSurrogate(lo)) {
201             // Start codepoint at start of high surrogate.
202             position = savePosition;
203             width += saveWidth;
204             // Compute codepoint.
205             codepoint = Character.toCodePoint(hi, lo);
206         } else {
207             // Restore to treat high surrogate as just a character.
208             position = savePosition;
209             width = saveWidth;
210             character = hi;
211             codepoint = (int)hi;
212             // Could potential report an error here (old code did not.)
213         }
214     }
215 
216     /**
217      * Converts an unicode escape into a character.
218      *
219      * @return true if was an unicode escape.
220      */
221     private boolean unicodeEscape() {
222         // Start of unicode escape (past backslash.)
223         int start = position + width;
224         int index;
225 
226         // Skip multiple &#39;u&#39;.
227         for (index = start; index &lt; length; index++) {
228             if (buffer[index] != &#39;u&#39;) {
229                 break;
230             }
231         }
232 
233         // Needs to be at least backslash-u.
234         if (index != start) {
235             // If enough characters available.
236             if (index + 4 &lt; length) {
237                 // Convert four hex digits to codepoint. If any digit is invalid then the
238                 // result is negative.
239                 int code = (Character.digit(buffer[index++], 16) &lt;&lt; 12) |
240                            (Character.digit(buffer[index++], 16) &lt;&lt; 8) |
241                            (Character.digit(buffer[index++], 16) &lt;&lt; 4) |
242                             Character.digit(buffer[index++], 16);
243 
244                 // If all digits are good.
245                 if (code &gt;= 0) {
246                     width = index - position;
247                     character = (char)code;
248 
249                     return true;
250                 }
251             }
252 
253             // Did not work out.
254             log.error(position, Errors.IllegalUnicodeEsc);
255             width = index - position;
256 
257             // Return true so that the invalid unicode escape is skipped.
258             return true;
259         }
260 
261         // Must be just a backslash.
262         character = &#39;\\&#39;;
263         width = 1;
264 
265         return false;
266     }
267 
268     /**
269      * Return the current position in the character buffer.
270      *
271      * @return  current position in the character buffer.
272      */
273     protected int position() {
274         return position;
275     }
276 
277 
278     /**
279      * Reset the reader to the specified position.
280      * Warning: Do not use when previous character was an ASCII or unicode backslash.
281      * @param pos
282      */
283     protected void reset(int pos) {
284         position = pos;
285         width = 0;
286         wasBackslash = false;
287         nextCodePoint();
288     }
289 
290     /**
291      * Return the current character in at the current position.
292      *
293      * @return current character in at the current position.
294      */
295     protected char get() {
296         return character;
297     }
298 
299     /**
300      * Return the current codepoint in at the current position.
301      *
302      * @return current codepoint in at the current position.
303      */
304     protected int getCodepoint() {
305         return codepoint;
306     }
307 
308     /**
309      * Returns true if the current codepoint is a surrogate.
310      *
311      * @return true if the current codepoint is a surrogate.
312      */
313     protected boolean isSurrogate() {
314         return 0xFFFF &lt; codepoint;
315     }
316 
317     /**
318      * Returns true if the current character is ASCII.
319      *
320      * @return true if the current character is ASCII.
321      */
322     protected boolean isASCII() {
323         return character &lt;= 0x7F;
324     }
325 
326     /**
327      * Advances the current character to the next character.
328      *
329      * @return next character.
330      */
331     protected char next() {
332         nextCodePoint();
333 
334         return character;
335     }
336 
337     /**
338      * Compare character. Returns true if a match.
339      *
340      * @param ch  character to match.
341      *
342      * @return true if a match.
343      */
344     protected boolean is(char ch) {
345         return character == ch;
346     }
347 
348     /**
349      * Match one of the arguments. Returns true if a match.
350      */
351     protected boolean isOneOf(char ch1, char ch2) {
352         return is(ch1) || is(ch2);
353     }
354     protected boolean isOneOf(char ch1, char ch2, char ch3) {
355         return is(ch1) || is(ch2) || is(ch3);
356     }
357     protected boolean isOneOf(char ch1, char ch2, char ch3, char ch4, char ch5, char ch6) {
358         return is(ch1) || is(ch2) || is(ch3) || is(ch4) || is(ch5) || is(ch6);
359     }
360 
361     /**
362      * Tests to see if current character is in the range of lo to hi characters (inclusive).
363      *
364      * @param lo  lowest character in range.
365      * @param hi  highest character in range.
366      *
367      * @return true if the current character is in range.
368      */
369     protected boolean inRange(char lo, char hi) {
370         return lo &lt;= character &amp;&amp; character &lt;= hi;
371     }
372 
373     /**
374      * Compare character and advance if a match. Returns true if a match.
375      *
376      * @param ch  character to match.
377      *
378      * @return true if a match.
379      */
380     protected boolean accept(char ch) {
381         if (is(ch)) {
382             next();
383 
384             return true;
385         }
386 
387         return false;
388     }
389 
390     /**
391      * Match one of the arguments and advance if a match. Returns true if a match.
392      */
393     protected boolean acceptOneOf(char ch1, char ch2) {
394         if (isOneOf(ch1, ch2)) {
395             next();
396 
397             return true;
398         }
399 
400         return false;
401     }
402 
403     protected boolean acceptOneOf(char ch1, char ch2, char ch3) {
404         if (isOneOf(ch1, ch2, ch3)) {
405             next();
406 
407             return true;
408         }
409 
410         return false;
411     }
412 
413     /**
414      * Skip over all occurances of character.
415      *
416      * @param ch character to accept.
417      */
418     protected void skip(char ch) {
419         while (accept(ch)) {
420             // next
421         }
422     }
423 
424     /**
425      * Skip over ASCII white space characters.
426      */
427     protected void skipWhitespace() {
428         while (acceptOneOf(&#39; &#39;, &#39;\t&#39;, &#39;\f&#39;)) {
429             // next
430         }
431     }
432 
433     /**
434      * Skip to end of line.
435      */
436     protected void skipToEOLN() {
437         while (isAvailable()) {
438             if (isOneOf(&#39;\r&#39;, &#39;\n&#39;)) {
439                 break;
440             }
441 
442             next();
443         }
444 
445     }
446 
447     /**
448      * Compare string and advance if a match. Returns true if a match.
449      * Warning: Do not use when previous character was a backslash
450      * (confuses state of wasBackslash.)
451      *
452      * @param string string to match character for character.
453      *
454      * @return true if a match.
455      */
456     protected boolean accept(String string) {
457         // Quick test.
458         if (string.length() == 0 || !is(string.charAt(0))) {
459             return false;
460         }
461 
462         // Be prepared to retreat if not a match.
463         int savedPosition = position;
464 
465         nextCodePoint();
466 
467         // Check each character.
468         for (int i = 1; i &lt; string.length(); i++) {
469             if (!is(string.charAt(i))) {
470                 // Restart if not a match.
471                 reset(savedPosition);
472 
473                 return false;
474             }
475 
476             nextCodePoint();
477         }
478 
479         return true;
480     }
481 
482     /**
483      * Convert an ASCII digit from its base (8, 10, or 16) to its value. Does not
484      * advance character.
485      *
486      * @param pos         starting position.
487      * @param digitRadix  base of number being converted.
488      *
489      * @return value of digit.
490      */
491     protected int digit(int pos, int digitRadix) {
492         int result;
493 
494         // Just an ASCII digit.
495         if (inRange(&#39;0&#39;, &#39;9&#39;)) {
496             // Fast common case.
497             result = character - &#39;0&#39;;
498 
499             return result &lt; digitRadix ? result : -1;
500         }
501 
502         // Handle other digits.
503         result = isSurrogate() ? Character.digit(codepoint, digitRadix) :
504                                  Character.digit(character, digitRadix);
505 
506         if (result &gt;= 0 &amp;&amp; !isASCII()) {
507             log.error(position(), Errors.IllegalNonasciiDigit);
508             character = &quot;0123456789abcdef&quot;.charAt(result);
509         }
510 
511         return result;
512     }
513 
514     /**
515      * Returns the input buffer. Unicode escape sequences are not translated.
516      *
517      * @return the input buffer.
518      */
519     public char[] getRawCharacters() {
520         return length == buffer.length ? buffer : Arrays.copyOf(buffer, length);
521     }
522 
523     /**
524      * Returns a copy of a character array subset of the input buffer.
525      * The returned array begins at the {@code beginIndex} and
526      * extends to the character at index {@code endIndex - 1}.
527      * Thus the length of the substring is {@code endIndex-beginIndex}.
528      * This behavior is like
529      * {@code String.substring(beginIndex, endIndex)}.
530      * Unicode escape sequences are not translated.
531      *
532      * @param  beginIndex the beginning index, inclusive.
533      * @param  endIndex the ending index, exclusive.
534      *
535      * @throws ArrayIndexOutOfBoundsException if either offset is outside of the
536      *         array bounds
537      */
538     public char[] getRawCharacters(int beginIndex, int endIndex) {
539         return Arrays.copyOfRange(buffer, beginIndex, endIndex);
540     }
541 
542     /**
543      * This is a specialized version of UnicodeReader that keeps track of the
544      * column position within a given character stream. Used for Javadoc
545      * processing to build a table for mapping positions in the comment string
546      * to positions in the source file.
547      */
548     static class PositionTrackingReader extends UnicodeReader {
549         /**
550          * Offset from the beginning of the original reader buffer.
551          */
552         private int offset;
553 
554         /**
555          * Current column in the comment.
556          */
557         private int column;
558 
559         /**
560          * Constructor.
561          *
562          * @param sf      Scan factory.
563          * @param array   Array containing contents of source.
564          * @param offset  Position offset in original source buffer.
565          */
566         protected PositionTrackingReader(ScannerFactory sf, char[] array, int offset) {
567             super(sf, array, array.length);
568             this.offset = offset;
569             this.column = 0;
570         }
571 
572         /**
573          * Advances the current character to the next character. Tracks column.
574          *
575          * @return next character.
576          */
577         @Override
578         protected char next() {
579             super.next();
580 
581             if (isOneOf(&#39;\n&#39;, &#39;\r&#39;, &#39;\f&#39;)) {
582                 column = 0;
583             } else if (is(&#39;\t&#39;)) {
584                 column = tabulate(column);
585             } else {
586                 column++;
587             }
588 
589             return get();
590         }
591 
592         /**
593          * Returns the current column.
594          *
595          * @return  the current column.
596          */
597         protected int column() {
598             return column;
599         }
600 
601         /**
602          * Returns position relative to the original source buffer.
603          *
604          * @return
605          */
606         protected int offsetPosition() {
607             return position() + offset;
608         }
609     }
610 
611 }
    </pre>
  </body>
</html>