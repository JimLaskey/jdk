<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/parser/UnicodeReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.parser;
 27 
<a name="2" id="anc2"></a>
 28 import java.util.Arrays;
 29 
<a name="3" id="anc3"></a>
 30 import com.sun.tools.javac.resources.CompilerProperties.Errors;
<a name="4" id="anc4"></a>
 31 import com.sun.tools.javac.util.Log;
<a name="5" id="anc5"></a>

 32 
<a name="6" id="anc6"></a><span class="line-modified"> 33 import static com.sun.tools.javac.util.LayoutCharacters.EOI;</span>
<span class="line-added"> 34 import static com.sun.tools.javac.util.LayoutCharacters.tabulate;</span>
 35 
<a name="7" id="anc7"></a><span class="line-modified"> 36 /**</span>
<span class="line-modified"> 37  * The unicode character reader used by the javac/javadoc lexer/tokenizer, returns characters</span>
<span class="line-modified"> 38  * one by one as contained in the input stream, handling unicode escape sequences accordingly.</span>

 39  *
 40  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 41  *  If you write code that depends on this, you do so at your own risk.
 42  *  This code and its internal interfaces are subject to change or
<a name="8" id="anc8"></a><span class="line-modified"> 43  *  deletion without notice.&lt;/b&gt;&lt;/p&gt;</span>
 44  */
 45 public class UnicodeReader {
<a name="9" id="anc9"></a><span class="line-added"> 46     /**</span>
<span class="line-added"> 47      * Buffer containing characters from source file. May contain extraneous characters</span>
<span class="line-added"> 48      * beyond this.length.</span>
<span class="line-added"> 49      */</span>
<span class="line-added"> 50     private final char[] buffer;</span>
 51 
<a name="10" id="anc10"></a><span class="line-modified"> 52     /**</span>
<span class="line-modified"> 53      * Length of meaningful content in buffer.</span>
 54      */
<a name="11" id="anc11"></a><span class="line-modified"> 55     private final int length;</span>


 56 
<a name="12" id="anc12"></a><span class="line-modified"> 57     /**</span>
<span class="line-added"> 58      * Character buffer index of character currently being observed.</span>
 59      */
<a name="13" id="anc13"></a><span class="line-modified"> 60     private int position;</span>
 61 
<a name="14" id="anc14"></a><span class="line-modified"> 62     /**</span>
<span class="line-added"> 63      * Number of characters combined to provide character currently being observed. Typically</span>
<span class="line-added"> 64      * one, but may be more when combinations of surrogate pairs and unicode escape sequences</span>
<span class="line-added"> 65      * are read.</span>
 66      */
<a name="15" id="anc15"></a><span class="line-modified"> 67     private int width;</span>
 68 
<a name="16" id="anc16"></a><span class="line-modified"> 69     /**</span>
<span class="line-modified"> 70      * Character currently being observed. If a surrogate pair is read then will be the high</span>
<span class="line-added"> 71      * member of the pair.</span>
<span class="line-added"> 72      */</span>
<span class="line-added"> 73     private char character;</span>
 74 
<a name="17" id="anc17"></a><span class="line-modified"> 75     /**</span>
<span class="line-added"> 76      * Codepoint of character currently being observed. Typically equivalent to the character</span>
<span class="line-added"> 77      * but will have a value greater that 0xFFFF when a surrogate pair.</span>
<span class="line-added"> 78      */</span>
<span class="line-added"> 79     private int codepoint;</span>
<span class="line-added"> 80 </span>
<span class="line-added"> 81     /**</span>
<span class="line-added"> 82      * true if the last character was a backslash. This is used to handle the special case</span>
<span class="line-added"> 83      * when a backslash precedes an unicode escape. In that case, the second backslash</span>
<span class="line-added"> 84      * is treated as a backslash and not part of an unicode escape.</span>
 85      */
<a name="18" id="anc18"></a><span class="line-modified"> 86     private boolean wasBackslash;</span>


 87 
 88     /**
<a name="19" id="anc19"></a><span class="line-modified"> 89      * Log for error reporting.</span>
<span class="line-modified"> 90      */</span>
<span class="line-modified"> 91     private final Log log;</span>
<span class="line-modified"> 92 </span>
<span class="line-added"> 93     /**</span>
<span class="line-added"> 94      * Constructor.</span>
 95      *
<a name="20" id="anc20"></a><span class="line-modified"> 96      * @param sf      scan factory.</span>
<span class="line-modified"> 97      * @param array   array containing contents of source.</span>
<span class="line-modified"> 98      * @param length  length of meaningful content in buffer.</span>
 99      */
<a name="21" id="anc21"></a><span class="line-modified">100     protected UnicodeReader(ScannerFactory sf, char[] array, int length) {</span>
<span class="line-modified">101         this.buffer = array;</span>
<span class="line-added">102         this.length = length;</span>
<span class="line-added">103         this.position = 0;</span>
<span class="line-added">104         this.width = 0;</span>
<span class="line-added">105         this.character = &#39;\0&#39;;</span>
<span class="line-added">106         this.codepoint = 0;</span>
<span class="line-added">107         this.wasBackslash = false;</span>
<span class="line-added">108         this.log = sf.log;</span>
<span class="line-added">109 </span>
<span class="line-added">110         nextCodePoint();</span>
111     }
112 
<a name="22" id="anc22"></a><span class="line-modified">113     /**</span>
<span class="line-modified">114      * Returns the length of the buffer. This is length of meaningful content in buffer and</span>
<span class="line-modified">115      * not the length of the buffer array.</span>
<span class="line-modified">116      *</span>
<span class="line-modified">117      * @return length of the buffer.</span>
<span class="line-modified">118      */</span>
<span class="line-modified">119     protected int length() {</span>
<span class="line-modified">120         return length;</span>
<span class="line-modified">121     }</span>
<span class="line-modified">122 </span>
<span class="line-added">123     /**</span>
<span class="line-added">124      * Return true if current position is within the meaningful part of the buffer.</span>
<span class="line-added">125      *</span>
<span class="line-added">126      * @return true if current position is within the meaningful part of the buffer.</span>
<span class="line-added">127      */</span>
<span class="line-added">128     protected boolean isAvailable() {</span>
<span class="line-added">129         return position &lt; length;</span>
<span class="line-added">130     }</span>
<span class="line-added">131 </span>
<span class="line-added">132     /**</span>
<span class="line-added">133      * Fetches the next 16-bit character from the buffer and places it in this.character.</span>
<span class="line-added">134      */</span>
<span class="line-added">135     private void nextCodeUnit() {</span>
<span class="line-added">136         // Index of next character in buffer.</span>
<span class="line-added">137         int index = position + width;</span>
<span class="line-added">138 </span>
<span class="line-added">139         // If past end of buffer.</span>
<span class="line-added">140         if (length &lt;= index) {</span>
<span class="line-added">141             // End of file is marked with EOI.</span>
<span class="line-added">142             character = EOI;</span>
<span class="line-added">143         } else {</span>
<span class="line-added">144             // Next character in buffer.</span>
<span class="line-added">145             character = buffer[index];</span>
<span class="line-added">146             // Increment length of codepoint.</span>
<span class="line-added">147             width++;</span>
148         }
<a name="23" id="anc23"></a>




149     }
150 
<a name="24" id="anc24"></a><span class="line-modified">151     /**</span>
<span class="line-added">152      * Fetches the next 16-bit character from the buffer. If an unicode escape</span>
<span class="line-added">153      * is detected then converts the unicode escape to a character.</span>
154      */
<a name="25" id="anc25"></a><span class="line-modified">155     private void nextUnicodeInputCharacter() {</span>
<span class="line-modified">156         // Position to next codepoint.</span>
<span class="line-modified">157         position += width;</span>
<span class="line-modified">158         // Codepoint has no characters yet.</span>
<span class="line-modified">159         width = 0;</span>
<span class="line-modified">160 </span>
<span class="line-added">161         // Fetch next character.</span>
<span class="line-added">162         nextCodeUnit();</span>
<span class="line-added">163 </span>
<span class="line-added">164         // If second backslash is detected.</span>
<span class="line-added">165         if (wasBackslash) {</span>
<span class="line-added">166             // Treat like a normal character (not part of unicode escape.)</span>
<span class="line-added">167             wasBackslash = false;</span>
<span class="line-added">168         } else if (character == &#39;\\&#39;) {</span>
<span class="line-added">169             // May be an unicode escape.</span>
<span class="line-added">170             wasBackslash = !unicodeEscape();</span>
171         }
<a name="26" id="anc26"></a><span class="line-added">172 </span>
<span class="line-added">173         // Codepoint and character match if not surrogate.</span>
<span class="line-added">174         codepoint = (int)character;</span>
175     }
176 
<a name="27" id="anc27"></a><span class="line-modified">177     /**</span>
<span class="line-added">178      * Fetches the nextcode point from the buffer. If an unicode escape is recognized</span>
<span class="line-added">179      * then converts unicode escape to a character. If two characters are a surrogate pair</span>
<span class="line-added">180      * then converts to a codepoint.</span>
181      */
<a name="28" id="anc28"></a><span class="line-modified">182     private void nextCodePoint() {</span>
<span class="line-modified">183         // Next unicode character.</span>
<span class="line-modified">184         nextUnicodeInputCharacter();</span>
<span class="line-modified">185 </span>
<span class="line-modified">186         // Return early if ASCII or not a surrogate pair.</span>
<span class="line-modified">187         if (isASCII() || !Character.isHighSurrogate(character)) {</span>
<span class="line-modified">188             return;</span>
<span class="line-added">189         }</span>
<span class="line-added">190 </span>
<span class="line-added">191         // Capture high surrogate and position.</span>
<span class="line-added">192         char hi = character;</span>
<span class="line-added">193         int savePosition = position;</span>
<span class="line-added">194         int saveWidth = width;</span>
<span class="line-added">195 </span>
<span class="line-added">196         // Get potential low surrogate.</span>
<span class="line-added">197         nextUnicodeInputCharacter();</span>
<span class="line-added">198         char lo = character;</span>
<span class="line-added">199 </span>
<span class="line-added">200         if (Character.isLowSurrogate(lo)) {</span>
<span class="line-added">201             // Start codepoint at start of high surrogate.</span>
<span class="line-added">202             position = savePosition;</span>
<span class="line-added">203             width += saveWidth;</span>
<span class="line-added">204             // Compute codepoint.</span>
<span class="line-added">205             codepoint = Character.toCodePoint(hi, lo);</span>
<span class="line-added">206         } else {</span>
<span class="line-added">207             // Restore to treat high surrogate as just a character.</span>
<span class="line-added">208             position = savePosition;</span>
<span class="line-added">209             width = saveWidth;</span>
<span class="line-added">210             character = hi;</span>
<span class="line-added">211             codepoint = (int)hi;</span>
<span class="line-added">212             // Could potential report an error here (old code did not.)</span>
<span class="line-added">213         }</span>
<span class="line-added">214     }</span>
<span class="line-added">215 </span>
<span class="line-added">216     /**</span>
<span class="line-added">217      * Converts an unicode escape into a character.</span>
<span class="line-added">218      *</span>
<span class="line-added">219      * @return true if was an unicode escape.</span>
<span class="line-added">220      */</span>
<span class="line-added">221     private boolean unicodeEscape() {</span>
<span class="line-added">222         // Start of unicode escape (past backslash.)</span>
<span class="line-added">223         int start = position + width;</span>
<span class="line-added">224         int index;</span>
<span class="line-added">225 </span>
<span class="line-added">226         // Skip multiple &#39;u&#39;.</span>
<span class="line-added">227         for (index = start; index &lt; length; index++) {</span>
<span class="line-added">228             if (buffer[index] != &#39;u&#39;) {</span>
<span class="line-added">229                 break;</span>
<span class="line-added">230             }</span>
<span class="line-added">231         }</span>
<span class="line-added">232 </span>
<span class="line-added">233         // Needs to be at least backslash-u.</span>
<span class="line-added">234         if (index != start) {</span>
<span class="line-added">235             // If enough characters available.</span>
<span class="line-added">236             if (index + 4 &lt; length) {</span>
<span class="line-added">237                 // Convert four hex digits to codepoint. If any digit is invalid then the</span>
<span class="line-added">238                 // result is negative.</span>
<span class="line-added">239                 int code = (Character.digit(buffer[index++], 16) &lt;&lt; 12) |</span>
<span class="line-added">240                            (Character.digit(buffer[index++], 16) &lt;&lt; 8) |</span>
<span class="line-added">241                            (Character.digit(buffer[index++], 16) &lt;&lt; 4) |</span>
<span class="line-added">242                             Character.digit(buffer[index++], 16);</span>
<span class="line-added">243 </span>
<span class="line-added">244                 // If all digits are good.</span>
<span class="line-added">245                 if (code &gt;= 0) {</span>
<span class="line-added">246                     width = index - position;</span>
<span class="line-added">247                     character = (char)code;</span>
<span class="line-added">248 </span>
<span class="line-added">249                     return true;</span>
<span class="line-added">250                 }</span>
251             }
<a name="29" id="anc29"></a><span class="line-added">252 </span>
<span class="line-added">253             // Did not work out.</span>
<span class="line-added">254             log.error(position, Errors.IllegalUnicodeEsc);</span>
<span class="line-added">255             width = index - position;</span>
<span class="line-added">256 </span>
<span class="line-added">257             // Return true so that the invalid unicode escape is skipped.</span>
<span class="line-added">258             return true;</span>
259         }
<a name="30" id="anc30"></a><span class="line-added">260 </span>
<span class="line-added">261         // Must be just a backslash.</span>
<span class="line-added">262         character = &#39;\\&#39;;</span>
<span class="line-added">263         width = 1;</span>
<span class="line-added">264 </span>
<span class="line-added">265         return false;</span>
266     }
267 
<a name="31" id="anc31"></a><span class="line-modified">268     /**</span>
<span class="line-added">269      * Return the current position in the character buffer.</span>
<span class="line-added">270      *</span>
<span class="line-added">271      * @return  current position in the character buffer.</span>
272      */
<a name="32" id="anc32"></a><span class="line-modified">273     protected int position() {</span>
<span class="line-modified">274         return position;</span>



275     }
276 
<a name="33" id="anc33"></a><span class="line-modified">277 </span>
<span class="line-modified">278     /**</span>
<span class="line-added">279      * Reset the reader to the specified position.</span>
<span class="line-added">280      * Warning: Do not use when previous character was an ASCII or unicode backslash.</span>
<span class="line-added">281      * @param pos</span>
<span class="line-added">282      */</span>
<span class="line-added">283     protected void reset(int pos) {</span>
<span class="line-added">284         position = pos;</span>
<span class="line-added">285         width = 0;</span>
<span class="line-added">286         wasBackslash = false;</span>
<span class="line-added">287         nextCodePoint();</span>
288     }
289 
<a name="34" id="anc34"></a><span class="line-modified">290     /**</span>
<span class="line-modified">291      * Return the current character in at the current position.</span>
<span class="line-added">292      *</span>
<span class="line-added">293      * @return current character in at the current position.</span>
<span class="line-added">294      */</span>
<span class="line-added">295     protected char get() {</span>
<span class="line-added">296         return character;</span>
297     }
298 
<a name="35" id="anc35"></a><span class="line-modified">299     /**</span>
<span class="line-modified">300      * Return the current codepoint in at the current position.</span>
<span class="line-modified">301      *</span>
<span class="line-modified">302      * @return current codepoint in at the current position.</span>
<span class="line-modified">303      */</span>
<span class="line-added">304     protected int getCodepoint() {</span>
<span class="line-added">305         return codepoint;</span>
<span class="line-added">306     }</span>
307 
<a name="36" id="anc36"></a><span class="line-modified">308     /**</span>
<span class="line-added">309      * Returns true if the current codepoint is a surrogate.</span>
<span class="line-added">310      *</span>
<span class="line-added">311      * @return true if the current codepoint is a surrogate.</span>
<span class="line-added">312      */</span>
<span class="line-added">313     protected boolean isSurrogate() {</span>
<span class="line-added">314         return 0xFFFF &lt; codepoint;</span>
315     }
316 
<a name="37" id="anc37"></a><span class="line-modified">317     /**</span>
<span class="line-modified">318      * Returns true if the current character is ASCII.</span>
<span class="line-added">319      *</span>
<span class="line-added">320      * @return true if the current character is ASCII.</span>
<span class="line-added">321      */</span>
<span class="line-added">322     protected boolean isASCII() {</span>
<span class="line-added">323         return character &lt;= 0x7F;</span>
324     }
325 
<a name="38" id="anc38"></a><span class="line-modified">326     /**</span>
<span class="line-modified">327      * Advances the current character to the next character.</span>
<span class="line-added">328      *</span>
<span class="line-added">329      * @return next character.</span>
<span class="line-added">330      */</span>
<span class="line-added">331     protected char next() {</span>
<span class="line-added">332         nextCodePoint();</span>
<span class="line-added">333 </span>
<span class="line-added">334         return character;</span>
335     }
336 
<a name="39" id="anc39"></a><span class="line-modified">337     /**</span>
<span class="line-added">338      * Compare character. Returns true if a match.</span>
<span class="line-added">339      *</span>
<span class="line-added">340      * @param ch  character to match.</span>
<span class="line-added">341      *</span>
<span class="line-added">342      * @return true if a match.</span>
343      */
<a name="40" id="anc40"></a><span class="line-modified">344     protected boolean is(char ch) {</span>
<span class="line-modified">345         return character == ch;</span>


346     }
347 
<a name="41" id="anc41"></a><span class="line-modified">348     /**</span>
<span class="line-added">349      * Match one of the arguments. Returns true if a match.</span>
350      */
<a name="42" id="anc42"></a><span class="line-modified">351     protected boolean isOneOf(char ch1, char ch2) {</span>
<span class="line-modified">352         return is(ch1) || is(ch2);</span>
<span class="line-modified">353     }</span>
<span class="line-added">354     protected boolean isOneOf(char ch1, char ch2, char ch3) {</span>
<span class="line-added">355         return is(ch1) || is(ch2) || is(ch3);</span>
<span class="line-added">356     }</span>
<span class="line-added">357     protected boolean isOneOf(char ch1, char ch2, char ch3, char ch4, char ch5, char ch6) {</span>
<span class="line-added">358         return is(ch1) || is(ch2) || is(ch3) || is(ch4) || is(ch5) || is(ch6);</span>
359     }
360 
<a name="43" id="anc43"></a><span class="line-modified">361     /**</span>
<span class="line-modified">362      * Tests to see if current character is in the range of lo to hi characters (inclusive).</span>
<span class="line-modified">363      *</span>
<span class="line-modified">364      * @param lo  lowest character in range.</span>
<span class="line-modified">365      * @param hi  highest character in range.</span>
<span class="line-modified">366      *</span>
<span class="line-modified">367      * @return true if the current character is in range.</span>
<span class="line-modified">368      */</span>
<span class="line-modified">369     protected boolean inRange(char lo, char hi) {</span>
<span class="line-modified">370         return lo &lt;= character &amp;&amp; character &lt;= hi;</span>





















371     }
372 
<a name="44" id="anc44"></a><span class="line-modified">373     /**</span>
<span class="line-added">374      * Compare character and advance if a match. Returns true if a match.</span>
<span class="line-added">375      *</span>
<span class="line-added">376      * @param ch  character to match.</span>
<span class="line-added">377      *</span>
<span class="line-added">378      * @return true if a match.</span>
379      */
<a name="45" id="anc45"></a><span class="line-modified">380     protected boolean accept(char ch) {</span>
<span class="line-modified">381         if (is(ch)) {</span>
<span class="line-modified">382             next();</span>
<span class="line-modified">383 </span>
384             return true;
<a name="46" id="anc46"></a>

385         }
<a name="47" id="anc47"></a><span class="line-added">386 </span>
<span class="line-added">387         return false;</span>
388     }
389 
<a name="48" id="anc48"></a><span class="line-modified">390     /**</span>
<span class="line-modified">391      * Match one of the arguments and advance if a match. Returns true if a match.</span>


392      */
<a name="49" id="anc49"></a><span class="line-modified">393     protected boolean acceptOneOf(char ch1, char ch2) {</span>
<span class="line-modified">394         if (isOneOf(ch1, ch2)) {</span>
<span class="line-modified">395             next();</span>

396 
<a name="50" id="anc50"></a><span class="line-modified">397             return true;</span>
<span class="line-added">398         }</span>
399 
<a name="51" id="anc51"></a><span class="line-modified">400         return false;</span>
<span class="line-added">401     }</span>
402 
<a name="52" id="anc52"></a><span class="line-modified">403     protected boolean acceptOneOf(char ch1, char ch2, char ch3) {</span>
<span class="line-modified">404         if (isOneOf(ch1, ch2, ch3)) {</span>
<span class="line-added">405             next();</span>
406 
<a name="53" id="anc53"></a><span class="line-modified">407             return true;</span>


408         }
409 
<a name="54" id="anc54"></a><span class="line-modified">410         return false;</span>
411     }
412 
<a name="55" id="anc55"></a><span class="line-modified">413     /**</span>
<span class="line-modified">414      * Skip over all occurances of character.</span>
<span class="line-modified">415      *</span>
<span class="line-modified">416      * @param ch character to accept.</span>
<span class="line-modified">417      */</span>
<span class="line-modified">418     protected void skip(char ch) {</span>
<span class="line-modified">419         while (accept(ch)) {</span>
<span class="line-modified">420             // next</span>






421         }
<a name="56" id="anc56"></a>
422     }
423 
<a name="57" id="anc57"></a><span class="line-modified">424     /**</span>
<span class="line-modified">425      * Skip over ASCII white space characters.</span>
<span class="line-added">426      */</span>
<span class="line-added">427     protected void skipWhitespace() {</span>
<span class="line-added">428         while (acceptOneOf(&#39; &#39;, &#39;\t&#39;, &#39;\f&#39;)) {</span>
<span class="line-added">429             // next</span>
<span class="line-added">430         }</span>
431     }
432 
<a name="58" id="anc58"></a><span class="line-modified">433     /**</span>
<span class="line-modified">434      * Skip to end of line.</span>
<span class="line-added">435      */</span>
<span class="line-added">436     protected void skipToEOLN() {</span>
<span class="line-added">437         while (isAvailable()) {</span>
<span class="line-added">438             if (isOneOf(&#39;\r&#39;, &#39;\n&#39;)) {</span>
<span class="line-added">439                 break;</span>
<span class="line-added">440             }</span>
<span class="line-added">441 </span>
<span class="line-added">442             next();</span>
<span class="line-added">443         }</span>
<span class="line-added">444 </span>
445     }
446 
<a name="59" id="anc59"></a><span class="line-modified">447     /**</span>
<span class="line-modified">448      * Compare string and advance if a match. Returns true if a match.</span>
<span class="line-added">449      * Warning: Do not use when previous character was a backslash</span>
<span class="line-added">450      * (confuses state of wasBackslash.)</span>
<span class="line-added">451      *</span>
<span class="line-added">452      * @param string string to match character for character.</span>
<span class="line-added">453      *</span>
<span class="line-added">454      * @return true if a match.</span>
<span class="line-added">455      */</span>
<span class="line-added">456     protected boolean accept(String string) {</span>
<span class="line-added">457         // Quick test.</span>
<span class="line-added">458         if (string.length() == 0 || !is(string.charAt(0))) {</span>
<span class="line-added">459             return false;</span>
<span class="line-added">460         }</span>
<span class="line-added">461 </span>
<span class="line-added">462         // Be prepared to retreat if not a match.</span>
<span class="line-added">463         int savedPosition = position;</span>
<span class="line-added">464 </span>
<span class="line-added">465         nextCodePoint();</span>
<span class="line-added">466 </span>
<span class="line-added">467         // Check each character.</span>
<span class="line-added">468         for (int i = 1; i &lt; string.length(); i++) {</span>
<span class="line-added">469             if (!is(string.charAt(i))) {</span>
<span class="line-added">470                 // Restart if not a match.</span>
<span class="line-added">471                 reset(savedPosition);</span>
<span class="line-added">472 </span>
<span class="line-added">473                 return false;</span>
<span class="line-added">474             }</span>
<span class="line-added">475 </span>
<span class="line-added">476             nextCodePoint();</span>
<span class="line-added">477         }</span>
<span class="line-added">478 </span>
<span class="line-added">479         return true;</span>
480     }
481 
482     /**
<a name="60" id="anc60"></a><span class="line-modified">483      * Convert an ASCII digit from its base (8, 10, or 16) to its value. Does not</span>
<span class="line-modified">484      * advance character.</span>
<span class="line-added">485      *</span>
<span class="line-added">486      * @param pos         starting position.</span>
<span class="line-added">487      * @param digitRadix  base of number being converted.</span>
<span class="line-added">488      *</span>
<span class="line-added">489      * @return value of digit.</span>
<span class="line-added">490      */</span>
<span class="line-added">491     protected int digit(int pos, int digitRadix) {</span>
<span class="line-added">492         int result;</span>
<span class="line-added">493 </span>
<span class="line-added">494         // Just an ASCII digit.</span>
<span class="line-added">495         if (inRange(&#39;0&#39;, &#39;9&#39;)) {</span>
<span class="line-added">496             // Fast common case.</span>
<span class="line-added">497             result = character - &#39;0&#39;;</span>
<span class="line-added">498 </span>
<span class="line-added">499             return result &lt; digitRadix ? result : -1;</span>
<span class="line-added">500         }</span>
<span class="line-added">501 </span>
<span class="line-added">502         // Handle other digits.</span>
<span class="line-added">503         result = isSurrogate() ? Character.digit(codepoint, digitRadix) :</span>
<span class="line-added">504                                  Character.digit(character, digitRadix);</span>
<span class="line-added">505 </span>
<span class="line-added">506         if (result &gt;= 0 &amp;&amp; !isASCII()) {</span>
<span class="line-added">507             log.error(position(), Errors.IllegalNonasciiDigit);</span>
<span class="line-added">508             character = &quot;0123456789abcdef&quot;.charAt(result);</span>
<span class="line-added">509         }</span>
<span class="line-added">510 </span>
<span class="line-added">511         return result;</span>
<span class="line-added">512     }</span>
<span class="line-added">513 </span>
<span class="line-added">514     /**</span>
<span class="line-added">515      * Returns the input buffer. Unicode escape sequences are not translated.</span>
<span class="line-added">516      *</span>
<span class="line-added">517      * @return the input buffer.</span>
518      */
519     public char[] getRawCharacters() {
<a name="61" id="anc61"></a><span class="line-modified">520         return length == buffer.length ? buffer : Arrays.copyOf(buffer, length);</span>


521     }
522 
523     /**
524      * Returns a copy of a character array subset of the input buffer.
525      * The returned array begins at the {@code beginIndex} and
526      * extends to the character at index {@code endIndex - 1}.
527      * Thus the length of the substring is {@code endIndex-beginIndex}.
528      * This behavior is like
529      * {@code String.substring(beginIndex, endIndex)}.
530      * Unicode escape sequences are not translated.
531      *
<a name="62" id="anc62"></a><span class="line-modified">532      * @param  beginIndex the beginning index, inclusive.</span>
<span class="line-modified">533      * @param  endIndex the ending index, exclusive.</span>
<span class="line-added">534      *</span>
535      * @throws ArrayIndexOutOfBoundsException if either offset is outside of the
536      *         array bounds
537      */
538     public char[] getRawCharacters(int beginIndex, int endIndex) {
<a name="63" id="anc63"></a><span class="line-modified">539         return Arrays.copyOfRange(buffer, beginIndex, endIndex);</span>
<span class="line-modified">540     }</span>
<span class="line-modified">541 </span>
<span class="line-modified">542     /**</span>
<span class="line-added">543      * This is a specialized version of UnicodeReader that keeps track of the</span>
<span class="line-added">544      * column position within a given character stream. Used for Javadoc</span>
<span class="line-added">545      * processing to build a table for mapping positions in the comment string</span>
<span class="line-added">546      * to positions in the source file.</span>
<span class="line-added">547      */</span>
<span class="line-added">548     static class PositionTrackingReader extends UnicodeReader {</span>
<span class="line-added">549         /**</span>
<span class="line-added">550          * Offset from the beginning of the original reader buffer.</span>
<span class="line-added">551          */</span>
<span class="line-added">552         private int offset;</span>
<span class="line-added">553 </span>
<span class="line-added">554         /**</span>
<span class="line-added">555          * Current column in the comment.</span>
<span class="line-added">556          */</span>
<span class="line-added">557         private int column;</span>
<span class="line-added">558 </span>
<span class="line-added">559         /**</span>
<span class="line-added">560          * Constructor.</span>
<span class="line-added">561          *</span>
<span class="line-added">562          * @param sf      Scan factory.</span>
<span class="line-added">563          * @param array   Array containing contents of source.</span>
<span class="line-added">564          * @param offset  Position offset in original source buffer.</span>
<span class="line-added">565          */</span>
<span class="line-added">566         protected PositionTrackingReader(ScannerFactory sf, char[] array, int offset) {</span>
<span class="line-added">567             super(sf, array, array.length);</span>
<span class="line-added">568             this.offset = offset;</span>
<span class="line-added">569             this.column = 0;</span>
<span class="line-added">570         }</span>
<span class="line-added">571 </span>
<span class="line-added">572         /**</span>
<span class="line-added">573          * Advances the current character to the next character. Tracks column.</span>
<span class="line-added">574          *</span>
<span class="line-added">575          * @return next character.</span>
<span class="line-added">576          */</span>
<span class="line-added">577         @Override</span>
<span class="line-added">578         protected char next() {</span>
<span class="line-added">579             super.next();</span>
<span class="line-added">580 </span>
<span class="line-added">581             if (isOneOf(&#39;\n&#39;, &#39;\r&#39;, &#39;\f&#39;)) {</span>
<span class="line-added">582                 column = 0;</span>
<span class="line-added">583             } else if (is(&#39;\t&#39;)) {</span>
<span class="line-added">584                 column = tabulate(column);</span>
<span class="line-added">585             } else {</span>
<span class="line-added">586                 column++;</span>
<span class="line-added">587             }</span>
<span class="line-added">588 </span>
<span class="line-added">589             return get();</span>
<span class="line-added">590         }</span>
<span class="line-added">591 </span>
<span class="line-added">592         /**</span>
<span class="line-added">593          * Returns the current column.</span>
<span class="line-added">594          *</span>
<span class="line-added">595          * @return  the current column.</span>
<span class="line-added">596          */</span>
<span class="line-added">597         protected int column() {</span>
<span class="line-added">598             return column;</span>
<span class="line-added">599         }</span>
<span class="line-added">600 </span>
<span class="line-added">601         /**</span>
<span class="line-added">602          * Returns position relative to the original source buffer.</span>
<span class="line-added">603          *</span>
<span class="line-added">604          * @return</span>
<span class="line-added">605          */</span>
<span class="line-added">606         protected int offsetPosition() {</span>
<span class="line-added">607             return position() + offset;</span>
<span class="line-added">608         }</span>
609     }
<a name="64" id="anc64"></a><span class="line-added">610 </span>
611 }
<a name="65" id="anc65"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="65" type="hidden" />
</body>
</html>