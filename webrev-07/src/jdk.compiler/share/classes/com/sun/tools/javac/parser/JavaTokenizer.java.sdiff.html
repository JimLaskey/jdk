<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavaTokenizer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JavadocTokenizer.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavaTokenizer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.parser;
  27 
  28 import com.sun.tools.javac.code.Lint;
  29 import com.sun.tools.javac.code.Lint.LintCategory;
  30 import com.sun.tools.javac.code.Preview;
  31 import com.sun.tools.javac.code.Source;
  32 import com.sun.tools.javac.code.Source.Feature;

  33 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  34 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  35 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  36 import com.sun.tools.javac.util.*;
  37 import com.sun.tools.javac.util.JCDiagnostic.*;
  38 
<span class="line-removed">  39 import java.lang.reflect.InvocationTargetException;</span>
<span class="line-removed">  40 import java.lang.reflect.Method;</span>
  41 import java.nio.CharBuffer;
<span class="line-removed">  42 import java.util.HashSet;</span>
  43 import java.util.Set;

  44 
  45 import static com.sun.tools.javac.parser.Tokens.*;
<span class="line-modified">  46 import static com.sun.tools.javac.util.LayoutCharacters.*;</span>
  47 
<span class="line-modified">  48 /** The lexical analyzer maps an input stream consisting of</span>
<span class="line-modified">  49  *  ASCII characters and Unicode escapes into a token sequence.</span>

  50  *
  51  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  52  *  If you write code that depends on this, you do so at your own risk.
  53  *  This code and its internal interfaces are subject to change or
  54  *  deletion without notice.&lt;/b&gt;
  55  */
<span class="line-modified">  56 public class JavaTokenizer {</span>
<span class="line-modified">  57 </span>


  58     private static final boolean scannerDebug = false;
  59 
<span class="line-modified">  60     /** The source language setting.</span>






  61      */
  62     private Source source;
  63 
<span class="line-modified">  64     /** The preview language setting. */</span>


  65     private Preview preview;
  66 
<span class="line-modified">  67     /** The log to be used for error reporting.</span>

  68      */
  69     private final Log log;
  70 
<span class="line-modified">  71     /** The token factory. */</span>


  72     private final Tokens tokens;
  73 
<span class="line-modified">  74     /** The token kind, set by nextToken().</span>






  75      */
  76     protected TokenKind tk;
  77 
<span class="line-modified">  78     /** The token&#39;s radix, set by nextToken().</span>

  79      */
  80     protected int radix;
  81 
<span class="line-modified">  82     /** The token&#39;s name, set by nextToken().</span>

  83      */
  84     protected Name name;
  85 
<span class="line-modified">  86     /** The position where a lexical error occurred;</span>

  87      */
  88     protected int errPos = Position.NOPOS;
  89 
<span class="line-modified">  90     /** The Unicode reader (low-level stream reader).</span>
<span class="line-modified">  91      */</span>
<span class="line-removed">  92     protected UnicodeReader reader;</span>
<span class="line-removed">  93 </span>
<span class="line-removed">  94     /** If is a text block</span>
  95      */
  96     protected boolean isTextBlock;
  97 
<span class="line-modified">  98     /** If contains escape sequences</span>

  99      */
 100     protected boolean hasEscapeSequences;
 101 








 102     protected ScannerFactory fac;
 103 
<span class="line-modified"> 104     // The set of lint options currently in effect. It is initialized</span>
<span class="line-modified"> 105     // from the context, and then is set/reset as needed by Attr as it</span>
<span class="line-modified"> 106     // visits all the various parts of the trees during attribution.</span>


 107     protected Lint lint;
 108 
<span class="line-removed"> 109     private static final boolean hexFloatsWork = hexFloatsWork();</span>
<span class="line-removed"> 110     private static boolean hexFloatsWork() {</span>
<span class="line-removed"> 111         try {</span>
<span class="line-removed"> 112             Float.valueOf(&quot;0x1.0p1&quot;);</span>
<span class="line-removed"> 113             return true;</span>
<span class="line-removed"> 114         } catch (NumberFormatException ex) {</span>
<span class="line-removed"> 115             return false;</span>
<span class="line-removed"> 116         }</span>
<span class="line-removed"> 117     }</span>
<span class="line-removed"> 118 </span>
 119     /**
<span class="line-modified"> 120      * Create a scanner from the input array.  This method might</span>
<span class="line-removed"> 121      * modify the array.  To avoid copying the input array, ensure</span>
<span class="line-removed"> 122      * that {@code inputLength &lt; input.length} or</span>
<span class="line-removed"> 123      * {@code input[input.length -1]} is a white space character.</span>
 124      *
<span class="line-modified"> 125      * @param fac the factory which created this Scanner</span>
<span class="line-modified"> 126      * @param buf the input, might be modified</span>
<span class="line-removed"> 127      * Must be positive and less than or equal to input.length.</span>
 128      */
<span class="line-modified"> 129     protected JavaTokenizer(ScannerFactory fac, CharBuffer buf) {</span>
<span class="line-modified"> 130         this(fac, new UnicodeReader(fac, buf));</span>
 131     }
 132 
<span class="line-modified"> 133     protected JavaTokenizer(ScannerFactory fac, char[] buf, int inputLength) {</span>
<span class="line-modified"> 134         this(fac, new UnicodeReader(fac, buf, inputLength));</span>
<span class="line-modified"> 135     }</span>
<span class="line-modified"> 136 </span>
<span class="line-modified"> 137     protected JavaTokenizer(ScannerFactory fac, UnicodeReader reader) {</span>




 138         this.fac = fac;
 139         this.log = fac.log;

 140         this.tokens = fac.tokens;
 141         this.source = fac.source;
 142         this.preview = fac.preview;
<span class="line-removed"> 143         this.reader = reader;</span>
 144         this.lint = fac.lint;

 145     }
 146 






 147     protected void checkSourceLevel(int pos, Feature feature) {
 148         if (preview.isPreview(feature) &amp;&amp; !preview.isEnabled()) {
 149             //preview feature without --preview flag, error
 150             lexError(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));
 151         } else if (!feature.allowedInSource(source)) {
 152             //incompatible source level, error
 153             lexError(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));
 154         } else if (preview.isPreview(feature)) {
 155             //use of preview feature, warn
 156             preview.warnPreview(pos, feature);
 157         }
 158     }
 159 
<span class="line-modified"> 160     /** Report an error at the given position using the provided arguments.</span>




 161      */
 162     protected void lexError(int pos, JCDiagnostic.Error key) {
 163         log.error(pos, key);
 164         tk = TokenKind.ERROR;
 165         errPos = pos;
 166     }
 167 







 168     protected void lexError(DiagnosticFlag flags, int pos, JCDiagnostic.Error key) {
 169         log.error(flags, pos, key);
 170         tk = TokenKind.ERROR;
 171         errPos = pos;
 172     }
 173 







 174     protected void lexWarning(LintCategory lc, int pos, JCDiagnostic.Warning key) {
 175         DiagnosticPosition dp = new SimpleDiagnosticPosition(pos) ;
 176         log.warning(lc, dp, key);
 177     }
 178 
<span class="line-modified"> 179     /** Read next character in character or string literal and copy into sbuf.</span>
<span class="line-modified"> 180      *      pos - start of literal offset</span>
<span class="line-modified"> 181      *      translateEscapesNow - true if String::translateEscapes is not available</span>
<span class="line-modified"> 182      *                            in the java.base libs. Occurs during bootstrapping.</span>
<span class="line-removed"> 183      *      multiline - true if scanning a text block. Allows newlines to be embedded</span>
<span class="line-removed"> 184      *                  in the result.</span>
 185      */
<span class="line-modified"> 186     private void scanLitChar(int pos, boolean translateEscapesNow, boolean multiline) {</span>
<span class="line-modified"> 187          if (reader.ch == &#39;\\&#39;) {</span>
<span class="line-removed"> 188             if (reader.peekChar() == &#39;\\&#39; &amp;&amp; !reader.isUnicode()) {</span>
<span class="line-removed"> 189                 reader.skipChar();</span>
<span class="line-removed"> 190                 if (!translateEscapesNow) {</span>
<span class="line-removed"> 191                     reader.putChar(false);</span>
<span class="line-removed"> 192                 }</span>
<span class="line-removed"> 193                 reader.putChar(true);</span>
<span class="line-removed"> 194             } else {</span>
<span class="line-removed"> 195                 reader.nextChar(translateEscapesNow);</span>
<span class="line-removed"> 196                 switch (reader.ch) {</span>
<span class="line-removed"> 197                 case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;:</span>
<span class="line-removed"> 198                 case &#39;4&#39;: case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;:</span>
<span class="line-removed"> 199                     char leadch = reader.ch;</span>
<span class="line-removed"> 200                     int oct = reader.digit(pos, 8);</span>
<span class="line-removed"> 201                     reader.nextChar(translateEscapesNow);</span>
<span class="line-removed"> 202                     if (&#39;0&#39; &lt;= reader.ch &amp;&amp; reader.ch &lt;= &#39;7&#39;) {</span>
<span class="line-removed"> 203                         oct = oct * 8 + reader.digit(pos, 8);</span>
<span class="line-removed"> 204                         reader.nextChar(translateEscapesNow);</span>
<span class="line-removed"> 205                         if (leadch &lt;= &#39;3&#39; &amp;&amp; &#39;0&#39; &lt;= reader.ch &amp;&amp; reader.ch &lt;= &#39;7&#39;) {</span>
<span class="line-removed"> 206                             oct = oct * 8 + reader.digit(pos, 8);</span>
<span class="line-removed"> 207                             reader.nextChar(translateEscapesNow);</span>
<span class="line-removed"> 208                         }</span>
<span class="line-removed"> 209                     }</span>
<span class="line-removed"> 210                     if (translateEscapesNow) {</span>
<span class="line-removed"> 211                         reader.putChar((char)oct);</span>
<span class="line-removed"> 212                     }</span>
<span class="line-removed"> 213                     break;</span>
<span class="line-removed"> 214                 case &#39;b&#39;:</span>
<span class="line-removed"> 215                     reader.putChar(translateEscapesNow ? &#39;\b&#39; : &#39;b&#39;, true); break;</span>
<span class="line-removed"> 216                 case &#39;t&#39;:</span>
<span class="line-removed"> 217                     reader.putChar(translateEscapesNow ? &#39;\t&#39; : &#39;t&#39;, true); break;</span>
<span class="line-removed"> 218                 case &#39;n&#39;:</span>
<span class="line-removed"> 219                     reader.putChar(translateEscapesNow ? &#39;\n&#39; : &#39;n&#39;, true); break;</span>
<span class="line-removed"> 220                 case &#39;f&#39;:</span>
<span class="line-removed"> 221                     reader.putChar(translateEscapesNow ? &#39;\f&#39; : &#39;f&#39;, true); break;</span>
<span class="line-removed"> 222                 case &#39;r&#39;:</span>
<span class="line-removed"> 223                     reader.putChar(translateEscapesNow ? &#39;\r&#39; : &#39;r&#39;, true); break;</span>
<span class="line-removed"> 224                 case &#39;\&#39;&#39;:</span>
<span class="line-removed"> 225                 case &#39;\&quot;&#39;:</span>
<span class="line-removed"> 226                 case &#39;\\&#39;:</span>
<span class="line-removed"> 227                     reader.putChar(true); break;</span>
<span class="line-removed"> 228                 case &#39;s&#39;:</span>
<span class="line-removed"> 229                     checkSourceLevel(reader.bp, Feature.TEXT_BLOCKS);</span>
<span class="line-removed"> 230                     reader.putChar(translateEscapesNow ? &#39; &#39; : &#39;s&#39;, true); break;</span>
<span class="line-removed"> 231                 case &#39;\n&#39;:</span>
<span class="line-removed"> 232                 case &#39;\r&#39;:</span>
<span class="line-removed"> 233                     if (!multiline) {</span>
<span class="line-removed"> 234                         lexError(reader.bp, Errors.IllegalEscChar);</span>
<span class="line-removed"> 235                     } else {</span>
<span class="line-removed"> 236                         checkSourceLevel(reader.bp, Feature.TEXT_BLOCKS);</span>
<span class="line-removed"> 237                         int start = reader.bp;</span>
<span class="line-removed"> 238                         if (reader.ch == &#39;\r&#39; &amp;&amp; reader.peekChar() == &#39;\n&#39;) {</span>
<span class="line-removed"> 239                            reader.nextChar(translateEscapesNow);</span>
<span class="line-removed"> 240                         }</span>
<span class="line-removed"> 241                         reader.nextChar(translateEscapesNow);</span>
<span class="line-removed"> 242                         processLineTerminator(start, reader.bp);</span>
<span class="line-removed"> 243                     }</span>
<span class="line-removed"> 244                     break;</span>
<span class="line-removed"> 245                 default:</span>
<span class="line-removed"> 246                     lexError(reader.bp, Errors.IllegalEscChar);</span>
<span class="line-removed"> 247                 }</span>
<span class="line-removed"> 248             }</span>
<span class="line-removed"> 249         } else if (reader.bp != reader.buflen) {</span>
<span class="line-removed"> 250             reader.putChar(true);</span>
<span class="line-removed"> 251         }</span>
 252     }
 253 
<span class="line-modified"> 254     /** Interim access to String methods used to support text blocks.</span>
<span class="line-modified"> 255      *  Required to handle bootstrapping with pre-text block jdks.</span>
<span class="line-modified"> 256      *  Should be replaced with direct calls in the &#39;next&#39; jdk.</span>

 257      */
<span class="line-modified"> 258     static class TextBlockSupport {</span>
<span class="line-modified"> 259         /** Reflection method to remove incidental indentation.</span>
<span class="line-modified"> 260          */</span>
<span class="line-removed"> 261         private static final Method stripIndent;</span>
 262 
<span class="line-modified"> 263         /** Reflection method to translate escape sequences.</span>
<span class="line-modified"> 264          */</span>
<span class="line-modified"> 265         private static final Method translateEscapes;</span>







 266 
<span class="line-modified"> 267         /** true if stripIndent and translateEscapes are available in the bootstrap jdk.</span>
<span class="line-modified"> 268          */</span>
<span class="line-modified"> 269         private static final boolean hasSupport;</span>



 270 
<span class="line-modified"> 271         /** Get a string method via refection or null if not available.</span>
<span class="line-modified"> 272          */</span>
<span class="line-modified"> 273         private static Method getStringMethodOrNull(String name) {</span>
<span class="line-modified"> 274             try {</span>
<span class="line-modified"> 275                 return String.class.getMethod(name);</span>
<span class="line-removed"> 276             } catch (Exception ex) {</span>
<span class="line-removed"> 277                 // Method not available, return null.</span>
<span class="line-removed"> 278             }</span>
<span class="line-removed"> 279             return null;</span>
<span class="line-removed"> 280         }</span>
 281 
<span class="line-modified"> 282         static {</span>
<span class="line-modified"> 283             // Get text block string methods.</span>
<span class="line-removed"> 284             stripIndent = getStringMethodOrNull(&quot;stripIndent&quot;);</span>
<span class="line-removed"> 285             translateEscapes = getStringMethodOrNull(&quot;translateEscapes&quot;);</span>
<span class="line-removed"> 286             // true if stripIndent and translateEscapes are available in the bootstrap jdk.</span>
<span class="line-removed"> 287             hasSupport = stripIndent != null &amp;&amp; translateEscapes != null;</span>
<span class="line-removed"> 288         }</span>
 289 
<span class="line-modified"> 290         /** Return true if stripIndent and translateEscapes are available in the bootstrap jdk.</span>
<span class="line-modified"> 291          */</span>
<span class="line-modified"> 292         static boolean hasSupport() {</span>
<span class="line-modified"> 293             return hasSupport;</span>
<span class="line-modified"> 294         }</span>







 295 
<span class="line-modified"> 296         /** Return the leading whitespace count (indentation) of the line.</span>
<span class="line-removed"> 297          */</span>
<span class="line-removed"> 298         private static int indent(String line) {</span>
<span class="line-removed"> 299             return line.length() - line.stripLeading().length();</span>
 300         }
 301 
<span class="line-modified"> 302         enum WhitespaceChecks {</span>
<span class="line-modified"> 303             INCONSISTENT,</span>
<span class="line-removed"> 304             TRAILING</span>
<span class="line-removed"> 305         };</span>
 306 
<span class="line-modified"> 307         /** Check that the use of white space in content is not problematic.</span>
<span class="line-modified"> 308          */</span>
<span class="line-modified"> 309         static Set&lt;WhitespaceChecks&gt; checkWhitespace(String string) {</span>
<span class="line-modified"> 310             // Start with empty result set.</span>
<span class="line-modified"> 311             Set&lt;WhitespaceChecks&gt; checks = new HashSet&lt;&gt;();</span>
<span class="line-modified"> 312             // No need to check empty strings.</span>
<span class="line-modified"> 313             if (string.isEmpty()) {</span>
<span class="line-modified"> 314                 return checks;</span>
<span class="line-modified"> 315             }</span>
<span class="line-modified"> 316             // Maximum common indentation.</span>
<span class="line-modified"> 317             int outdent = 0;</span>
<span class="line-modified"> 318             // No need to check indentation if opting out (last line is empty.)</span>
<span class="line-modified"> 319             char lastChar = string.charAt(string.length() - 1);</span>
<span class="line-removed"> 320             boolean optOut = lastChar == &#39;\n&#39; || lastChar == &#39;\r&#39;;</span>
<span class="line-removed"> 321             // Split string based at line terminators.</span>
<span class="line-removed"> 322             String[] lines = string.split(&quot;\\R&quot;);</span>
<span class="line-removed"> 323             int length = lines.length;</span>
<span class="line-removed"> 324             // Extract last line.</span>
<span class="line-removed"> 325             String lastLine = length == 0 ? &quot;&quot; : lines[length - 1];</span>
<span class="line-removed"> 326              if (!optOut) {</span>
<span class="line-removed"> 327                 // Prime with the last line indentation (may be blank.)</span>
<span class="line-removed"> 328                 outdent = indent(lastLine);</span>
<span class="line-removed"> 329                 for (String line : lines) {</span>
<span class="line-removed"> 330                     // Blanks lines have no influence (last line accounted for.)</span>
<span class="line-removed"> 331                     if (!line.isBlank()) {</span>
<span class="line-removed"> 332                         outdent = Integer.min(outdent, indent(line));</span>
<span class="line-removed"> 333                         if (outdent == 0) {</span>
<span class="line-removed"> 334                             break;</span>
<span class="line-removed"> 335                         }</span>
<span class="line-removed"> 336                     }</span>
<span class="line-removed"> 337                 }</span>
<span class="line-removed"> 338             }</span>
<span class="line-removed"> 339             // Last line is representative.</span>
<span class="line-removed"> 340             String start = lastLine.substring(0, outdent);</span>
<span class="line-removed"> 341             for (String line : lines) {</span>
<span class="line-removed"> 342                 // Fail if a line does not have the same indentation.</span>
<span class="line-removed"> 343                 if (!line.isBlank() &amp;&amp; !line.startsWith(start)) {</span>
<span class="line-removed"> 344                     // Mix of different white space</span>
<span class="line-removed"> 345                     checks.add(WhitespaceChecks.INCONSISTENT);</span>
<span class="line-removed"> 346                 }</span>
<span class="line-removed"> 347                 // Line has content even after indent is removed.</span>
<span class="line-removed"> 348                 if (outdent &lt; line.length()) {</span>
<span class="line-removed"> 349                     // Is the last character a white space.</span>
<span class="line-removed"> 350                     lastChar = line.charAt(line.length() - 1);</span>
<span class="line-removed"> 351                     if (Character.isWhitespace(lastChar)) {</span>
<span class="line-removed"> 352                         // Has trailing white space.</span>
<span class="line-removed"> 353                         checks.add(WhitespaceChecks.TRAILING);</span>
<span class="line-removed"> 354                     }</span>
<span class="line-removed"> 355                 }</span>
<span class="line-removed"> 356             }</span>
<span class="line-removed"> 357             return checks;</span>
<span class="line-removed"> 358         }</span>
 359 
<span class="line-modified"> 360         /** Invoke String::stripIndent through reflection.</span>
<span class="line-removed"> 361          */</span>
<span class="line-removed"> 362         static String stripIndent(String string) {</span>
<span class="line-removed"> 363             try {</span>
<span class="line-removed"> 364                 string = (String)stripIndent.invoke(string);</span>
<span class="line-removed"> 365             } catch (InvocationTargetException | IllegalAccessException ex) {</span>
<span class="line-removed"> 366                 throw new RuntimeException(ex);</span>
<span class="line-removed"> 367             }</span>
<span class="line-removed"> 368             return string;</span>
 369         }
 370 
<span class="line-modified"> 371         /** Invoke String::translateEscapes through reflection.</span>
<span class="line-removed"> 372          */</span>
<span class="line-removed"> 373         static String translateEscapes(String string) {</span>
<span class="line-removed"> 374             try {</span>
<span class="line-removed"> 375                 string = (String)translateEscapes.invoke(string);</span>
<span class="line-removed"> 376             } catch (InvocationTargetException | IllegalAccessException ex) {</span>
<span class="line-removed"> 377                 throw new RuntimeException(ex);</span>
<span class="line-removed"> 378             }</span>
<span class="line-removed"> 379             return string;</span>
<span class="line-removed"> 380         }</span>
 381     }
 382 
<span class="line-modified"> 383     /** Test for EOLN.</span>



 384      */
 385     private boolean isEOLN() {
<span class="line-modified"> 386         return reader.ch == LF || reader.ch == CR;</span>
 387     }
 388 
<span class="line-modified"> 389     /** Test for CRLF.</span>

 390      */
<span class="line-modified"> 391     private boolean isCRLF() {</span>
<span class="line-modified"> 392         return reader.ch == CR &amp;&amp; reader.peekChar() == LF;</span>



 393     }
 394 
<span class="line-modified"> 395     /** Count and skip repeated occurrences of the specified character.</span>





 396      */
<span class="line-modified"> 397     private int countChar(char ch, int max) {</span>
<span class="line-modified"> 398         int count = 0;</span>
<span class="line-modified"> 399         for ( ; count &lt; max &amp;&amp; reader.bp &lt; reader.buflen &amp;&amp; reader.ch == ch; count++) {</span>
<span class="line-removed"> 400             reader.scanChar();</span>
<span class="line-removed"> 401         }</span>
<span class="line-removed"> 402         return count;</span>
<span class="line-removed"> 403     }</span>
 404 
<span class="line-modified"> 405     /** Skip and process a line terminator.</span>
<span class="line-modified"> 406      */</span>
<span class="line-modified"> 407     private void skipLineTerminator() {</span>
<span class="line-modified"> 408         int start = reader.bp;</span>
<span class="line-modified"> 409         if (isCRLF()) {</span>
<span class="line-modified"> 410             reader.scanChar();</span>










































 411         }
<span class="line-removed"> 412         reader.scanChar();</span>
<span class="line-removed"> 413         processLineTerminator(start, reader.bp);</span>
 414     }
 415 
<span class="line-modified"> 416     /** Scan a string literal or text block.</span>



 417      */
 418     private void scanString(int pos) {
<span class="line-modified"> 419         // Clear flags.</span>
<span class="line-modified"> 420         isTextBlock = false;</span>
<span class="line-removed"> 421         hasEscapeSequences = false;</span>
 422         // Track the end of first line for error recovery.
<span class="line-modified"> 423         int firstEOLN = -1;</span>
<span class="line-modified"> 424         // Attempt to scan for up to 3 double quotes.</span>
<span class="line-modified"> 425         int openCount = countChar(&#39;\&quot;&#39;, 3);</span>
<span class="line-modified"> 426         switch (openCount) {</span>
<span class="line-modified"> 427         case 1: // Starting a string literal.</span>
<span class="line-removed"> 428             break;</span>
<span class="line-removed"> 429         case 2: // Starting an empty string literal.</span>
<span class="line-removed"> 430             tk = Tokens.TokenKind.STRINGLITERAL;</span>
<span class="line-removed"> 431             return;</span>
<span class="line-removed"> 432         case 3: // Starting a text block.</span>
 433             // Check if preview feature is enabled for text blocks.
 434             checkSourceLevel(pos, Feature.TEXT_BLOCKS);
<span class="line-modified"> 435             isTextBlock = true;</span>
 436             // Verify the open delimiter sequence.
<span class="line-modified"> 437             while (reader.bp &lt; reader.buflen) {</span>
<span class="line-modified"> 438                 char ch = reader.ch;</span>
<span class="line-modified"> 439                 if (ch != &#39; &#39; &amp;&amp; ch != &#39;\t&#39; &amp;&amp; ch != FF) {</span>
<span class="line-removed"> 440                     break;</span>
<span class="line-removed"> 441                 }</span>
<span class="line-removed"> 442                 reader.scanChar();</span>
<span class="line-removed"> 443             }</span>
 444             if (isEOLN()) {
 445                 skipLineTerminator();
 446             } else {
<span class="line-modified"> 447                 // Error if the open delimiter sequence is not</span>
<span class="line-removed"> 448                 //     &quot;&quot;&quot;&lt;white space&gt;*&lt;LineTerminator&gt;.</span>
<span class="line-removed"> 449                 lexError(reader.bp, Errors.IllegalTextBlockOpen);</span>
 450                 return;
 451             }
<span class="line-modified"> 452             break;</span>
<span class="line-modified"> 453         }</span>
<span class="line-modified"> 454         // While characters are available.</span>
<span class="line-modified"> 455         while (reader.bp &lt; reader.buflen) {</span>
<span class="line-removed"> 456             // If possible close delimiter sequence.</span>
<span class="line-removed"> 457             if (reader.ch == &#39;\&quot;&#39;) {</span>
<span class="line-removed"> 458                 // Check to see if enough double quotes are present.</span>
<span class="line-removed"> 459                 int closeCount = countChar(&#39;\&quot;&#39;, openCount);</span>
<span class="line-removed"> 460                 if (openCount == closeCount) {</span>
<span class="line-removed"> 461                     // Good result.</span>
<span class="line-removed"> 462                     tk = Tokens.TokenKind.STRINGLITERAL;</span>
 463                     return;
 464                 }
<span class="line-modified"> 465                 // False alarm, add double quotes to string buffer.</span>
<span class="line-modified"> 466                 reader.repeat(&#39;\&quot;&#39;, closeCount);</span>
<span class="line-modified"> 467             } else if (isEOLN()) {</span>
<span class="line-modified"> 468                 // Line terminator in string literal is an error.</span>
<span class="line-modified"> 469                 // Fall out to unclosed string literal error.</span>
<span class="line-modified"> 470                 if (openCount == 1) {</span>
<span class="line-modified"> 471                     break;</span>






 472                 }
<span class="line-modified"> 473                 skipLineTerminator();</span>
<span class="line-modified"> 474                 // Add line terminator to string buffer.</span>
<span class="line-modified"> 475                 reader.putChar(&#39;\n&#39;, false);</span>
<span class="line-modified"> 476                 // Record first line terminator for error recovery.</span>
<span class="line-modified"> 477                 if (firstEOLN == -1) {</span>
<span class="line-modified"> 478                     firstEOLN = reader.bp;</span>












 479                 }
<span class="line-removed"> 480             } else if (reader.ch == &#39;\\&#39;) {</span>
<span class="line-removed"> 481                 // Handle escape sequences.</span>
<span class="line-removed"> 482                 hasEscapeSequences = true;</span>
<span class="line-removed"> 483                 // Translate escapes immediately if TextBlockSupport is not available</span>
<span class="line-removed"> 484                 // during bootstrapping.</span>
<span class="line-removed"> 485                 boolean translateEscapesNow = !TextBlockSupport.hasSupport();</span>
<span class="line-removed"> 486                 scanLitChar(pos, translateEscapesNow, openCount != 1);</span>
<span class="line-removed"> 487             } else {</span>
<span class="line-removed"> 488                 // Add character to string buffer.</span>
<span class="line-removed"> 489                 reader.putChar(true);</span>
 490             }
 491         }

 492         // String ended without close delimiter sequence.
<span class="line-modified"> 493         lexError(pos, openCount == 1 ? Errors.UnclosedStrLit : Errors.UnclosedTextBlock);</span>
<span class="line-modified"> 494         if (firstEOLN  != -1) {</span>
<span class="line-modified"> 495             // Reset recovery position to point after open delimiter sequence.</span>
<span class="line-modified"> 496             reader.reset(firstEOLN);</span>

 497         }
 498     }
 499 






 500     private void scanDigits(int pos, int digitRadix) {
<span class="line-modified"> 501         char saveCh;</span>
<span class="line-modified"> 502         int savePos;</span>

 503         do {
<span class="line-modified"> 504             if (reader.ch != &#39;_&#39;) {</span>
<span class="line-modified"> 505                 reader.putChar(false);</span>



 506             }
<span class="line-modified"> 507             saveCh = reader.ch;</span>
<span class="line-modified"> 508             savePos = reader.bp;</span>
<span class="line-modified"> 509             reader.scanChar();</span>
<span class="line-modified"> 510         } while (reader.digit(pos, digitRadix) &gt;= 0 || reader.ch == &#39;_&#39;);</span>
<span class="line-modified"> 511         if (saveCh == &#39;_&#39;)</span>
<span class="line-modified"> 512             lexError(savePos, Errors.IllegalUnderscore);</span>



 513     }
 514 
<span class="line-modified"> 515     /** Read fractional part of hexadecimal floating point number.</span>



 516      */
 517     private void scanHexExponentAndSuffix(int pos) {
<span class="line-modified"> 518         if (reader.ch == &#39;p&#39; || reader.ch == &#39;P&#39;) {</span>
<span class="line-removed"> 519             reader.putChar(true);</span>
 520             skipIllegalUnderscores();
<span class="line-modified"> 521             if (reader.ch == &#39;+&#39; || reader.ch == &#39;-&#39;) {</span>
<span class="line-removed"> 522                 reader.putChar(true);</span>
<span class="line-removed"> 523             }</span>
 524             skipIllegalUnderscores();
<span class="line-modified"> 525             if (reader.digit(pos, 10) &gt;= 0) {</span>

 526                 scanDigits(pos, 10);
<span class="line-modified"> 527                 if (!hexFloatsWork)</span>
<span class="line-removed"> 528                     lexError(pos, Errors.UnsupportedCrossFpLit);</span>
<span class="line-removed"> 529             } else</span>
 530                 lexError(pos, Errors.MalformedFpLit);

 531         } else {
 532             lexError(pos, Errors.MalformedFpLit);
 533         }
<span class="line-modified"> 534         if (reader.ch == &#39;f&#39; || reader.ch == &#39;F&#39;) {</span>
<span class="line-modified"> 535             reader.putChar(true);</span>
 536             tk = TokenKind.FLOATLITERAL;
 537             radix = 16;
 538         } else {
<span class="line-modified"> 539             if (reader.ch == &#39;d&#39; || reader.ch == &#39;D&#39;) {</span>
<span class="line-removed"> 540                 reader.putChar(true);</span>
<span class="line-removed"> 541             }</span>
 542             tk = TokenKind.DOUBLELITERAL;
 543             radix = 16;
 544         }
 545     }
 546 
<span class="line-modified"> 547     /** Read fractional part of floating point number.</span>



 548      */
 549     private void scanFraction(int pos) {
 550         skipIllegalUnderscores();
<span class="line-modified"> 551         if (reader.digit(pos, 10) &gt;= 0) {</span>

 552             scanDigits(pos, 10);
 553         }
<span class="line-modified"> 554         int sp1 = reader.sp;</span>
<span class="line-modified"> 555         if (reader.ch == &#39;e&#39; || reader.ch == &#39;E&#39;) {</span>
<span class="line-modified"> 556             reader.putChar(true);</span>

 557             skipIllegalUnderscores();
<span class="line-modified"> 558             if (reader.ch == &#39;+&#39; || reader.ch == &#39;-&#39;) {</span>
<span class="line-removed"> 559                 reader.putChar(true);</span>
<span class="line-removed"> 560             }</span>
 561             skipIllegalUnderscores();
<span class="line-modified"> 562             if (reader.digit(pos, 10) &gt;= 0) {</span>

 563                 scanDigits(pos, 10);
 564                 return;
 565             }

 566             lexError(pos, Errors.MalformedFpLit);
<span class="line-modified"> 567             reader.sp = sp1;</span>
 568         }
 569     }
 570 
<span class="line-modified"> 571     /** Read fractional part and &#39;d&#39; or &#39;f&#39; suffix of floating point number.</span>



 572      */
 573     private void scanFractionAndSuffix(int pos) {
 574         radix = 10;
 575         scanFraction(pos);
<span class="line-modified"> 576         if (reader.ch == &#39;f&#39; || reader.ch == &#39;F&#39;) {</span>
<span class="line-modified"> 577             reader.putChar(true);</span>
<span class="line-modified"> 578             tk = TokenKind.FLOATLITERAL;</span>
 579         } else {
<span class="line-modified"> 580             if (reader.ch == &#39;d&#39; || reader.ch == &#39;D&#39;) {</span>
<span class="line-removed"> 581                 reader.putChar(true);</span>
<span class="line-removed"> 582             }</span>
 583             tk = TokenKind.DOUBLELITERAL;
 584         }
 585     }
 586 
<span class="line-modified"> 587     /** Read fractional part and &#39;d&#39; or &#39;f&#39; suffix of floating point number.</span>



 588      */
 589     private void scanHexFractionAndSuffix(int pos, boolean seendigit) {
 590         radix = 16;
<span class="line-modified"> 591         Assert.check(reader.ch == &#39;.&#39;);</span>
<span class="line-modified"> 592         reader.putChar(true);</span>
 593         skipIllegalUnderscores();
<span class="line-modified"> 594         if (reader.digit(pos, 16) &gt;= 0) {</span>

 595             seendigit = true;
 596             scanDigits(pos, 16);
 597         }

 598         if (!seendigit)
 599             lexError(pos, Errors.InvalidHexNumber);
 600         else
 601             scanHexExponentAndSuffix(pos);
 602     }
 603 



 604     private void skipIllegalUnderscores() {
<span class="line-modified"> 605         if (reader.ch == &#39;_&#39;) {</span>
<span class="line-modified"> 606             lexError(reader.bp, Errors.IllegalUnderscore);</span>
<span class="line-modified"> 607             while (reader.ch == &#39;_&#39;)</span>
<span class="line-removed"> 608                 reader.scanChar();</span>
 609         }
 610     }
 611 
<span class="line-modified"> 612     /** Read a number.</span>
<span class="line-modified"> 613      *  @param radix  The radix of the number; one of 2, 8, 10, 16.</span>



 614      */
 615     private void scanNumber(int pos, int radix) {
 616         // for octal, allow base-10 digit in case it&#39;s a float literal
 617         this.radix = radix;
 618         int digitRadix = (radix == 8 ? 10 : radix);
<span class="line-modified"> 619         int firstDigit = reader.digit(pos, Math.max(10, digitRadix));</span>
 620         boolean seendigit = firstDigit &gt;= 0;
 621         boolean seenValidDigit = firstDigit &gt;= 0 &amp;&amp; firstDigit &lt; digitRadix;

 622         if (seendigit) {
 623             scanDigits(pos, digitRadix);
 624         }
<span class="line-modified"> 625         if (radix == 16 &amp;&amp; reader.ch == &#39;.&#39;) {</span>

 626             scanHexFractionAndSuffix(pos, seendigit);
<span class="line-modified"> 627         } else if (seendigit &amp;&amp; radix == 16 &amp;&amp; (reader.ch == &#39;p&#39; || reader.ch == &#39;P&#39;)) {</span>
 628             scanHexExponentAndSuffix(pos);
<span class="line-modified"> 629         } else if (digitRadix == 10 &amp;&amp; reader.ch == &#39;.&#39;) {</span>
<span class="line-modified"> 630             reader.putChar(true);</span>
 631             scanFractionAndSuffix(pos);
<span class="line-modified"> 632         } else if (digitRadix == 10 &amp;&amp;</span>
<span class="line-removed"> 633                    (reader.ch == &#39;e&#39; || reader.ch == &#39;E&#39; ||</span>
<span class="line-removed"> 634                     reader.ch == &#39;f&#39; || reader.ch == &#39;F&#39; ||</span>
<span class="line-removed"> 635                     reader.ch == &#39;d&#39; || reader.ch == &#39;D&#39;)) {</span>
 636             scanFractionAndSuffix(pos);
 637         } else {
 638             if (!seenValidDigit) {
 639                 switch (radix) {
 640                 case 2:
 641                     lexError(pos, Errors.InvalidBinaryNumber);
 642                     break;
 643                 case 16:
 644                     lexError(pos, Errors.InvalidHexNumber);
 645                     break;
 646                 }
 647             }
<span class="line-modified"> 648             if (reader.ch == &#39;l&#39; || reader.ch == &#39;L&#39;) {</span>
<span class="line-modified"> 649                 reader.scanChar();</span>
 650                 tk = TokenKind.LONGLITERAL;
 651             } else {
 652                 tk = TokenKind.INTLITERAL;
 653             }
 654         }
 655     }
 656 
<span class="line-modified"> 657     /** Read an identifier.</span>









 658      */
 659     private void scanIdent() {
<span class="line-modified"> 660         boolean isJavaIdentifierPart;</span>
<span class="line-modified"> 661         char high;</span>
<span class="line-removed"> 662         reader.putChar(true);</span>
 663         do {
<span class="line-modified"> 664             switch (reader.ch) {</span>
 665             case &#39;A&#39;: case &#39;B&#39;: case &#39;C&#39;: case &#39;D&#39;: case &#39;E&#39;:
 666             case &#39;F&#39;: case &#39;G&#39;: case &#39;H&#39;: case &#39;I&#39;: case &#39;J&#39;:
 667             case &#39;K&#39;: case &#39;L&#39;: case &#39;M&#39;: case &#39;N&#39;: case &#39;O&#39;:
 668             case &#39;P&#39;: case &#39;Q&#39;: case &#39;R&#39;: case &#39;S&#39;: case &#39;T&#39;:
 669             case &#39;U&#39;: case &#39;V&#39;: case &#39;W&#39;: case &#39;X&#39;: case &#39;Y&#39;:
 670             case &#39;Z&#39;:
 671             case &#39;a&#39;: case &#39;b&#39;: case &#39;c&#39;: case &#39;d&#39;: case &#39;e&#39;:
 672             case &#39;f&#39;: case &#39;g&#39;: case &#39;h&#39;: case &#39;i&#39;: case &#39;j&#39;:
 673             case &#39;k&#39;: case &#39;l&#39;: case &#39;m&#39;: case &#39;n&#39;: case &#39;o&#39;:
 674             case &#39;p&#39;: case &#39;q&#39;: case &#39;r&#39;: case &#39;s&#39;: case &#39;t&#39;:
 675             case &#39;u&#39;: case &#39;v&#39;: case &#39;w&#39;: case &#39;x&#39;: case &#39;y&#39;:
 676             case &#39;z&#39;:
 677             case &#39;$&#39;: case &#39;_&#39;:
 678             case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
 679             case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:
 680                 break;

 681             case &#39;\u0000&#39;: case &#39;\u0001&#39;: case &#39;\u0002&#39;: case &#39;\u0003&#39;:
 682             case &#39;\u0004&#39;: case &#39;\u0005&#39;: case &#39;\u0006&#39;: case &#39;\u0007&#39;:
 683             case &#39;\u0008&#39;: case &#39;\u000E&#39;: case &#39;\u000F&#39;: case &#39;\u0010&#39;:
 684             case &#39;\u0011&#39;: case &#39;\u0012&#39;: case &#39;\u0013&#39;: case &#39;\u0014&#39;:
 685             case &#39;\u0015&#39;: case &#39;\u0016&#39;: case &#39;\u0017&#39;:
 686             case &#39;\u0018&#39;: case &#39;\u0019&#39;: case &#39;\u001B&#39;:
 687             case &#39;\u007F&#39;:
<span class="line-modified"> 688                 reader.scanChar();</span>
 689                 continue;

 690             case &#39;\u001A&#39;: // EOI is also a legal identifier part
<span class="line-modified"> 691                 if (reader.bp &gt;= reader.buflen) {</span>
<span class="line-modified"> 692                     name = reader.name();</span>
<span class="line-modified"> 693                     tk = tokens.lookupKind(name);</span>
<span class="line-removed"> 694                     return;</span>
 695                 }
<span class="line-modified"> 696                 reader.scanChar();</span>
<span class="line-modified"> 697                 continue;</span>


 698             default:
<span class="line-modified"> 699                 if (reader.ch &lt; &#39;\u0080&#39;) {</span>


 700                     // all ASCII range chars already handled, above
 701                     isJavaIdentifierPart = false;
 702                 } else {
<span class="line-modified"> 703                     if (Character.isIdentifierIgnorable(reader.ch)) {</span>
<span class="line-modified"> 704                         reader.scanChar();</span>
 705                         continue;
<span class="line-removed"> 706                     } else {</span>
<span class="line-removed"> 707                         int codePoint = reader.peekSurrogates();</span>
<span class="line-removed"> 708                         if (codePoint &gt;= 0) {</span>
<span class="line-removed"> 709                             if (isJavaIdentifierPart = Character.isJavaIdentifierPart(codePoint)) {</span>
<span class="line-removed"> 710                                 reader.putChar(true);</span>
<span class="line-removed"> 711                             }</span>
<span class="line-removed"> 712                         } else {</span>
<span class="line-removed"> 713                             isJavaIdentifierPart = Character.isJavaIdentifierPart(reader.ch);</span>
<span class="line-removed"> 714                         }</span>
 715                     }




 716                 }

 717                 if (!isJavaIdentifierPart) {
<span class="line-modified"> 718                     name = reader.name();</span>
<span class="line-removed"> 719                     tk = tokens.lookupKind(name);</span>
 720                     return;
 721                 }
 722             }
<span class="line-modified"> 723             reader.putChar(true);</span>

 724         } while (true);
 725     }
 726 
<span class="line-modified"> 727     /** Return true if reader.ch can be part of an operator.</span>





 728      */
 729     private boolean isSpecial(char ch) {
 730         switch (ch) {
 731         case &#39;!&#39;: case &#39;%&#39;: case &#39;&amp;&#39;: case &#39;*&#39;: case &#39;?&#39;:
 732         case &#39;+&#39;: case &#39;-&#39;: case &#39;:&#39;: case &#39;&lt;&#39;: case &#39;=&#39;:
 733         case &#39;&gt;&#39;: case &#39;^&#39;: case &#39;|&#39;: case &#39;~&#39;:
 734         case &#39;@&#39;:
 735             return true;

 736         default:
 737             return false;
 738         }
 739     }
 740 
<span class="line-modified"> 741     /** Read longest possible sequence of special characters and convert</span>
<span class="line-modified"> 742      *  to token.</span>
 743      */
 744     private void scanOperator() {
 745         while (true) {
<span class="line-modified"> 746             reader.putChar(false);</span>
<span class="line-modified"> 747             Name newname = reader.name();</span>
<span class="line-modified"> 748             TokenKind tk1 = tokens.lookupKind(newname);</span>
<span class="line-modified"> 749             if (tk1 == TokenKind.IDENTIFIER) {</span>
<span class="line-modified"> 750                 reader.sp--;</span>







 751                 break;
 752             }
<span class="line-removed"> 753             tk = tk1;</span>
<span class="line-removed"> 754             reader.scanChar();</span>
<span class="line-removed"> 755             if (!isSpecial(reader.ch)) break;</span>
 756         }
 757     }
 758 
<span class="line-modified"> 759     /** Read token.</span>

 760      */
 761     public Token readToken() {
<span class="line-modified"> 762 </span>
<span class="line-removed"> 763         reader.sp = 0;</span>
 764         name = null;
 765         radix = 0;


 766 
<span class="line-modified"> 767         int pos = 0;</span>
<span class="line-removed"> 768         int endPos = 0;</span>
 769         List&lt;Comment&gt; comments = null;
 770 
 771         try {
 772             loop: while (true) {
<span class="line-modified"> 773                 pos = reader.bp;</span>
<span class="line-modified"> 774                 switch (reader.ch) {</span>
<span class="line-modified"> 775                 case &#39; &#39;: // (Spec 3.6)</span>

 776                 case &#39;\t&#39;: // (Spec 3.6)
<span class="line-modified"> 777                 case FF: // (Spec 3.6)</span>
<span class="line-modified"> 778                     do {</span>
<span class="line-modified"> 779                         reader.scanChar();</span>
<span class="line-removed"> 780                     } while (reader.ch == &#39; &#39; || reader.ch == &#39;\t&#39; || reader.ch == FF);</span>
<span class="line-removed"> 781                     processWhiteSpace(pos, reader.bp);</span>
 782                     break;
<span class="line-modified"> 783                 case LF: // (Spec 3.4)</span>
<span class="line-modified"> 784                     reader.scanChar();</span>
<span class="line-modified"> 785                     processLineTerminator(pos, reader.bp);</span>

 786                     break;
<span class="line-modified"> 787                 case CR: // (Spec 3.4)</span>
<span class="line-modified"> 788                     reader.scanChar();</span>
<span class="line-modified"> 789                     if (reader.ch == LF) {</span>
<span class="line-modified"> 790                         reader.scanChar();</span>
<span class="line-modified"> 791                     }</span>
<span class="line-removed"> 792                     processLineTerminator(pos, reader.bp);</span>
 793                     break;

 794                 case &#39;A&#39;: case &#39;B&#39;: case &#39;C&#39;: case &#39;D&#39;: case &#39;E&#39;:
 795                 case &#39;F&#39;: case &#39;G&#39;: case &#39;H&#39;: case &#39;I&#39;: case &#39;J&#39;:
 796                 case &#39;K&#39;: case &#39;L&#39;: case &#39;M&#39;: case &#39;N&#39;: case &#39;O&#39;:
 797                 case &#39;P&#39;: case &#39;Q&#39;: case &#39;R&#39;: case &#39;S&#39;: case &#39;T&#39;:
 798                 case &#39;U&#39;: case &#39;V&#39;: case &#39;W&#39;: case &#39;X&#39;: case &#39;Y&#39;:
 799                 case &#39;Z&#39;:
 800                 case &#39;a&#39;: case &#39;b&#39;: case &#39;c&#39;: case &#39;d&#39;: case &#39;e&#39;:
 801                 case &#39;f&#39;: case &#39;g&#39;: case &#39;h&#39;: case &#39;i&#39;: case &#39;j&#39;:
 802                 case &#39;k&#39;: case &#39;l&#39;: case &#39;m&#39;: case &#39;n&#39;: case &#39;o&#39;:
 803                 case &#39;p&#39;: case &#39;q&#39;: case &#39;r&#39;: case &#39;s&#39;: case &#39;t&#39;:
 804                 case &#39;u&#39;: case &#39;v&#39;: case &#39;w&#39;: case &#39;x&#39;: case &#39;y&#39;:
 805                 case &#39;z&#39;:
<span class="line-modified"> 806                 case &#39;$&#39;: case &#39;_&#39;:</span>
 807                     scanIdent();
 808                     break loop;
<span class="line-modified"> 809                 case &#39;0&#39;:</span>
<span class="line-modified"> 810                     reader.scanChar();</span>
<span class="line-modified"> 811                     if (reader.ch == &#39;x&#39; || reader.ch == &#39;X&#39;) {</span>
<span class="line-modified"> 812                         reader.scanChar();</span>

 813                         skipIllegalUnderscores();
 814                         scanNumber(pos, 16);
<span class="line-modified"> 815                     } else if (reader.ch == &#39;b&#39; || reader.ch == &#39;B&#39;) {</span>
<span class="line-removed"> 816                         reader.scanChar();</span>
 817                         skipIllegalUnderscores();
 818                         scanNumber(pos, 2);
 819                     } else {
<span class="line-modified"> 820                         reader.putChar(&#39;0&#39;);</span>
<span class="line-modified"> 821                         if (reader.ch == &#39;_&#39;) {</span>
<span class="line-modified"> 822                             int savePos = reader.bp;</span>
<span class="line-modified"> 823                             do {</span>
<span class="line-modified"> 824                                 reader.scanChar();</span>
<span class="line-modified"> 825                             } while (reader.ch == &#39;_&#39;);</span>
<span class="line-modified"> 826                             if (reader.digit(pos, 10) &lt; 0) {</span>
 827                                 lexError(savePos, Errors.IllegalUnderscore);
 828                             }
 829                         }

 830                         scanNumber(pos, 8);
 831                     }
 832                     break loop;

 833                 case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
<span class="line-modified"> 834                 case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:</span>
 835                     scanNumber(pos, 10);
 836                     break loop;
<span class="line-modified"> 837                 case &#39;.&#39;:</span>
<span class="line-modified"> 838                     reader.scanChar();</span>
<span class="line-modified"> 839                     if (reader.digit(pos, 10) &gt;= 0) {</span>
<span class="line-modified"> 840                         reader.putChar(&#39;.&#39;);</span>
<span class="line-modified"> 841                         scanFractionAndSuffix(pos);</span>
<span class="line-modified"> 842                     } else if (reader.ch == &#39;.&#39;) {</span>
<span class="line-modified"> 843                         int savePos = reader.bp;</span>
<span class="line-modified"> 844                         reader.putChar(&#39;.&#39;); reader.putChar(&#39;.&#39;, true);</span>
<span class="line-modified"> 845                         if (reader.ch == &#39;.&#39;) {</span>
<span class="line-modified"> 846                             reader.scanChar();</span>
<span class="line-removed"> 847                             reader.putChar(&#39;.&#39;);</span>
<span class="line-removed"> 848                             tk = TokenKind.ELLIPSIS;</span>
<span class="line-removed"> 849                         } else {</span>
 850                             lexError(savePos, Errors.IllegalDot);





 851                         }
<span class="line-removed"> 852                     } else {</span>
<span class="line-removed"> 853                         tk = TokenKind.DOT;</span>
 854                     }
 855                     break loop;
<span class="line-modified"> 856                 case &#39;,&#39;:</span>
<span class="line-modified"> 857                     reader.scanChar(); tk = TokenKind.COMMA; break loop;</span>
<span class="line-modified"> 858                 case &#39;;&#39;:</span>
<span class="line-modified"> 859                     reader.scanChar(); tk = TokenKind.SEMI; break loop;</span>
<span class="line-modified"> 860                 case &#39;(&#39;:</span>
<span class="line-modified"> 861                     reader.scanChar(); tk = TokenKind.LPAREN; break loop;</span>
<span class="line-modified"> 862                 case &#39;)&#39;:</span>
<span class="line-modified"> 863                     reader.scanChar(); tk = TokenKind.RPAREN; break loop;</span>
<span class="line-modified"> 864                 case &#39;[&#39;:</span>
<span class="line-modified"> 865                     reader.scanChar(); tk = TokenKind.LBRACKET; break loop;</span>
<span class="line-modified"> 866                 case &#39;]&#39;:</span>
<span class="line-modified"> 867                     reader.scanChar(); tk = TokenKind.RBRACKET; break loop;</span>
<span class="line-modified"> 868                 case &#39;{&#39;:</span>
<span class="line-modified"> 869                     reader.scanChar(); tk = TokenKind.LBRACE; break loop;</span>
<span class="line-modified"> 870                 case &#39;}&#39;:</span>
<span class="line-modified"> 871                     reader.scanChar(); tk = TokenKind.RBRACE; break loop;</span>

























 872                 case &#39;/&#39;:
<span class="line-modified"> 873                     reader.scanChar();</span>
<span class="line-modified"> 874                     if (reader.ch == &#39;/&#39;) {</span>
<span class="line-modified"> 875                         do {</span>
<span class="line-modified"> 876                             reader.scanCommentChar();</span>
<span class="line-modified"> 877                         } while (reader.ch != CR &amp;&amp; reader.ch != LF &amp;&amp; reader.bp &lt; reader.buflen);</span>
<span class="line-modified"> 878                         if (reader.bp &lt; reader.buflen) {</span>
<span class="line-modified"> 879                             comments = addComment(comments, processComment(pos, reader.bp, CommentStyle.LINE));</span>
 880                         }
 881                         break;
<span class="line-modified"> 882                     } else if (reader.ch == &#39;*&#39;) {</span>
 883                         boolean isEmpty = false;
<span class="line-removed"> 884                         reader.scanChar();</span>
 885                         CommentStyle style;
<span class="line-modified"> 886                         if (reader.ch == &#39;*&#39;) {</span>

 887                             style = CommentStyle.JAVADOC;
<span class="line-modified"> 888                             reader.scanCommentChar();</span>
<span class="line-modified"> 889                             if (reader.ch == &#39;/&#39;) {</span>
 890                                 isEmpty = true;
 891                             }
 892                         } else {
 893                             style = CommentStyle.BLOCK;
 894                         }
<span class="line-modified"> 895                         while (!isEmpty &amp;&amp; reader.bp &lt; reader.buflen) {</span>
<span class="line-modified"> 896                             if (reader.ch == &#39;*&#39;) {</span>
<span class="line-modified"> 897                                 reader.scanChar();</span>
<span class="line-modified"> 898                                 if (reader.ch == &#39;/&#39;) break;</span>
<span class="line-modified"> 899                             } else {</span>
<span class="line-modified"> 900                                 reader.scanCommentChar();</span>




 901                             }
 902                         }
<span class="line-modified"> 903                         if (reader.ch == &#39;/&#39;) {</span>
<span class="line-modified"> 904                             reader.scanChar();</span>
<span class="line-modified"> 905                             comments = addComment(comments, processComment(pos, reader.bp, style));</span>

 906                             break;
 907                         } else {
 908                             lexError(pos, Errors.UnclosedComment);

 909                             break loop;
 910                         }
<span class="line-modified"> 911                     } else if (reader.ch == &#39;=&#39;) {</span>
<span class="line-modified"> 912                         tk = TokenKind.SLASHEQ;</span>
<span class="line-removed"> 913                         reader.scanChar();</span>
 914                     } else {
<span class="line-modified"> 915                         tk = TokenKind.SLASH;</span>
 916                     }
 917                     break loop;
<span class="line-modified"> 918                 case &#39;\&#39;&#39;:</span>
<span class="line-modified"> 919                     reader.scanChar();</span>
<span class="line-modified"> 920                     if (reader.ch == &#39;\&#39;&#39;) {</span>


 921                         lexError(pos, Errors.EmptyCharLit);
<span class="line-removed"> 922                         reader.scanChar();</span>
 923                     } else {
<span class="line-modified"> 924                         if (isEOLN())</span>
 925                             lexError(pos, Errors.IllegalLineEndInCharLit);
<span class="line-modified"> 926                         scanLitChar(pos, true, false);</span>
<span class="line-modified"> 927                         if (reader.ch == &#39;\&#39;&#39;) {</span>
<span class="line-modified"> 928                             reader.scanChar();</span>


 929                             tk = TokenKind.CHARLITERAL;
 930                         } else {
 931                             lexError(pos, Errors.UnclosedCharLit);
 932                         }
 933                     }
 934                     break loop;
<span class="line-modified"> 935                 case &#39;\&quot;&#39;:</span>

 936                     scanString(pos);
 937                     break loop;

 938                 default:
<span class="line-modified"> 939                     if (isSpecial(reader.ch)) {</span>
 940                         scanOperator();
 941                     } else {
 942                         boolean isJavaIdentifierStart;
<span class="line-modified"> 943                         int codePoint = -1;</span>
<span class="line-modified"> 944                         if (reader.ch &lt; &#39;\u0080&#39;) {</span>
 945                             // all ASCII range chars already handled, above
 946                             isJavaIdentifierStart = false;
 947                         } else {
<span class="line-modified"> 948                             codePoint = reader.peekSurrogates();</span>
<span class="line-modified"> 949                             if (codePoint &gt;= 0) {</span>
<span class="line-modified"> 950                                 if (isJavaIdentifierStart = Character.isJavaIdentifierStart(codePoint)) {</span>
<span class="line-removed"> 951                                     reader.putChar(true);</span>
<span class="line-removed"> 952                                 }</span>
<span class="line-removed"> 953                             } else {</span>
<span class="line-removed"> 954                                 isJavaIdentifierStart = Character.isJavaIdentifierStart(reader.ch);</span>
<span class="line-removed"> 955                             }</span>
 956                         }

 957                         if (isJavaIdentifierStart) {
 958                             scanIdent();
<span class="line-modified"> 959                         } else if (reader.digit(pos, 10) &gt;= 0) {</span>
 960                             scanNumber(pos, 10);
<span class="line-modified"> 961                         } else if (reader.bp == reader.buflen || reader.ch == EOI &amp;&amp; reader.bp + 1 == reader.buflen) { // JLS 3.5</span>
 962                             tk = TokenKind.EOF;
<span class="line-modified"> 963                             pos = reader.realLength;</span>
 964                         } else {
 965                             String arg;
 966 
<span class="line-modified"> 967                             if (codePoint &gt;= 0) {</span>
<span class="line-modified"> 968                                 char high = reader.ch;</span>
<span class="line-modified"> 969                                 reader.scanChar();</span>
<span class="line-modified"> 970                                 arg = String.format(&quot;\\u%04x\\u%04x&quot;, (int) high, (int)reader.ch);</span>

 971                             } else {
<span class="line-modified"> 972                                 arg = (32 &lt; reader.ch &amp;&amp; reader.ch &lt; 127) ?</span>
<span class="line-modified"> 973                                                 String.format(&quot;%s&quot;, reader.ch) :</span>
<span class="line-modified"> 974                                                 String.format(&quot;\\u%04x&quot;, (int)reader.ch);</span>
 975                             }

 976                             lexError(pos, Errors.IllegalChar(arg));
<span class="line-modified"> 977                             reader.scanChar();</span>
 978                         }
 979                     }
 980                     break loop;
 981                 }
 982             }
<span class="line-modified"> 983             endPos = reader.bp;</span>
<span class="line-modified"> 984             switch (tk.tag) {</span>
<span class="line-modified"> 985                 case DEFAULT: return new Token(tk, pos, endPos, comments);</span>
<span class="line-modified"> 986                 case NAMED: return new NamedToken(tk, pos, endPos, name, comments);</span>
<span class="line-modified"> 987                 case STRING: {</span>
<span class="line-modified"> 988                     // Get characters from string buffer.</span>
<span class="line-modified"> 989                     String string = reader.chars();</span>
<span class="line-modified"> 990                     // If a text block.</span>
<span class="line-modified"> 991                     if (isTextBlock &amp;&amp; TextBlockSupport.hasSupport()) {</span>
<span class="line-modified"> 992                         // Verify that the incidental indentation is consistent.</span>
<span class="line-modified"> 993                         if (lint.isEnabled(LintCategory.TEXT_BLOCKS)) {</span>
<span class="line-modified"> 994                             Set&lt;TextBlockSupport.WhitespaceChecks&gt; checks =</span>
<span class="line-modified"> 995                                     TextBlockSupport.checkWhitespace(string);</span>
<span class="line-modified"> 996                             if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {</span>
<span class="line-modified"> 997                                 lexWarning(LintCategory.TEXT_BLOCKS, pos,</span>
<span class="line-modified"> 998                                         Warnings.InconsistentWhiteSpaceIndentation);</span>
<span class="line-modified"> 999                             }</span>
<span class="line-modified">1000                             if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {</span>
<span class="line-modified">1001                                 lexWarning(LintCategory.TEXT_BLOCKS, pos,</span>
<span class="line-modified">1002                                         Warnings.TrailingWhiteSpaceWillBeRemoved);</span>
<span class="line-removed">1003                             }</span>
1004                         }
<span class="line-modified">1005                         // Remove incidental indentation.</span>
<span class="line-modified">1006                         try {</span>
<span class="line-modified">1007                             string = TextBlockSupport.stripIndent(string);</span>
<span class="line-removed">1008                         } catch (Exception ex) {</span>
<span class="line-removed">1009                             // Error already reported, just use unstripped string.</span>
1010                         }
1011                     }
<span class="line-modified">1012                     // Translate escape sequences if present.</span>
<span class="line-modified">1013                     if (hasEscapeSequences &amp;&amp; TextBlockSupport.hasSupport()) {</span>
<span class="line-modified">1014                         try {</span>
<span class="line-modified">1015                             string = TextBlockSupport.translateEscapes(string);</span>
<span class="line-modified">1016                         } catch (Exception ex) {</span>
<span class="line-modified">1017                             // Error already reported, just use untranslated string.</span>
<span class="line-modified">1018                         }</span>







1019                     }



1020                     // Build string token.
1021                     return new StringToken(tk, pos, endPos, string, comments);



1022                 }
<span class="line-removed">1023                 case NUMERIC: return new NumericToken(tk, pos, endPos, reader.chars(), radix, comments);</span>
<span class="line-removed">1024                 default: throw new AssertionError();</span>
1025             }
<span class="line-modified">1026         }</span>
<span class="line-modified">1027         finally {</span>

1028             if (scannerDebug) {
1029                     System.out.println(&quot;nextToken(&quot; + pos
1030                                        + &quot;,&quot; + endPos + &quot;)=|&quot; +
<span class="line-modified">1031                                        new String(reader.getRawCharacters(pos, endPos))</span>
1032                                        + &quot;|&quot;);
1033             }
1034         }
1035     }
<span class="line-removed">1036     //where</span>
<span class="line-removed">1037         List&lt;Comment&gt; addComment(List&lt;Comment&gt; comments, Comment comment) {</span>
<span class="line-removed">1038             return comments == null ?</span>
<span class="line-removed">1039                     List.of(comment) :</span>
<span class="line-removed">1040                     comments.prepend(comment);</span>
<span class="line-removed">1041         }</span>
1042 
<span class="line-modified">1043     /** Return the position where a lexical error occurred;</span>

















1044      */
1045     public int errPos() {
1046         return errPos;
1047     }
1048 
<span class="line-modified">1049     /** Set the position where a lexical error occurred;</span>



1050      */
1051     public void errPos(int pos) {
1052         errPos = pos;
1053     }
1054 
1055     /**
1056      * Called when a complete comment has been scanned. pos and endPos
1057      * will mark the comment boundary.






1058      */
1059     protected Tokens.Comment processComment(int pos, int endPos, CommentStyle style) {
<span class="line-modified">1060         if (scannerDebug)</span>
1061             System.out.println(&quot;processComment(&quot; + pos
<span class="line-modified">1062                                + &quot;,&quot; + endPos + &quot;,&quot; + style + &quot;)=|&quot;</span>
<span class="line-modified">1063                                + new String(reader.getRawCharacters(pos, endPos))</span>
<span class="line-modified">1064                                + &quot;|&quot;);</span>
<span class="line-modified">1065         char[] buf = reader.getRawCharacters(pos, endPos);</span>
<span class="line-modified">1066         return new BasicComment&lt;&gt;(new UnicodeReader(fac, buf, buf.length), style);</span>



1067     }
1068 
1069     /**
1070      * Called when a complete whitespace run has been scanned. pos and endPos
1071      * will mark the whitespace boundary.





1072      */
1073     protected void processWhiteSpace(int pos, int endPos) {
<span class="line-modified">1074         if (scannerDebug)</span>
1075             System.out.println(&quot;processWhitespace(&quot; + pos
<span class="line-modified">1076                                + &quot;,&quot; + endPos + &quot;)=|&quot; +</span>
<span class="line-modified">1077                                new String(reader.getRawCharacters(pos, endPos))</span>
<span class="line-modified">1078                                + &quot;|&quot;);</span>

1079     }
1080 
1081     /**
1082      * Called when a line terminator has been processed.



1083      */
1084     protected void processLineTerminator(int pos, int endPos) {
<span class="line-modified">1085         if (scannerDebug)</span>
1086             System.out.println(&quot;processTerminator(&quot; + pos
<span class="line-modified">1087                                + &quot;,&quot; + endPos + &quot;)=|&quot; +</span>
<span class="line-modified">1088                                new String(reader.getRawCharacters(pos, endPos))</span>
<span class="line-modified">1089                                + &quot;|&quot;);</span>

1090     }
1091 
<span class="line-modified">1092     /** Build a map for translating between line numbers and</span>
<span class="line-modified">1093      * positions in the input.</span>
1094      *
<span class="line-modified">1095      * @return a LineMap */</span>

1096     public Position.LineMap getLineMap() {
<span class="line-modified">1097         return Position.makeLineMap(reader.getRawCharacters(), reader.buflen, false);</span>
1098     }
1099 
<span class="line-removed">1100 </span>
1101     /**
<span class="line-modified">1102     * Scan a documentation comment; determine if a deprecated tag is present.</span>
<span class="line-modified">1103     * Called once the initial /, * have been skipped, positioned at the second *</span>
<span class="line-modified">1104     * (which is treated as the beginning of the first line).</span>
<span class="line-modified">1105     * Stops positioned at the closing &#39;/&#39;.</span>
<span class="line-modified">1106     */</span>
<span class="line-modified">1107     protected static class BasicComment&lt;U extends UnicodeReader&gt; implements Comment {</span>
<span class="line-modified">1108 </span>





1109         CommentStyle cs;
<span class="line-removed">1110         U comment_reader;</span>
1111 



1112         protected boolean deprecatedFlag = false;




1113         protected boolean scanned = false;
1114 
<span class="line-modified">1115         protected BasicComment(U comment_reader, CommentStyle cs) {</span>
<span class="line-modified">1116             this.comment_reader = comment_reader;</span>








1117             this.cs = cs;
1118         }
1119 





1120         public String getText() {
1121             return null;
1122         }
1123 







1124         public int getSourcePos(int pos) {
1125             return -1;
1126         }
1127 








1128         public CommentStyle getStyle() {
1129             return cs;
1130         }
1131 





1132         public boolean isDeprecated() {
1133             if (!scanned &amp;&amp; cs == CommentStyle.JAVADOC) {
1134                 scanDocComment();
1135             }

1136             return deprecatedFlag;
1137         }
1138 
<span class="line-modified">1139         @SuppressWarnings(&quot;fallthrough&quot;)</span>


1140         protected void scanDocComment() {
1141             try {
1142                 boolean deprecatedPrefix = false;
<span class="line-modified">1143 </span>
<span class="line-removed">1144                 comment_reader.bp += 3; // &#39;/**&#39;</span>
<span class="line-removed">1145                 comment_reader.ch = comment_reader.buf[comment_reader.bp];</span>
1146 
1147                 forEachLine:
<span class="line-modified">1148                 while (comment_reader.bp &lt; comment_reader.buflen) {</span>
<span class="line-removed">1149 </span>
1150                     // Skip optional WhiteSpace at beginning of line
<span class="line-modified">1151                     while (comment_reader.bp &lt; comment_reader.buflen &amp;&amp; (comment_reader.ch == &#39; &#39; || comment_reader.ch == &#39;\t&#39; || comment_reader.ch == FF)) {</span>
<span class="line-removed">1152                         comment_reader.scanCommentChar();</span>
<span class="line-removed">1153                     }</span>
1154 
1155                     // Skip optional consecutive Stars
<span class="line-modified">1156                     while (comment_reader.bp &lt; comment_reader.buflen &amp;&amp; comment_reader.ch == &#39;*&#39;) {</span>
<span class="line-modified">1157                         comment_reader.scanCommentChar();</span>
<span class="line-removed">1158                         if (comment_reader.ch == &#39;/&#39;) {</span>
1159                             return;
1160                         }
1161                     }
1162 
1163                     // Skip optional WhiteSpace after Stars
<span class="line-modified">1164                     while (comment_reader.bp &lt; comment_reader.buflen &amp;&amp; (comment_reader.ch == &#39; &#39; || comment_reader.ch == &#39;\t&#39; || comment_reader.ch == FF)) {</span>
<span class="line-removed">1165                         comment_reader.scanCommentChar();</span>
<span class="line-removed">1166                     }</span>
1167 
<span class="line-removed">1168                     deprecatedPrefix = false;</span>
1169                     // At beginning of line in the JavaDoc sense.
<span class="line-modified">1170                     if (!deprecatedFlag) {</span>
<span class="line-removed">1171                         String deprecated = &quot;@deprecated&quot;;</span>
<span class="line-removed">1172                         int i = 0;</span>
<span class="line-removed">1173                         while (comment_reader.bp &lt; comment_reader.buflen &amp;&amp; comment_reader.ch == deprecated.charAt(i)) {</span>
<span class="line-removed">1174                             comment_reader.scanCommentChar();</span>
<span class="line-removed">1175                             i++;</span>
<span class="line-removed">1176                             if (i == deprecated.length()) {</span>
<span class="line-removed">1177                                 deprecatedPrefix = true;</span>
<span class="line-removed">1178                                 break;</span>
<span class="line-removed">1179                             }</span>
<span class="line-removed">1180                         }</span>
<span class="line-removed">1181                     }</span>
1182 
<span class="line-modified">1183                     if (deprecatedPrefix &amp;&amp; comment_reader.bp &lt; comment_reader.buflen) {</span>
<span class="line-modified">1184                         if (Character.isWhitespace(comment_reader.ch)) {</span>
1185                             deprecatedFlag = true;
<span class="line-modified">1186                         } else if (comment_reader.ch == &#39;*&#39;) {</span>
<span class="line-modified">1187                             comment_reader.scanCommentChar();</span>
<span class="line-removed">1188                             if (comment_reader.ch == &#39;/&#39;) {</span>
1189                                 deprecatedFlag = true;
1190                                 return;
1191                             }
1192                         }
1193                     }
1194 
1195                     // Skip rest of line
<span class="line-modified">1196                     while (comment_reader.bp &lt; comment_reader.buflen) {</span>
<span class="line-modified">1197                         switch (comment_reader.ch) {</span>
1198                             case &#39;*&#39;:
<span class="line-modified">1199                                 comment_reader.scanCommentChar();</span>
<span class="line-modified">1200                                 if (comment_reader.ch == &#39;/&#39;) {</span>

1201                                     return;
1202                                 }

1203                                 break;
<span class="line-modified">1204                             case CR: // (Spec 3.4)</span>
<span class="line-modified">1205                                 comment_reader.scanCommentChar();</span>
<span class="line-modified">1206                                 if (comment_reader.ch != LF) {</span>
<span class="line-modified">1207                                     continue forEachLine;</span>
<span class="line-removed">1208                                 }</span>
<span class="line-removed">1209                             /* fall through to LF case */</span>
<span class="line-removed">1210                             case LF: // (Spec 3.4)</span>
<span class="line-removed">1211                                 comment_reader.scanCommentChar();</span>
1212                                 continue forEachLine;

1213                             default:
<span class="line-modified">1214                                 comment_reader.scanCommentChar();</span>

1215                         }
1216                     } // rest of line
1217                 } // forEachLine
1218                 return;
1219             } finally {
1220                 scanned = true;
1221             }
1222         }
1223     }
1224 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.parser;
  27 
  28 import com.sun.tools.javac.code.Lint;
  29 import com.sun.tools.javac.code.Lint.LintCategory;
  30 import com.sun.tools.javac.code.Preview;
  31 import com.sun.tools.javac.code.Source;
  32 import com.sun.tools.javac.code.Source.Feature;
<span class="line-added">  33 import com.sun.tools.javac.file.JavacFileManager;</span>
  34 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  35 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  36 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  37 import com.sun.tools.javac.util.*;
  38 import com.sun.tools.javac.util.JCDiagnostic.*;
  39 


  40 import java.nio.CharBuffer;

  41 import java.util.Set;
<span class="line-added">  42 import java.util.regex.Pattern;</span>
  43 
  44 import static com.sun.tools.javac.parser.Tokens.*;
<span class="line-modified">  45 import static com.sun.tools.javac.util.LayoutCharacters.EOI;</span>
  46 
<span class="line-modified">  47 /**</span>
<span class="line-modified">  48  * The lexical analyzer maps an input stream consisting of UTF-8 characters and unicode</span>
<span class="line-added">  49  * escape sequences into a token sequence.</span>
  50  *
  51  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  52  *  If you write code that depends on this, you do so at your own risk.
  53  *  This code and its internal interfaces are subject to change or
  54  *  deletion without notice.&lt;/b&gt;
  55  */
<span class="line-modified">  56 public class JavaTokenizer extends UnicodeReader {</span>
<span class="line-modified">  57     /**</span>
<span class="line-added">  58      * If true then prints token information after each nextToken().</span>
<span class="line-added">  59      */</span>
  60     private static final boolean scannerDebug = false;
  61 
<span class="line-modified">  62     /**</span>
<span class="line-added">  63      * Sentinal for non-value.</span>
<span class="line-added">  64      */</span>
<span class="line-added">  65     private int NOT_FOUND = -1;</span>
<span class="line-added">  66 </span>
<span class="line-added">  67     /**</span>
<span class="line-added">  68      * The source language setting. Copied from scanner factory.</span>
  69      */
  70     private Source source;
  71 
<span class="line-modified">  72     /**</span>
<span class="line-added">  73      * The preview language setting. Copied from scanner factory.</span>
<span class="line-added">  74      */</span>
  75     private Preview preview;
  76 
<span class="line-modified">  77     /**</span>
<span class="line-added">  78      * The log to be used for error reporting. Copied from scanner factory.</span>
  79      */
  80     private final Log log;
  81 
<span class="line-modified">  82     /**</span>
<span class="line-added">  83      * The token factory. Copied from scanner factory.</span>
<span class="line-added">  84      */</span>
  85     private final Tokens tokens;
  86 
<span class="line-modified">  87     /**</span>
<span class="line-added">  88      * The names factory. Copied from scanner factory.</span>
<span class="line-added">  89      */</span>
<span class="line-added">  90     private final Names names;</span>
<span class="line-added">  91 </span>
<span class="line-added">  92     /**</span>
<span class="line-added">  93      * The token kind, set by nextToken().</span>
  94      */
  95     protected TokenKind tk;
  96 
<span class="line-modified">  97     /**</span>
<span class="line-added">  98      * The token&#39;s radix, set by nextToken().</span>
  99      */
 100     protected int radix;
 101 
<span class="line-modified"> 102     /**</span>
<span class="line-added"> 103      * The token&#39;s name, set by nextToken().</span>
 104      */
 105     protected Name name;
 106 
<span class="line-modified"> 107     /**</span>
<span class="line-added"> 108      * The position where a lexical error occurred;</span>
 109      */
 110     protected int errPos = Position.NOPOS;
 111 
<span class="line-modified"> 112     /**</span>
<span class="line-modified"> 113      * true if is a text block, set by nextToken().</span>



 114      */
 115     protected boolean isTextBlock;
 116 
<span class="line-modified"> 117     /**</span>
<span class="line-added"> 118      * true if contains escape sequences, set by nextToken().</span>
 119      */
 120     protected boolean hasEscapeSequences;
 121 
<span class="line-added"> 122     /**</span>
<span class="line-added"> 123      * Buffer for building literals, used by nextToken().</span>
<span class="line-added"> 124      */</span>
<span class="line-added"> 125     protected StringBuilder sb;</span>
<span class="line-added"> 126 </span>
<span class="line-added"> 127     /**</span>
<span class="line-added"> 128      * Origin scanner factory.</span>
<span class="line-added"> 129      */</span>
 130     protected ScannerFactory fac;
 131 
<span class="line-modified"> 132     /**</span>
<span class="line-modified"> 133      * The set of lint options currently in effect. It is initialized</span>
<span class="line-modified"> 134      * from the context, and then is set/reset as needed by Attr as it</span>
<span class="line-added"> 135      * visits all the various parts of the trees during attribution.</span>
<span class="line-added"> 136      */</span>
 137     protected Lint lint;
 138 










 139     /**
<span class="line-modified"> 140      * Construct a Java token scanner from the input character buffer.</span>



 141      *
<span class="line-modified"> 142      * @param fac  the factory which created this Scanner.</span>
<span class="line-modified"> 143      * @param cb   the input character buffer.</span>

 144      */
<span class="line-modified"> 145     protected JavaTokenizer(ScannerFactory fac, CharBuffer cb) {</span>
<span class="line-modified"> 146         this(fac, JavacFileManager.toArray(cb), cb.limit());</span>
 147     }
 148 
<span class="line-modified"> 149     /**</span>
<span class="line-modified"> 150      * Construct a Java token scanner from the input character array.</span>
<span class="line-modified"> 151      *</span>
<span class="line-modified"> 152      * @param fac     the factory which created this Scanner</span>
<span class="line-modified"> 153      * @param array   the input character array.</span>
<span class="line-added"> 154      * @param length  The length of the meaningful content in the array.</span>
<span class="line-added"> 155      */</span>
<span class="line-added"> 156     protected JavaTokenizer(ScannerFactory fac, char[] array, int length) {</span>
<span class="line-added"> 157         super(fac, array, length);</span>
 158         this.fac = fac;
 159         this.log = fac.log;
<span class="line-added"> 160         this.names = fac.names;</span>
 161         this.tokens = fac.tokens;
 162         this.source = fac.source;
 163         this.preview = fac.preview;

 164         this.lint = fac.lint;
<span class="line-added"> 165         this.sb = new StringBuilder(256);</span>
 166     }
 167 
<span class="line-added"> 168     /**</span>
<span class="line-added"> 169      * Check the source level for a lexical feature.</span>
<span class="line-added"> 170      *</span>
<span class="line-added"> 171      * @param pos      position in input buffer.</span>
<span class="line-added"> 172      * @param feature  feature to verify.</span>
<span class="line-added"> 173      */</span>
 174     protected void checkSourceLevel(int pos, Feature feature) {
 175         if (preview.isPreview(feature) &amp;&amp; !preview.isEnabled()) {
 176             //preview feature without --preview flag, error
 177             lexError(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));
 178         } else if (!feature.allowedInSource(source)) {
 179             //incompatible source level, error
 180             lexError(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));
 181         } else if (preview.isPreview(feature)) {
 182             //use of preview feature, warn
 183             preview.warnPreview(pos, feature);
 184         }
 185     }
 186 
<span class="line-modified"> 187     /**</span>
<span class="line-added"> 188      * Report an error at the given position using the provided arguments.</span>
<span class="line-added"> 189      *</span>
<span class="line-added"> 190      * @param pos  position in input buffer.</span>
<span class="line-added"> 191      * @param key  error key to report.</span>
 192      */
 193     protected void lexError(int pos, JCDiagnostic.Error key) {
 194         log.error(pos, key);
 195         tk = TokenKind.ERROR;
 196         errPos = pos;
 197     }
 198 
<span class="line-added"> 199     /**</span>
<span class="line-added"> 200      * Report an error at the given position using the provided arguments.</span>
<span class="line-added"> 201      *</span>
<span class="line-added"> 202      * @param flags  diagnostic flags.</span>
<span class="line-added"> 203      * @param pos    position in input buffer.</span>
<span class="line-added"> 204      * @param key    error key to report.</span>
<span class="line-added"> 205      */</span>
 206     protected void lexError(DiagnosticFlag flags, int pos, JCDiagnostic.Error key) {
 207         log.error(flags, pos, key);
 208         tk = TokenKind.ERROR;
 209         errPos = pos;
 210     }
 211 
<span class="line-added"> 212     /**</span>
<span class="line-added"> 213      * Report an error at the given position using the provided arguments.</span>
<span class="line-added"> 214      *</span>
<span class="line-added"> 215      * @param lc     lint category.</span>
<span class="line-added"> 216      * @param pos    position in input buffer.</span>
<span class="line-added"> 217      * @param key    error key to report.</span>
<span class="line-added"> 218      */</span>
 219     protected void lexWarning(LintCategory lc, int pos, JCDiagnostic.Warning key) {
 220         DiagnosticPosition dp = new SimpleDiagnosticPosition(pos) ;
 221         log.warning(lc, dp, key);
 222     }
 223 
<span class="line-modified"> 224     /**</span>
<span class="line-modified"> 225      * Add a character to the literal buffer.</span>
<span class="line-modified"> 226      *</span>
<span class="line-modified"> 227      * @param ch  character to add.</span>


 228      */
<span class="line-modified"> 229     protected void put(char ch) {</span>
<span class="line-modified"> 230         sb.append(ch);</span>
































































 231     }
 232 
<span class="line-modified"> 233     /**</span>
<span class="line-modified"> 234      * Add a codepoint to the literal buffer.</span>
<span class="line-modified"> 235      *</span>
<span class="line-added"> 236      * @param codePoint  codepoint to add.</span>
 237      */
<span class="line-modified"> 238     protected void putCodePoint(int codePoint) {</span>
<span class="line-modified"> 239         sb.appendCodePoint(codePoint);</span>
<span class="line-modified"> 240     }</span>

 241 
<span class="line-modified"> 242     /**</span>
<span class="line-modified"> 243      * Add current character or codepoint to the literal buffer.</span>
<span class="line-modified"> 244      */</span>
<span class="line-added"> 245     protected void put() {</span>
<span class="line-added"> 246         if (isSurrogate()) {</span>
<span class="line-added"> 247             putCodePoint(getCodepoint());</span>
<span class="line-added"> 248         } else {</span>
<span class="line-added"> 249             put(get());</span>
<span class="line-added"> 250         }</span>
<span class="line-added"> 251     }</span>
 252 
<span class="line-modified"> 253     /**</span>
<span class="line-modified"> 254      * Add a string to the literal buffer.</span>
<span class="line-modified"> 255      */</span>
<span class="line-added"> 256     protected void put(String string) {</span>
<span class="line-added"> 257         sb.append(string);</span>
<span class="line-added"> 258     }</span>
 259 
<span class="line-modified"> 260     /**</span>
<span class="line-modified"> 261      * Add current character or codepoint to the literal buffer then return next character.</span>
<span class="line-modified"> 262      */</span>
<span class="line-modified"> 263     protected char putThenNext() {</span>
<span class="line-modified"> 264         put();</span>





 265 
<span class="line-modified"> 266         return next();</span>
<span class="line-modified"> 267     }</span>





 268 
<span class="line-modified"> 269     /**</span>
<span class="line-modified"> 270      * If the specified character ch matches the current character then add current character</span>
<span class="line-modified"> 271      * to the literal buffer and then advance.</span>
<span class="line-modified"> 272      *</span>
<span class="line-modified"> 273      * @param ch  character to match.</span>
<span class="line-added"> 274      *</span>
<span class="line-added"> 275      * @return true if ch matches current character.</span>
<span class="line-added"> 276      */</span>
<span class="line-added"> 277     protected boolean acceptThenPut(char ch) {</span>
<span class="line-added"> 278         if (is(ch)) {</span>
<span class="line-added"> 279             put(get());</span>
<span class="line-added"> 280             next();</span>
 281 
<span class="line-modified"> 282             return true;</span>



 283         }
 284 
<span class="line-modified"> 285         return false;</span>
<span class="line-modified"> 286     }</span>


 287 
<span class="line-modified"> 288     /**</span>
<span class="line-modified"> 289      * If either ch1 or ch2 matches the current character then add current character</span>
<span class="line-modified"> 290      * to the literal buffer and then advance.</span>
<span class="line-modified"> 291      *</span>
<span class="line-modified"> 292      * @param ch1  first character to match.</span>
<span class="line-modified"> 293      * @param ch2  second character to match.</span>
<span class="line-modified"> 294      *</span>
<span class="line-modified"> 295      * @return true if either ch1 or ch2 matches current character.</span>
<span class="line-modified"> 296      */</span>
<span class="line-modified"> 297     protected boolean acceptOneOfThenPut(char ch1, char ch2) {</span>
<span class="line-modified"> 298         if (isOneOf(ch1, ch2)) {</span>
<span class="line-modified"> 299             put(get());</span>
<span class="line-modified"> 300             next();</span>







































 301 
<span class="line-modified"> 302             return true;</span>








 303         }
 304 
<span class="line-modified"> 305         return false;</span>









 306     }
 307 
<span class="line-modified"> 308     /**</span>
<span class="line-added"> 309      * Test if the current character is a line terminator.</span>
<span class="line-added"> 310      *</span>
<span class="line-added"> 311      * @return true if current character is a line terminator.</span>
 312      */
 313     private boolean isEOLN() {
<span class="line-modified"> 314         return isOneOf(&#39;\n&#39;, &#39;\r&#39;);</span>
 315     }
 316 
<span class="line-modified"> 317     /**</span>
<span class="line-added"> 318      * Skip and process a line terminator sequence.</span>
 319      */
<span class="line-modified"> 320     private void skipLineTerminator() {</span>
<span class="line-modified"> 321         int start = position();</span>
<span class="line-added"> 322         accept(&#39;\r&#39;);</span>
<span class="line-added"> 323         accept(&#39;\n&#39;);</span>
<span class="line-added"> 324         processLineTerminator(start, position());</span>
 325     }
 326 
<span class="line-modified"> 327     /**</span>
<span class="line-added"> 328      * Processes the current character and places in the literal buffer. If the current</span>
<span class="line-added"> 329      * character is a backslash then the next character is validated as a proper</span>
<span class="line-added"> 330      * escape character. Conversion of escape sequences takes place at end of nextToken().</span>
<span class="line-added"> 331      *</span>
<span class="line-added"> 332      * @param pos position of the first character in literal.</span>
 333      */
<span class="line-modified"> 334     private void scanLitChar(int pos) {</span>
<span class="line-modified"> 335         if (acceptThenPut(&#39;\\&#39;)) {</span>
<span class="line-modified"> 336             hasEscapeSequences = true;</span>




 337 
<span class="line-modified"> 338             switch (get()) {</span>
<span class="line-modified"> 339                 case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;:</span>
<span class="line-modified"> 340                 case &#39;4&#39;: case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;:</span>
<span class="line-modified"> 341                     char leadch = get();</span>
<span class="line-modified"> 342                     putThenNext();</span>
<span class="line-modified"> 343 </span>
<span class="line-added"> 344                     if (inRange(&#39;0&#39;, &#39;7&#39;)) {</span>
<span class="line-added"> 345                         putThenNext();</span>
<span class="line-added"> 346 </span>
<span class="line-added"> 347                         if (leadch &lt;= &#39;3&#39; &amp;&amp; inRange(&#39;0&#39;, &#39;7&#39;)) {</span>
<span class="line-added"> 348                             putThenNext();</span>
<span class="line-added"> 349                         }</span>
<span class="line-added"> 350                     }</span>
<span class="line-added"> 351                     break;</span>
<span class="line-added"> 352 </span>
<span class="line-added"> 353                 case &#39;b&#39;:</span>
<span class="line-added"> 354                 case &#39;t&#39;:</span>
<span class="line-added"> 355                 case &#39;n&#39;:</span>
<span class="line-added"> 356                 case &#39;f&#39;:</span>
<span class="line-added"> 357                 case &#39;r&#39;:</span>
<span class="line-added"> 358                 case &#39;\&#39;&#39;:</span>
<span class="line-added"> 359                 case &#39;\&quot;&#39;:</span>
<span class="line-added"> 360                 case &#39;\\&#39;:</span>
<span class="line-added"> 361                     putThenNext();</span>
<span class="line-added"> 362                     break;</span>
<span class="line-added"> 363 </span>
<span class="line-added"> 364                 case &#39;s&#39;:</span>
<span class="line-added"> 365                     checkSourceLevel(position(), Feature.TEXT_BLOCKS);</span>
<span class="line-added"> 366                     putThenNext();</span>
<span class="line-added"> 367                     break;</span>
<span class="line-added"> 368 </span>
<span class="line-added"> 369                 case &#39;\n&#39;:</span>
<span class="line-added"> 370                 case &#39;\r&#39;:</span>
<span class="line-added"> 371                     if (isTextBlock) {</span>
<span class="line-added"> 372                         skipLineTerminator();</span>
<span class="line-added"> 373                         // Normalize line terminator.</span>
<span class="line-added"> 374                         put(&#39;\n&#39;);</span>
<span class="line-added"> 375                     } else {</span>
<span class="line-added"> 376                         lexError(position(), Errors.IllegalEscChar);</span>
<span class="line-added"> 377                     }</span>
<span class="line-added"> 378                     break;</span>
<span class="line-added"> 379 </span>
<span class="line-added"> 380                 default:</span>
<span class="line-added"> 381                     lexError(position(), Errors.IllegalEscChar);</span>
<span class="line-added"> 382                     break;</span>
<span class="line-added"> 383             }</span>
<span class="line-added"> 384         } else {</span>
<span class="line-added"> 385             putThenNext();</span>
 386         }


 387     }
 388 
<span class="line-modified"> 389     /**</span>
<span class="line-added"> 390      * Scan a string literal or text block.</span>
<span class="line-added"> 391      *</span>
<span class="line-added"> 392      * @param pos  position of the first character in literal.</span>
 393      */
 394     private void scanString(int pos) {
<span class="line-modified"> 395         // Assume the best.</span>
<span class="line-modified"> 396         tk = Tokens.TokenKind.STRINGLITERAL;</span>

 397         // Track the end of first line for error recovery.
<span class="line-modified"> 398         int firstEOLN = NOT_FOUND;</span>
<span class="line-modified"> 399         // Check for text block delimiter.</span>
<span class="line-modified"> 400         isTextBlock = accept(&quot;\&quot;\&quot;\&quot;&quot;);</span>
<span class="line-modified"> 401 </span>
<span class="line-modified"> 402         if (isTextBlock) {</span>





 403             // Check if preview feature is enabled for text blocks.
 404             checkSourceLevel(pos, Feature.TEXT_BLOCKS);
<span class="line-modified"> 405 </span>
 406             // Verify the open delimiter sequence.
<span class="line-modified"> 407             // Error if the open delimiter sequence is not &quot;&quot;&quot;&lt;white space&gt;*&lt;LineTerminator&gt;.</span>
<span class="line-modified"> 408             skipWhitespace();</span>
<span class="line-modified"> 409 </span>




 410             if (isEOLN()) {
 411                 skipLineTerminator();
 412             } else {
<span class="line-modified"> 413                 lexError(position(), Errors.IllegalTextBlockOpen);</span>


 414                 return;
 415             }
<span class="line-modified"> 416 </span>
<span class="line-modified"> 417             // While characters are available.</span>
<span class="line-modified"> 418             while (isAvailable()) {</span>
<span class="line-modified"> 419                 if (accept(&quot;\&quot;\&quot;\&quot;&quot;)) {</span>







 420                     return;
 421                 }
<span class="line-modified"> 422 </span>
<span class="line-modified"> 423                 if (isEOLN()) {</span>
<span class="line-modified"> 424                     skipLineTerminator();</span>
<span class="line-modified"> 425                     // Add normalized line terminator to literal buffer.</span>
<span class="line-modified"> 426                     put(&#39;\n&#39;);</span>
<span class="line-modified"> 427 </span>
<span class="line-modified"> 428                     // Record first line terminator for error recovery.</span>
<span class="line-added"> 429                     if (firstEOLN == NOT_FOUND) {</span>
<span class="line-added"> 430                         firstEOLN = position();</span>
<span class="line-added"> 431                     }</span>
<span class="line-added"> 432                 } else {</span>
<span class="line-added"> 433                     // Add character to string buffer.</span>
<span class="line-added"> 434                     scanLitChar(pos);</span>
 435                 }
<span class="line-modified"> 436             }</span>
<span class="line-modified"> 437         } else {</span>
<span class="line-modified"> 438             // Skip first quote.</span>
<span class="line-modified"> 439             next();</span>
<span class="line-modified"> 440 </span>
<span class="line-modified"> 441             // While characters are available.</span>
<span class="line-added"> 442             while (isAvailable()) {</span>
<span class="line-added"> 443                 if (accept(&#39;\&quot;&#39;)) {</span>
<span class="line-added"> 444                     return;</span>
<span class="line-added"> 445                 }</span>
<span class="line-added"> 446 </span>
<span class="line-added"> 447                 if (isEOLN()) {</span>
<span class="line-added"> 448                     // Line terminator in string literal is an error.</span>
<span class="line-added"> 449                     // Fall out to unclosed string literal error.</span>
<span class="line-added"> 450                     break;</span>
<span class="line-added"> 451                 } else {</span>
<span class="line-added"> 452                     // Add character to string buffer.</span>
<span class="line-added"> 453                     scanLitChar(pos);</span>
 454                 }










 455             }
 456         }
<span class="line-added"> 457 </span>
 458         // String ended without close delimiter sequence.
<span class="line-modified"> 459         lexError(pos, isTextBlock ? Errors.UnclosedTextBlock : Errors.UnclosedStrLit);</span>
<span class="line-modified"> 460 </span>
<span class="line-modified"> 461         if (firstEOLN  != NOT_FOUND) {</span>
<span class="line-modified"> 462             // Reset recovery position to point after text block open delimiter sequence.</span>
<span class="line-added"> 463             reset(firstEOLN);</span>
 464         }
 465     }
 466 
<span class="line-added"> 467     /**</span>
<span class="line-added"> 468      * Scan sequence of digits.</span>
<span class="line-added"> 469      *</span>
<span class="line-added"> 470      * @param pos         position of the first character in literal.</span>
<span class="line-added"> 471      * @param digitRadix  radix of numeric literal.</span>
<span class="line-added"> 472      */</span>
 473     private void scanDigits(int pos, int digitRadix) {
<span class="line-modified"> 474         int leadingUnderscorePos = is(&#39;_&#39;) ? position() : NOT_FOUND;</span>
<span class="line-modified"> 475         int trailingUnderscorePos;</span>
<span class="line-added"> 476 </span>
 477         do {
<span class="line-modified"> 478             if (!is(&#39;_&#39;)) {</span>
<span class="line-modified"> 479                 put();</span>
<span class="line-added"> 480                 trailingUnderscorePos = NOT_FOUND;</span>
<span class="line-added"> 481             } else {</span>
<span class="line-added"> 482                 trailingUnderscorePos = position();</span>
 483             }
<span class="line-modified"> 484 </span>
<span class="line-modified"> 485             next();</span>
<span class="line-modified"> 486         } while (digit(pos, digitRadix) &gt;= 0 || is(&#39;_&#39;));</span>
<span class="line-modified"> 487 </span>
<span class="line-modified"> 488         if (leadingUnderscorePos != NOT_FOUND) {</span>
<span class="line-modified"> 489             lexError(leadingUnderscorePos, Errors.IllegalUnderscore);</span>
<span class="line-added"> 490         } else if (trailingUnderscorePos != NOT_FOUND) {</span>
<span class="line-added"> 491             lexError(trailingUnderscorePos, Errors.IllegalUnderscore);</span>
<span class="line-added"> 492         }</span>
 493     }
 494 
<span class="line-modified"> 495     /**</span>
<span class="line-added"> 496      * Read fractional part of hexadecimal floating point number.</span>
<span class="line-added"> 497      *</span>
<span class="line-added"> 498      * @param pos  position of the first character in literal.</span>
 499      */
 500     private void scanHexExponentAndSuffix(int pos) {
<span class="line-modified"> 501         if (acceptOneOfThenPut(&#39;p&#39;, &#39;P&#39;)) {</span>

 502             skipIllegalUnderscores();
<span class="line-modified"> 503             acceptOneOfThenPut(&#39;+&#39;, &#39;-&#39;);</span>


 504             skipIllegalUnderscores();
<span class="line-modified"> 505 </span>
<span class="line-added"> 506             if (digit(pos, 10) &gt;= 0) {</span>
 507                 scanDigits(pos, 10);
<span class="line-modified"> 508             } else {</span>


 509                 lexError(pos, Errors.MalformedFpLit);
<span class="line-added"> 510             }</span>
 511         } else {
 512             lexError(pos, Errors.MalformedFpLit);
 513         }
<span class="line-modified"> 514 </span>
<span class="line-modified"> 515         if (acceptOneOfThenPut(&#39;f&#39;, &#39;F&#39;)) {</span>
 516             tk = TokenKind.FLOATLITERAL;
 517             radix = 16;
 518         } else {
<span class="line-modified"> 519             acceptOneOfThenPut(&#39;d&#39;, &#39;D&#39;);</span>


 520             tk = TokenKind.DOUBLELITERAL;
 521             radix = 16;
 522         }
 523     }
 524 
<span class="line-modified"> 525     /**</span>
<span class="line-added"> 526      * Read fractional part of floating point number.</span>
<span class="line-added"> 527      *</span>
<span class="line-added"> 528      * @param pos  position of the first character in literal.</span>
 529      */
 530     private void scanFraction(int pos) {
 531         skipIllegalUnderscores();
<span class="line-modified"> 532 </span>
<span class="line-added"> 533         if (digit(pos, 10) &gt;= 0) {</span>
 534             scanDigits(pos, 10);
 535         }
<span class="line-modified"> 536 </span>
<span class="line-modified"> 537         int index = sb.length();</span>
<span class="line-modified"> 538 </span>
<span class="line-added"> 539         if (acceptOneOfThenPut(&#39;e&#39;, &#39;E&#39;)) {</span>
 540             skipIllegalUnderscores();
<span class="line-modified"> 541             acceptOneOfThenPut(&#39;+&#39;, &#39;-&#39;);</span>


 542             skipIllegalUnderscores();
<span class="line-modified"> 543 </span>
<span class="line-added"> 544             if (digit(pos, 10) &gt;= 0) {</span>
 545                 scanDigits(pos, 10);
 546                 return;
 547             }
<span class="line-added"> 548 </span>
 549             lexError(pos, Errors.MalformedFpLit);
<span class="line-modified"> 550             sb.setLength(index);</span>
 551         }
 552     }
 553 
<span class="line-modified"> 554     /**</span>
<span class="line-added"> 555      * Read fractional part and &#39;d&#39; or &#39;f&#39; suffix of floating point number.</span>
<span class="line-added"> 556      *</span>
<span class="line-added"> 557      * @param pos  position of the first character in literal.</span>
 558      */
 559     private void scanFractionAndSuffix(int pos) {
 560         radix = 10;
 561         scanFraction(pos);
<span class="line-modified"> 562 </span>
<span class="line-modified"> 563         if (acceptOneOfThenPut(&#39;f&#39;, &#39;F&#39;)) {</span>
<span class="line-modified"> 564              tk = TokenKind.FLOATLITERAL;</span>
 565         } else {
<span class="line-modified"> 566             acceptOneOfThenPut(&#39;d&#39;, &#39;D&#39;);</span>


 567             tk = TokenKind.DOUBLELITERAL;
 568         }
 569     }
 570 
<span class="line-modified"> 571     /**</span>
<span class="line-added"> 572      * Read fractional part and &#39;d&#39; or &#39;f&#39; suffix of hexadecimal floating point number.</span>
<span class="line-added"> 573      *</span>
<span class="line-added"> 574      * @param pos  position of the first character in literal.</span>
 575      */
 576     private void scanHexFractionAndSuffix(int pos, boolean seendigit) {
 577         radix = 16;
<span class="line-modified"> 578         Assert.check(is(&#39;.&#39;));</span>
<span class="line-modified"> 579         putThenNext();</span>
 580         skipIllegalUnderscores();
<span class="line-modified"> 581 </span>
<span class="line-added"> 582         if (digit(pos, 16) &gt;= 0) {</span>
 583             seendigit = true;
 584             scanDigits(pos, 16);
 585         }
<span class="line-added"> 586 </span>
 587         if (!seendigit)
 588             lexError(pos, Errors.InvalidHexNumber);
 589         else
 590             scanHexExponentAndSuffix(pos);
 591     }
 592 
<span class="line-added"> 593     /**</span>
<span class="line-added"> 594      * Skip over underscores and report as a error if found.</span>
<span class="line-added"> 595      */</span>
 596     private void skipIllegalUnderscores() {
<span class="line-modified"> 597         if (is(&#39;_&#39;)) {</span>
<span class="line-modified"> 598             lexError(position(), Errors.IllegalUnderscore);</span>
<span class="line-modified"> 599             skip(&#39;_&#39;);</span>

 600         }
 601     }
 602 
<span class="line-modified"> 603     /**</span>
<span class="line-modified"> 604      * Read a number. (Spec. 3.10)</span>
<span class="line-added"> 605      *</span>
<span class="line-added"> 606      * @param pos    position of the first character in literal.</span>
<span class="line-added"> 607      * @param radix  the radix of the number; one of 2, 8, 10, 16.</span>
 608      */
 609     private void scanNumber(int pos, int radix) {
 610         // for octal, allow base-10 digit in case it&#39;s a float literal
 611         this.radix = radix;
 612         int digitRadix = (radix == 8 ? 10 : radix);
<span class="line-modified"> 613         int firstDigit = digit(pos, Math.max(10, digitRadix));</span>
 614         boolean seendigit = firstDigit &gt;= 0;
 615         boolean seenValidDigit = firstDigit &gt;= 0 &amp;&amp; firstDigit &lt; digitRadix;
<span class="line-added"> 616 </span>
 617         if (seendigit) {
 618             scanDigits(pos, digitRadix);
 619         }
<span class="line-modified"> 620 </span>
<span class="line-added"> 621         if (radix == 16 &amp;&amp; is(&#39;.&#39;)) {</span>
 622             scanHexFractionAndSuffix(pos, seendigit);
<span class="line-modified"> 623         } else if (seendigit &amp;&amp; radix == 16 &amp;&amp; isOneOf(&#39;p&#39;, &#39;P&#39;)) {</span>
 624             scanHexExponentAndSuffix(pos);
<span class="line-modified"> 625         } else if (digitRadix == 10 &amp;&amp; is(&#39;.&#39;)) {</span>
<span class="line-modified"> 626             putThenNext();</span>
 627             scanFractionAndSuffix(pos);
<span class="line-modified"> 628         } else if (digitRadix == 10 &amp;&amp; isOneOf(&#39;e&#39;, &#39;E&#39;, &#39;f&#39;, &#39;F&#39;, &#39;d&#39;, &#39;D&#39;)) {</span>



 629             scanFractionAndSuffix(pos);
 630         } else {
 631             if (!seenValidDigit) {
 632                 switch (radix) {
 633                 case 2:
 634                     lexError(pos, Errors.InvalidBinaryNumber);
 635                     break;
 636                 case 16:
 637                     lexError(pos, Errors.InvalidHexNumber);
 638                     break;
 639                 }
 640             }
<span class="line-modified"> 641 </span>
<span class="line-modified"> 642             if (acceptOneOf(&#39;l&#39;, &#39;L&#39;)) {</span>
 643                 tk = TokenKind.LONGLITERAL;
 644             } else {
 645                 tk = TokenKind.INTLITERAL;
 646             }
 647         }
 648     }
 649 
<span class="line-modified"> 650     /**</span>
<span class="line-added"> 651      * Determines if the sequence in the literal buffer is a token (keyword, operator.)</span>
<span class="line-added"> 652      */</span>
<span class="line-added"> 653     private void checkIdent() {</span>
<span class="line-added"> 654         name = names.fromString(sb.toString());</span>
<span class="line-added"> 655         tk = tokens.lookupKind(name);</span>
<span class="line-added"> 656     }</span>
<span class="line-added"> 657 </span>
<span class="line-added"> 658     /**</span>
<span class="line-added"> 659      * Read an identifier. (Spec. 3.8)</span>
 660      */
 661     private void scanIdent() {
<span class="line-modified"> 662         putThenNext();</span>
<span class="line-modified"> 663 </span>

 664         do {
<span class="line-modified"> 665             switch (get()) {</span>
 666             case &#39;A&#39;: case &#39;B&#39;: case &#39;C&#39;: case &#39;D&#39;: case &#39;E&#39;:
 667             case &#39;F&#39;: case &#39;G&#39;: case &#39;H&#39;: case &#39;I&#39;: case &#39;J&#39;:
 668             case &#39;K&#39;: case &#39;L&#39;: case &#39;M&#39;: case &#39;N&#39;: case &#39;O&#39;:
 669             case &#39;P&#39;: case &#39;Q&#39;: case &#39;R&#39;: case &#39;S&#39;: case &#39;T&#39;:
 670             case &#39;U&#39;: case &#39;V&#39;: case &#39;W&#39;: case &#39;X&#39;: case &#39;Y&#39;:
 671             case &#39;Z&#39;:
 672             case &#39;a&#39;: case &#39;b&#39;: case &#39;c&#39;: case &#39;d&#39;: case &#39;e&#39;:
 673             case &#39;f&#39;: case &#39;g&#39;: case &#39;h&#39;: case &#39;i&#39;: case &#39;j&#39;:
 674             case &#39;k&#39;: case &#39;l&#39;: case &#39;m&#39;: case &#39;n&#39;: case &#39;o&#39;:
 675             case &#39;p&#39;: case &#39;q&#39;: case &#39;r&#39;: case &#39;s&#39;: case &#39;t&#39;:
 676             case &#39;u&#39;: case &#39;v&#39;: case &#39;w&#39;: case &#39;x&#39;: case &#39;y&#39;:
 677             case &#39;z&#39;:
 678             case &#39;$&#39;: case &#39;_&#39;:
 679             case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
 680             case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:
 681                 break;
<span class="line-added"> 682 </span>
 683             case &#39;\u0000&#39;: case &#39;\u0001&#39;: case &#39;\u0002&#39;: case &#39;\u0003&#39;:
 684             case &#39;\u0004&#39;: case &#39;\u0005&#39;: case &#39;\u0006&#39;: case &#39;\u0007&#39;:
 685             case &#39;\u0008&#39;: case &#39;\u000E&#39;: case &#39;\u000F&#39;: case &#39;\u0010&#39;:
 686             case &#39;\u0011&#39;: case &#39;\u0012&#39;: case &#39;\u0013&#39;: case &#39;\u0014&#39;:
 687             case &#39;\u0015&#39;: case &#39;\u0016&#39;: case &#39;\u0017&#39;:
 688             case &#39;\u0018&#39;: case &#39;\u0019&#39;: case &#39;\u001B&#39;:
 689             case &#39;\u007F&#39;:
<span class="line-modified"> 690                 next();</span>
 691                 continue;
<span class="line-added"> 692 </span>
 693             case &#39;\u001A&#39;: // EOI is also a legal identifier part
<span class="line-modified"> 694                 if (isAvailable()) {</span>
<span class="line-modified"> 695                     next();</span>
<span class="line-modified"> 696                     continue;</span>

 697                 }
<span class="line-modified"> 698 </span>
<span class="line-modified"> 699                 checkIdent();</span>
<span class="line-added"> 700                 return;</span>
<span class="line-added"> 701 </span>
 702             default:
<span class="line-modified"> 703                 boolean isJavaIdentifierPart;</span>
<span class="line-added"> 704 </span>
<span class="line-added"> 705                 if (isASCII()) {</span>
 706                     // all ASCII range chars already handled, above
 707                     isJavaIdentifierPart = false;
 708                 } else {
<span class="line-modified"> 709                     if (Character.isIdentifierIgnorable(get())) {</span>
<span class="line-modified"> 710                         next();</span>
 711                         continue;









 712                     }
<span class="line-added"> 713 </span>
<span class="line-added"> 714                     isJavaIdentifierPart = isSurrogate()</span>
<span class="line-added"> 715                             ? Character.isJavaIdentifierPart(getCodepoint())</span>
<span class="line-added"> 716                             : Character.isJavaIdentifierPart(get());</span>
 717                 }
<span class="line-added"> 718 </span>
 719                 if (!isJavaIdentifierPart) {
<span class="line-modified"> 720                     checkIdent();</span>

 721                     return;
 722                 }
 723             }
<span class="line-modified"> 724 </span>
<span class="line-added"> 725             putThenNext();</span>
 726         } while (true);
 727     }
 728 
<span class="line-modified"> 729     /**</span>
<span class="line-added"> 730      * Return true if ch can be part of an operator.</span>
<span class="line-added"> 731      *</span>
<span class="line-added"> 732      * @param ch  character to check.</span>
<span class="line-added"> 733      *</span>
<span class="line-added"> 734      * @return true if ch can be part of an operator.</span>
 735      */
 736     private boolean isSpecial(char ch) {
 737         switch (ch) {
 738         case &#39;!&#39;: case &#39;%&#39;: case &#39;&amp;&#39;: case &#39;*&#39;: case &#39;?&#39;:
 739         case &#39;+&#39;: case &#39;-&#39;: case &#39;:&#39;: case &#39;&lt;&#39;: case &#39;=&#39;:
 740         case &#39;&gt;&#39;: case &#39;^&#39;: case &#39;|&#39;: case &#39;~&#39;:
 741         case &#39;@&#39;:
 742             return true;
<span class="line-added"> 743 </span>
 744         default:
 745             return false;
 746         }
 747     }
 748 
<span class="line-modified"> 749     /**</span>
<span class="line-modified"> 750      * Read longest possible sequence of special characters and convert to token.</span>
 751      */
 752     private void scanOperator() {
 753         while (true) {
<span class="line-modified"> 754             put();</span>
<span class="line-modified"> 755             TokenKind newtk = tokens.lookupKind(sb.toString());</span>
<span class="line-modified"> 756 </span>
<span class="line-modified"> 757             if (newtk == TokenKind.IDENTIFIER) {</span>
<span class="line-modified"> 758                 sb.setLength(sb.length() - 1);</span>
<span class="line-added"> 759                 break;</span>
<span class="line-added"> 760             }</span>
<span class="line-added"> 761 </span>
<span class="line-added"> 762             tk = newtk;</span>
<span class="line-added"> 763             next();</span>
<span class="line-added"> 764 </span>
<span class="line-added"> 765             if (!isSpecial(get())) {</span>
 766                 break;
 767             }



 768         }
 769     }
 770 
<span class="line-modified"> 771     /**</span>
<span class="line-added"> 772      * Read token (main entrypoint.)</span>
 773      */
 774     public Token readToken() {
<span class="line-modified"> 775         sb.setLength(0);</span>

 776         name = null;
 777         radix = 0;
<span class="line-added"> 778         isTextBlock = false;</span>
<span class="line-added"> 779         hasEscapeSequences = false;</span>
 780 
<span class="line-modified"> 781         int pos;</span>

 782         List&lt;Comment&gt; comments = null;
 783 
 784         try {
 785             loop: while (true) {
<span class="line-modified"> 786                 pos = position();</span>
<span class="line-modified"> 787 </span>
<span class="line-modified"> 788                 switch (get()) {</span>
<span class="line-added"> 789                 case &#39; &#39;:  // (Spec 3.6)</span>
 790                 case &#39;\t&#39;: // (Spec 3.6)
<span class="line-modified"> 791                 case &#39;\f&#39;: // (Spec 3.6)</span>
<span class="line-modified"> 792                     skipWhitespace();</span>
<span class="line-modified"> 793                     processWhiteSpace(pos, position());</span>


 794                     break;
<span class="line-modified"> 795 </span>
<span class="line-modified"> 796                 case &#39;\n&#39;: // (Spec 3.4)</span>
<span class="line-modified"> 797                     next();</span>
<span class="line-added"> 798                     processLineTerminator(pos, position());</span>
 799                     break;
<span class="line-modified"> 800 </span>
<span class="line-modified"> 801                 case &#39;\r&#39;: // (Spec 3.4)</span>
<span class="line-modified"> 802                     next();</span>
<span class="line-modified"> 803                     accept(&#39;\n&#39;);</span>
<span class="line-modified"> 804                     processLineTerminator(pos, position());</span>

 805                     break;
<span class="line-added"> 806 </span>
 807                 case &#39;A&#39;: case &#39;B&#39;: case &#39;C&#39;: case &#39;D&#39;: case &#39;E&#39;:
 808                 case &#39;F&#39;: case &#39;G&#39;: case &#39;H&#39;: case &#39;I&#39;: case &#39;J&#39;:
 809                 case &#39;K&#39;: case &#39;L&#39;: case &#39;M&#39;: case &#39;N&#39;: case &#39;O&#39;:
 810                 case &#39;P&#39;: case &#39;Q&#39;: case &#39;R&#39;: case &#39;S&#39;: case &#39;T&#39;:
 811                 case &#39;U&#39;: case &#39;V&#39;: case &#39;W&#39;: case &#39;X&#39;: case &#39;Y&#39;:
 812                 case &#39;Z&#39;:
 813                 case &#39;a&#39;: case &#39;b&#39;: case &#39;c&#39;: case &#39;d&#39;: case &#39;e&#39;:
 814                 case &#39;f&#39;: case &#39;g&#39;: case &#39;h&#39;: case &#39;i&#39;: case &#39;j&#39;:
 815                 case &#39;k&#39;: case &#39;l&#39;: case &#39;m&#39;: case &#39;n&#39;: case &#39;o&#39;:
 816                 case &#39;p&#39;: case &#39;q&#39;: case &#39;r&#39;: case &#39;s&#39;: case &#39;t&#39;:
 817                 case &#39;u&#39;: case &#39;v&#39;: case &#39;w&#39;: case &#39;x&#39;: case &#39;y&#39;:
 818                 case &#39;z&#39;:
<span class="line-modified"> 819                 case &#39;$&#39;: case &#39;_&#39;: // (Spec. 3.8)</span>
 820                     scanIdent();
 821                     break loop;
<span class="line-modified"> 822 </span>
<span class="line-modified"> 823                 case &#39;0&#39;: // (Spec. 3.10)</span>
<span class="line-modified"> 824                     next();</span>
<span class="line-modified"> 825 </span>
<span class="line-added"> 826                     if (acceptOneOf(&#39;x&#39;, &#39;X&#39;)) {</span>
 827                         skipIllegalUnderscores();
 828                         scanNumber(pos, 16);
<span class="line-modified"> 829                     } else if (acceptOneOf(&#39;b&#39;, &#39;B&#39;)) {</span>

 830                         skipIllegalUnderscores();
 831                         scanNumber(pos, 2);
 832                     } else {
<span class="line-modified"> 833                         put(&#39;0&#39;);</span>
<span class="line-modified"> 834 </span>
<span class="line-modified"> 835                         if (is(&#39;_&#39;)) {</span>
<span class="line-modified"> 836                             int savePos = position();</span>
<span class="line-modified"> 837                             skip(&#39;_&#39;);</span>
<span class="line-modified"> 838 </span>
<span class="line-modified"> 839                             if (digit(pos, 10) &lt; 0) {</span>
 840                                 lexError(savePos, Errors.IllegalUnderscore);
 841                             }
 842                         }
<span class="line-added"> 843 </span>
 844                         scanNumber(pos, 8);
 845                     }
 846                     break loop;
<span class="line-added"> 847 </span>
 848                 case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
<span class="line-modified"> 849                 case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:  // (Spec. 3.10)</span>
 850                     scanNumber(pos, 10);
 851                     break loop;
<span class="line-modified"> 852 </span>
<span class="line-modified"> 853                 case &#39;.&#39;: // (Spec. 3.12)</span>
<span class="line-modified"> 854                     if (accept(&quot;...&quot;)) {</span>
<span class="line-modified"> 855                         put(&quot;...&quot;);</span>
<span class="line-modified"> 856                         tk = TokenKind.ELLIPSIS;</span>
<span class="line-modified"> 857                     } else {</span>
<span class="line-modified"> 858                         next();</span>
<span class="line-modified"> 859                         int savePos = position();</span>
<span class="line-modified"> 860 </span>
<span class="line-modified"> 861                         if (accept(&#39;.&#39;)) {</span>



 862                             lexError(savePos, Errors.IllegalDot);
<span class="line-added"> 863                         } else if (digit(pos, 10) &gt;= 0) {</span>
<span class="line-added"> 864                             put(&#39;.&#39;);</span>
<span class="line-added"> 865                             scanFractionAndSuffix(pos); // (Spec. 3.10)</span>
<span class="line-added"> 866                         } else {</span>
<span class="line-added"> 867                             tk = TokenKind.DOT;</span>
 868                         }


 869                     }
 870                     break loop;
<span class="line-modified"> 871 </span>
<span class="line-modified"> 872                 case &#39;,&#39;: // (Spec. 3.12)</span>
<span class="line-modified"> 873                     next();</span>
<span class="line-modified"> 874                     tk = TokenKind.COMMA;</span>
<span class="line-modified"> 875                     break loop;</span>
<span class="line-modified"> 876 </span>
<span class="line-modified"> 877                 case &#39;;&#39;: // (Spec. 3.12)</span>
<span class="line-modified"> 878                     next();</span>
<span class="line-modified"> 879                     tk = TokenKind.SEMI;</span>
<span class="line-modified"> 880                     break loop;</span>
<span class="line-modified"> 881 </span>
<span class="line-modified"> 882                 case &#39;(&#39;: // (Spec. 3.12)</span>
<span class="line-modified"> 883                     next();</span>
<span class="line-modified"> 884                     tk = TokenKind.LPAREN;</span>
<span class="line-modified"> 885                     break loop;</span>
<span class="line-modified"> 886 </span>
<span class="line-added"> 887                 case &#39;)&#39;: // (Spec. 3.12)</span>
<span class="line-added"> 888                     next();</span>
<span class="line-added"> 889                     tk = TokenKind.RPAREN;</span>
<span class="line-added"> 890                     break loop;</span>
<span class="line-added"> 891 </span>
<span class="line-added"> 892                 case &#39;[&#39;: // (Spec. 3.12)</span>
<span class="line-added"> 893                     next();</span>
<span class="line-added"> 894                     tk = TokenKind.LBRACKET;</span>
<span class="line-added"> 895                     break loop;</span>
<span class="line-added"> 896 </span>
<span class="line-added"> 897                 case &#39;]&#39;: // (Spec. 3.12)</span>
<span class="line-added"> 898                     next();</span>
<span class="line-added"> 899                     tk = TokenKind.RBRACKET;</span>
<span class="line-added"> 900                     break loop;</span>
<span class="line-added"> 901 </span>
<span class="line-added"> 902                 case &#39;{&#39;: // (Spec. 3.12)</span>
<span class="line-added"> 903                     next();</span>
<span class="line-added"> 904                     tk = TokenKind.LBRACE;</span>
<span class="line-added"> 905                     break loop;</span>
<span class="line-added"> 906 </span>
<span class="line-added"> 907                 case &#39;}&#39;: // (Spec. 3.12)</span>
<span class="line-added"> 908                     next();</span>
<span class="line-added"> 909                     tk = TokenKind.RBRACE;</span>
<span class="line-added"> 910                     break loop;</span>
<span class="line-added"> 911 </span>
 912                 case &#39;/&#39;:
<span class="line-modified"> 913                     next();</span>
<span class="line-modified"> 914 </span>
<span class="line-modified"> 915                     if (accept(&#39;/&#39;)) { // (Spec. 3.7)</span>
<span class="line-modified"> 916                         skipToEOLN();</span>
<span class="line-modified"> 917 </span>
<span class="line-modified"> 918                         if (isAvailable()) {</span>
<span class="line-modified"> 919                             comments = appendComment(comments, processComment(pos, position(), CommentStyle.LINE));</span>
 920                         }
 921                         break;
<span class="line-modified"> 922                     } else if (accept(&#39;*&#39;)) { // (Spec. 3.7)</span>
 923                         boolean isEmpty = false;

 924                         CommentStyle style;
<span class="line-modified"> 925 </span>
<span class="line-added"> 926                         if (accept(&#39;*&#39;)) {</span>
 927                             style = CommentStyle.JAVADOC;
<span class="line-modified"> 928 </span>
<span class="line-modified"> 929                             if (is(&#39;/&#39;)) {</span>
 930                                 isEmpty = true;
 931                             }
 932                         } else {
 933                             style = CommentStyle.BLOCK;
 934                         }
<span class="line-modified"> 935 </span>
<span class="line-modified"> 936                         if (!isEmpty) {</span>
<span class="line-modified"> 937                             while (isAvailable()) {</span>
<span class="line-modified"> 938                                 if (accept(&#39;*&#39;)) {</span>
<span class="line-modified"> 939                                     if (is(&#39;/&#39;)) {</span>
<span class="line-modified"> 940                                         break;</span>
<span class="line-added"> 941                                     }</span>
<span class="line-added"> 942                                 } else {</span>
<span class="line-added"> 943                                     next();</span>
<span class="line-added"> 944                                 }</span>
 945                             }
 946                         }
<span class="line-modified"> 947 </span>
<span class="line-modified"> 948                         if (accept(&#39;/&#39;)) {</span>
<span class="line-modified"> 949                             comments = appendComment(comments, processComment(pos, position(), style));</span>
<span class="line-added"> 950 </span>
 951                             break;
 952                         } else {
 953                             lexError(pos, Errors.UnclosedComment);
<span class="line-added"> 954 </span>
 955                             break loop;
 956                         }
<span class="line-modified"> 957                     } else if (accept(&#39;=&#39;)) {</span>
<span class="line-modified"> 958                         tk = TokenKind.SLASHEQ; // (Spec. 3.12)</span>

 959                     } else {
<span class="line-modified"> 960                         tk = TokenKind.SLASH; // (Spec. 3.12)</span>
 961                     }
 962                     break loop;
<span class="line-modified"> 963 </span>
<span class="line-modified"> 964                 case &#39;\&#39;&#39;: // (Spec. 3.10)</span>
<span class="line-modified"> 965                     next();</span>
<span class="line-added"> 966 </span>
<span class="line-added"> 967                     if (accept(&#39;\&#39;&#39;)) {</span>
 968                         lexError(pos, Errors.EmptyCharLit);

 969                     } else {
<span class="line-modified"> 970                         if (isEOLN()) {</span>
 971                             lexError(pos, Errors.IllegalLineEndInCharLit);
<span class="line-modified"> 972                         }</span>
<span class="line-modified"> 973 </span>
<span class="line-modified"> 974                         scanLitChar(pos);</span>
<span class="line-added"> 975 </span>
<span class="line-added"> 976                         if (accept(&#39;\&#39;&#39;)) {</span>
 977                             tk = TokenKind.CHARLITERAL;
 978                         } else {
 979                             lexError(pos, Errors.UnclosedCharLit);
 980                         }
 981                     }
 982                     break loop;
<span class="line-modified"> 983 </span>
<span class="line-added"> 984                 case &#39;\&quot;&#39;: // (Spec. 3.10)</span>
 985                     scanString(pos);
 986                     break loop;
<span class="line-added"> 987 </span>
 988                 default:
<span class="line-modified"> 989                     if (isSpecial(get())) {</span>
 990                         scanOperator();
 991                     } else {
 992                         boolean isJavaIdentifierStart;
<span class="line-modified"> 993 </span>
<span class="line-modified"> 994                         if (isASCII()) {</span>
 995                             // all ASCII range chars already handled, above
 996                             isJavaIdentifierStart = false;
 997                         } else {
<span class="line-modified"> 998                             isJavaIdentifierStart = isSurrogate()</span>
<span class="line-modified"> 999                                     ? Character.isJavaIdentifierStart(getCodepoint())</span>
<span class="line-modified">1000                                     : Character.isJavaIdentifierStart(get());</span>





1001                         }
<span class="line-added">1002 </span>
1003                         if (isJavaIdentifierStart) {
1004                             scanIdent();
<span class="line-modified">1005                         } else if (digit(pos, 10) &gt;= 0) {</span>
1006                             scanNumber(pos, 10);
<span class="line-modified">1007                         } else if (is((char)EOI) || !isAvailable()) {</span>
1008                             tk = TokenKind.EOF;
<span class="line-modified">1009                             pos = position();</span>
1010                         } else {
1011                             String arg;
1012 
<span class="line-modified">1013                             if (isSurrogate()) {</span>
<span class="line-modified">1014                                 int codePoint = getCodepoint();</span>
<span class="line-modified">1015                                 char hi = Character.highSurrogate(codePoint);</span>
<span class="line-modified">1016                                 char lo = Character.lowSurrogate(codePoint);</span>
<span class="line-added">1017                                 arg = String.format(&quot;\\u%04x\\u%04x&quot;, (int) hi, (int) lo);</span>
1018                             } else {
<span class="line-modified">1019                                 char ch = get();</span>
<span class="line-modified">1020                                 arg = (32 &lt; ch &amp;&amp; ch &lt; 127) ? String.format(&quot;%s&quot;, ch) :</span>
<span class="line-modified">1021                                                               String.format(&quot;\\u%04x&quot;, (int) ch);</span>
1022                             }
<span class="line-added">1023 </span>
1024                             lexError(pos, Errors.IllegalChar(arg));
<span class="line-modified">1025                             next();</span>
1026                         }
1027                     }
1028                     break loop;
1029                 }
1030             }
<span class="line-modified">1031 </span>
<span class="line-modified">1032             int endPos = position();</span>
<span class="line-modified">1033 </span>
<span class="line-modified">1034             if (tk.tag == Token.Tag.DEFAULT) {</span>
<span class="line-modified">1035                 return new Token(tk, pos, endPos, comments);</span>
<span class="line-modified">1036             } else  if (tk.tag == Token.Tag.NAMED) {</span>
<span class="line-modified">1037                 return new NamedToken(tk, pos, endPos, name, comments);</span>
<span class="line-modified">1038             } else {</span>
<span class="line-modified">1039                 // Get characters from string buffer.</span>
<span class="line-modified">1040                 String string = sb.toString();</span>
<span class="line-modified">1041 </span>
<span class="line-modified">1042                 // If a text block.</span>
<span class="line-modified">1043                 if (isTextBlock) {</span>
<span class="line-modified">1044                     // Verify that the incidental indentation is consistent.</span>
<span class="line-modified">1045                     if (lint.isEnabled(LintCategory.TEXT_BLOCKS)) {</span>
<span class="line-modified">1046                         Set&lt;TextBlockSupport.WhitespaceChecks&gt; checks =</span>
<span class="line-modified">1047                                 TextBlockSupport.checkWhitespace(string);</span>
<span class="line-modified">1048                         if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {</span>
<span class="line-modified">1049                             lexWarning(LintCategory.TEXT_BLOCKS, pos,</span>
<span class="line-modified">1050                                     Warnings.InconsistentWhiteSpaceIndentation);</span>

1051                         }
<span class="line-modified">1052                         if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {</span>
<span class="line-modified">1053                             lexWarning(LintCategory.TEXT_BLOCKS, pos,</span>
<span class="line-modified">1054                                     Warnings.TrailingWhiteSpaceWillBeRemoved);</span>


1055                         }
1056                     }
<span class="line-modified">1057                     // Remove incidental indentation.</span>
<span class="line-modified">1058                     try {</span>
<span class="line-modified">1059                         string = string.stripIndent();</span>
<span class="line-modified">1060                     } catch (Exception ex) {</span>
<span class="line-modified">1061                         // Error already reported, just use unstripped string.</span>
<span class="line-modified">1062                     }</span>
<span class="line-modified">1063                 }</span>
<span class="line-added">1064 </span>
<span class="line-added">1065                 // Translate escape sequences if present.</span>
<span class="line-added">1066                 if (hasEscapeSequences) {</span>
<span class="line-added">1067                     try {</span>
<span class="line-added">1068                         string = string.translateEscapes();</span>
<span class="line-added">1069                     } catch (Exception ex) {</span>
<span class="line-added">1070                         // Error already reported, just use untranslated string.</span>
1071                     }
<span class="line-added">1072                 }</span>
<span class="line-added">1073 </span>
<span class="line-added">1074                 if (tk.tag == Token.Tag.STRING) {</span>
1075                     // Build string token.
1076                     return new StringToken(tk, pos, endPos, string, comments);
<span class="line-added">1077                 } else {</span>
<span class="line-added">1078                     // Build numeric token.</span>
<span class="line-added">1079                     return new NumericToken(tk, pos, endPos, string, radix, comments);</span>
1080                 }


1081             }
<span class="line-modified">1082         } finally {</span>
<span class="line-modified">1083             int endPos = position();</span>
<span class="line-added">1084 </span>
1085             if (scannerDebug) {
1086                     System.out.println(&quot;nextToken(&quot; + pos
1087                                        + &quot;,&quot; + endPos + &quot;)=|&quot; +
<span class="line-modified">1088                                        new String(getRawCharacters(pos, endPos))</span>
1089                                        + &quot;|&quot;);
1090             }
1091         }
1092     }






1093 
<span class="line-modified">1094     /**</span>
<span class="line-added">1095      * Appends a comment to the list of comments preceding the current token.</span>
<span class="line-added">1096      *</span>
<span class="line-added">1097      * @param comments  existing list of comments.</span>
<span class="line-added">1098      * @param comment   comment to append.</span>
<span class="line-added">1099      *</span>
<span class="line-added">1100      * @return new list with comment prepended to the existing list.</span>
<span class="line-added">1101      */</span>
<span class="line-added">1102     List&lt;Comment&gt; appendComment(List&lt;Comment&gt; comments, Comment comment) {</span>
<span class="line-added">1103         return comments == null ?</span>
<span class="line-added">1104                 List.of(comment) :</span>
<span class="line-added">1105                 comments.prepend(comment);</span>
<span class="line-added">1106     }</span>
<span class="line-added">1107 </span>
<span class="line-added">1108     /**</span>
<span class="line-added">1109      * Return the position where a lexical error occurred.</span>
<span class="line-added">1110      *</span>
<span class="line-added">1111      * @return position in the input buffer of where the error occurred.</span>
1112      */
1113     public int errPos() {
1114         return errPos;
1115     }
1116 
<span class="line-modified">1117     /**</span>
<span class="line-added">1118      * Set the position where a lexical error occurred.</span>
<span class="line-added">1119      *</span>
<span class="line-added">1120      * @param pos  position in the input buffer of where the error occurred.</span>
1121      */
1122     public void errPos(int pos) {
1123         errPos = pos;
1124     }
1125 
1126     /**
1127      * Called when a complete comment has been scanned. pos and endPos
1128      * will mark the comment boundary.
<span class="line-added">1129      *</span>
<span class="line-added">1130      * @param pos     position of the opening / in the input buffer.</span>
<span class="line-added">1131      * @param endPos  position + 1 of the closing / in the input buffer.</span>
<span class="line-added">1132      * @param style   style of comment.</span>
<span class="line-added">1133      *</span>
<span class="line-added">1134      * @return the constructed BasicComment.</span>
1135      */
1136     protected Tokens.Comment processComment(int pos, int endPos, CommentStyle style) {
<span class="line-modified">1137         if (scannerDebug) {</span>
1138             System.out.println(&quot;processComment(&quot; + pos
<span class="line-modified">1139                                 + &quot;,&quot; + endPos + &quot;,&quot; + style + &quot;)=|&quot;</span>
<span class="line-modified">1140                                 + new String(getRawCharacters(pos, endPos))</span>
<span class="line-modified">1141                                 + &quot;|&quot;);</span>
<span class="line-modified">1142         }</span>
<span class="line-modified">1143 </span>
<span class="line-added">1144         char[] buf = getRawCharacters(pos, endPos);</span>
<span class="line-added">1145 </span>
<span class="line-added">1146         return new BasicComment(style, fac, buf, pos);</span>
1147     }
1148 
1149     /**
1150      * Called when a complete whitespace run has been scanned. pos and endPos
1151      * will mark the whitespace boundary.
<span class="line-added">1152      *</span>
<span class="line-added">1153      * (Spec 3.6)</span>
<span class="line-added">1154      *</span>
<span class="line-added">1155      * @param pos     position in input buffer of first whitespace character.</span>
<span class="line-added">1156      * @param endPos  position + 1 in input buffer of last whitespace character.</span>
1157      */
1158     protected void processWhiteSpace(int pos, int endPos) {
<span class="line-modified">1159         if (scannerDebug) {</span>
1160             System.out.println(&quot;processWhitespace(&quot; + pos
<span class="line-modified">1161                                 + &quot;,&quot; + endPos + &quot;)=|&quot; +</span>
<span class="line-modified">1162                                 new String(getRawCharacters(pos, endPos))</span>
<span class="line-modified">1163                                 + &quot;|&quot;);</span>
<span class="line-added">1164         }</span>
1165     }
1166 
1167     /**
1168      * Called when a line terminator has been processed.
<span class="line-added">1169      *</span>
<span class="line-added">1170      * @param pos     position in input buffer of first character in sequence.</span>
<span class="line-added">1171      * @param endPos  position + 1 in input buffer of last character in sequence.</span>
1172      */
1173     protected void processLineTerminator(int pos, int endPos) {
<span class="line-modified">1174         if (scannerDebug) {</span>
1175             System.out.println(&quot;processTerminator(&quot; + pos
<span class="line-modified">1176                                 + &quot;,&quot; + endPos + &quot;)=|&quot; +</span>
<span class="line-modified">1177                                 new String(getRawCharacters(pos, endPos))</span>
<span class="line-modified">1178                                 + &quot;|&quot;);</span>
<span class="line-added">1179         }</span>
1180     }
1181 
<span class="line-modified">1182     /**</span>
<span class="line-modified">1183      * Build a map for translating between line numbers and positions in the input.</span>
1184      *
<span class="line-modified">1185      * @return a LineMap</span>
<span class="line-added">1186      */</span>
1187     public Position.LineMap getLineMap() {
<span class="line-modified">1188         return Position.makeLineMap(getRawCharacters(), length(), false);</span>
1189     }
1190 

1191     /**
<span class="line-modified">1192      * Scan a documentation comment; determine if a deprecated tag is present.</span>
<span class="line-modified">1193      * Called once the initial /, * have been skipped, positioned at the second *</span>
<span class="line-modified">1194      * (which is treated as the beginning of the first line).</span>
<span class="line-modified">1195      * Stops positioned at the closing &#39;/&#39;.</span>
<span class="line-modified">1196      */</span>
<span class="line-modified">1197     protected static class BasicComment extends PositionTrackingReader implements Comment {</span>
<span class="line-modified">1198         /**</span>
<span class="line-added">1199          * Style of comment</span>
<span class="line-added">1200          *   LINE starting with //</span>
<span class="line-added">1201          *   BLOCK starting with /*</span>
<span class="line-added">1202          *   JAVADOC starting with /**</span>
<span class="line-added">1203          */</span>
1204         CommentStyle cs;

1205 
<span class="line-added">1206         /**</span>
<span class="line-added">1207          * true if comment contains @deprecated at beginning of a line.</span>
<span class="line-added">1208          */</span>
1209         protected boolean deprecatedFlag = false;
<span class="line-added">1210 </span>
<span class="line-added">1211         /**</span>
<span class="line-added">1212          * true if comment has been fully scanned.</span>
<span class="line-added">1213          */</span>
1214         protected boolean scanned = false;
1215 
<span class="line-modified">1216         /**</span>
<span class="line-modified">1217          * Constructor.</span>
<span class="line-added">1218          *</span>
<span class="line-added">1219          * @param cs      comment style</span>
<span class="line-added">1220          * @param sf      Scan factory.</span>
<span class="line-added">1221          * @param array   Array containing contents of source.</span>
<span class="line-added">1222          * @param offset  Position offset in original source buffer.</span>
<span class="line-added">1223          */</span>
<span class="line-added">1224         protected BasicComment(CommentStyle cs, ScannerFactory sf, char[] array, int offset) {</span>
<span class="line-added">1225             super(sf, array, offset);</span>
1226             this.cs = cs;
1227         }
1228 
<span class="line-added">1229         /**</span>
<span class="line-added">1230          * Return comment body text minus comment adornments or null if not scanned.</span>
<span class="line-added">1231          *</span>
<span class="line-added">1232          * @return comment body text.</span>
<span class="line-added">1233          */</span>
1234         public String getText() {
1235             return null;
1236         }
1237 
<span class="line-added">1238         /**</span>
<span class="line-added">1239          * Return buffer position in original buffer mapped from buffer position in comment.</span>
<span class="line-added">1240          *</span>
<span class="line-added">1241          * @param pos  buffer position in comment.</span>
<span class="line-added">1242          *</span>
<span class="line-added">1243          * @return buffer position in original buffer.</span>
<span class="line-added">1244          */</span>
1245         public int getSourcePos(int pos) {
1246             return -1;
1247         }
1248 
<span class="line-added">1249         /**</span>
<span class="line-added">1250          * Return style of comment.</span>
<span class="line-added">1251          *   LINE starting with //</span>
<span class="line-added">1252          *   BLOCK starting with /*</span>
<span class="line-added">1253          *   JAVADOC starting with /**</span>
<span class="line-added">1254          *</span>
<span class="line-added">1255          * @return</span>
<span class="line-added">1256          */</span>
1257         public CommentStyle getStyle() {
1258             return cs;
1259         }
1260 
<span class="line-added">1261         /**</span>
<span class="line-added">1262          * true if comment contains @deprecated at beginning of a line.</span>
<span class="line-added">1263          *</span>
<span class="line-added">1264          * @return true if comment contains @deprecated.</span>
<span class="line-added">1265          */</span>
1266         public boolean isDeprecated() {
1267             if (!scanned &amp;&amp; cs == CommentStyle.JAVADOC) {
1268                 scanDocComment();
1269             }
<span class="line-added">1270 </span>
1271             return deprecatedFlag;
1272         }
1273 
<span class="line-modified">1274         /**</span>
<span class="line-added">1275          * Scan JAVADOC comment for details.</span>
<span class="line-added">1276          */</span>
1277         protected void scanDocComment() {
1278             try {
1279                 boolean deprecatedPrefix = false;
<span class="line-modified">1280                 accept(&quot;/**&quot;);</span>


1281 
1282                 forEachLine:
<span class="line-modified">1283                 while (isAvailable()) {</span>

1284                     // Skip optional WhiteSpace at beginning of line
<span class="line-modified">1285                     skipWhitespace();</span>


1286 
1287                     // Skip optional consecutive Stars
<span class="line-modified">1288                     while (accept(&#39;*&#39;)) {</span>
<span class="line-modified">1289                         if (is(&#39;/&#39;)) {</span>

1290                             return;
1291                         }
1292                     }
1293 
1294                     // Skip optional WhiteSpace after Stars
<span class="line-modified">1295                     skipWhitespace();</span>


1296 

1297                     // At beginning of line in the JavaDoc sense.
<span class="line-modified">1298                     deprecatedPrefix = deprecatedFlag || accept(&quot;@deprecated&quot;);</span>











1299 
<span class="line-modified">1300                     if (deprecatedPrefix &amp;&amp; isAvailable()) {</span>
<span class="line-modified">1301                         if (Character.isWhitespace(get())) {</span>
1302                             deprecatedFlag = true;
<span class="line-modified">1303                         } else if (accept(&#39;*&#39;)) {</span>
<span class="line-modified">1304                             if (is(&#39;/&#39;)) {</span>

1305                                 deprecatedFlag = true;
1306                                 return;
1307                             }
1308                         }
1309                     }
1310 
1311                     // Skip rest of line
<span class="line-modified">1312                     while (isAvailable()) {</span>
<span class="line-modified">1313                         switch (get()) {</span>
1314                             case &#39;*&#39;:
<span class="line-modified">1315                                 next();</span>
<span class="line-modified">1316 </span>
<span class="line-added">1317                                 if (is(&#39;/&#39;)) {</span>
1318                                     return;
1319                                 }
<span class="line-added">1320 </span>
1321                                 break;
<span class="line-modified">1322                             case &#39;\r&#39;: // (Spec 3.4)</span>
<span class="line-modified">1323                             case &#39;\n&#39;: // (Spec 3.4)</span>
<span class="line-modified">1324                                 accept(&#39;\r&#39;);</span>
<span class="line-modified">1325                                 accept(&#39;\n&#39;);</span>




1326                                 continue forEachLine;
<span class="line-added">1327 </span>
1328                             default:
<span class="line-modified">1329                                 next();</span>
<span class="line-added">1330                                 break;</span>
1331                         }
1332                     } // rest of line
1333                 } // forEachLine
1334                 return;
1335             } finally {
1336                 scanned = true;
1337             }
1338         }
1339     }
1340 }
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JavadocTokenizer.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>